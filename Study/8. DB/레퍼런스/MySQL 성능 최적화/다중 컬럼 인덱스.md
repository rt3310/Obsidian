다중 컬럼 인덱스(Multiple-column indexes)는 복합 인덱스(composite indexes)라고도 알려져 있으며 이는 테이블의 여러 컬럼을 조합해서 구성되는 인덱스를 말한다.

중요한 건 복합 인덱스는 명시된 컬럼의 순으로 정렬되어 있다는 것이다.

복합 인덱스를 설계할 때 컬럼 순서에 따라서 쿼리의 성능이 급격하게 차이가 나기 때문에 올바르게 설계하는 것이 중요하다.

다음과 같이 `(이름, 시력)`으로 인덱스가 구축된 경우를 보자
- 먼저 이름 순대로 정렬되어 있고 이후에 시력 순대로 정렬되어 잇다.
- 그러므로 이름이 먼저 정렬되어 있기 때문에 `시력`만으로 쿼리를 날릴 경우에 인덱스 풀 스캔이 발생할 것이다.

## 효과적인 설계 전략

일반적인 복합 인덱스를 설계하는 기준은 Cardinality이다.

Cardinality가 높은 컬럼을 복합 인덱스의 선행 컬럼으로 두는 것이다.

중요한 건 Cardinality만 고려해서 인덱스를 설계하면 안된다는 것이다. 이것 말고도 고려할 사항은 많다.
- 자주 사용하는 쿼리가 무엇인가?
	- 특정 컬럼을 단독으로 사용하는 쿼리들도 많다면 해당 컬럼이 Cardinality가 좀 떨어지더라도 충분히 인덱스의 선행 컬럼으로 두는 것도 좋은 선택이다.
- 조인에도 인덱스를 사용하는가?
	- 조인에 자주 사용되는 컬럼을 선행 컬럼으로 두면 조인 처리에 도움이 된다.
- 인덱스의 선행 칼럼이 범위 기반의 쿼리로 많이 이용되는가?
	- 선행 컬럼이 범위 쿼리로 사용된다면 이는 Cardinality가 높더라도 많은 범위의 인덱스 탐색이 이루어질 수 있기 때문에 선행 컬럼으로 적합하지 않을 수 있다.
- 이렇게 인덱스를 설계하면 슬로우 쿼리가 발생하지 않을까?
	- 슬로우 쿼리가 하나씩 누적되면 DB 성능에 큰 영향을 준다.

컬럼의 Cardinality는 어떻게 확인할 수 있을까?
- 이미 생성된 인덱스라면 인덱스 통계 테이블(=`innodb_index_stats`)을 통해서 볼 수 있다.
- 아직 인덱스를 생성하지 않았더라면 MySQL 8.0에서는 히스토그램을 통해서 확인할 수 있다.
```sql
ANALYZE TABLE your_table UPDATE HISTOGRAM ON your_column WITH 100 BUCKETS;
```
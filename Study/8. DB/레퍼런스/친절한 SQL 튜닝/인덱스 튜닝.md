
## 테이블 랜덤 액세스

데이터가 많아도 인덱스를 사용하면 데이터가 금방 조회된다.
하지만, 대량 데이터를 조회할 때 인덱스를 사용하면 테이블 전체를 스캔할 때보다 훨씬 느릴 수 있다.

### 인덱스 ROWID
SQL이 참조하는 컬럼은 인덱스가 모두 포함하는 경우가 아니면, 인덱스를 스캔한 후에 반드시 테이블을 액세스한다. 실행계획에서 'TABLE ACCESS BY INDEX ROWID'라고 표시된 부분이 여기에 해당한다.
```sql
select * from 고객 where 지역 = '서울';
```
```
Execution Plan
-----------------------------------------------------
0 SELECT STATEMENT Optimizer=ALL_ROWS
1 	TABLE ACCESS BY INDEX ROWID OF '고객' (TABLE)
2 		INDEX RANGE SCAN OF '고객_지역_IDX' (INDEX)
```

인덱스를 스캔하는 이유는, 검색 조건을 만족하는 소량의 데이터를 인덱스에서 빨리 찾고 거기서 테이블 레코드를 찾아가기 위한 주소값, 즉 ROWID를 얻으려는 데 있다.

그렇다면 인덱스 ROWID는 물리적 주소일까, 논리적 주소일까?
인덱스 ROWID를 물리적 주소라고 생각한다면, 그것이 데이터파일 번호, 오브젝트 번호, 블록 번호 같은 물리적 요소로 구성돼 있어서다. 그런 의미에서 ROWID를 물리적 주소라고 설명한다면 틀리다고 말할 수 없다. 하지만 인덱스 ROWID는 물리적 주소보다 **논리적 주소**에 가깝다. **물리적으로 직접 연결되지 않고 테이블 레코드를 찾아가기 위한 논리적 주소 정보를 담고 있기 때문**이다.

정리하면, 인덱스 ROWID는 논리적 주소다. **디스크 상에서 테이블 레코드를 찾아가기 위한 위치 정보를 담는다**. (프로그래밍에서 말하는) 포인터가 아니며, 테이블 레코드와 물리적으로 직접 연결된 구조는 더더욱 아니다.


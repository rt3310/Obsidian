## Index Skip Scan을 이용한 비효율 해소

고객번호, 판매월, 판매구분, 판매금액으로 일어진 `월별고객판매집계` 테이블이 있다고 가정한다.
이때 판매구분 + 판매월을 기준으로 조회해야 할 때 어떻게 개선할 수 있을지 확인해보자.

### Case 1
인덱스: 판매구분 + 판매월
```sql
select count(*)
from 월별고객판매집계 t
where 판매구분 = 'A'
and 판매월 between 200801 and 200812
```

실행계획을 수행해보면 ConsistencyRead(LogicalRead)는 281이 나온다.
만약 `판매월 + 판매구분`으로 인덱스가 잡혀있다면 어떻게 될까?

### Case 2
인덱스: 판매월 + 판매구분
```sql
select count(*)
from 월별고객판매집계 t
where 판매구분 = 'A'
and 판매월 between 200801 and 200812
```

Case 1과 동일하게 조건을 사용하게 되면 ConsistencyRead는 **3090**이 나온다.
즉, 전에 했던 것과 동일하게 between이 먼저 인덱스 조건이 되어 뒤의 판매구분이 전혀 인덱스 효과를 발휘하지 못하고 Case 1에 비해 굉장히 비효율적인 인덱스가 된다.

그럼 `판매구분 + 판매월`로 인덱스를 변경하면 어떻게 될까?
실제 운영환경에서 인덱스를 변경하는 일은 굉장히 부담이 된다. 왜냐하면 해당 테이블의 인덱스를 다시 생성해야 하는데 이 시간동안 해당 테이블에 등록/수정/삭제는 부담이 되기 때문이다.
보통 한번 만든 인덱스는 거의 변경하지 않거나, 가장 사용률이 적은 시간 때에 수정하는 등 최대한 자제하는 편이다.
그럼 이렇게 이미 `판매월 + 판매구분`으로 지정된 상태에서 어떻게 인덱스 효율을 높일지 확인해보자.

### Case 3
인덱스: 판매월 + 판매구분, in list
```sql
select count(*)
from 월별고객판매집계 t
where 판매구분 = 'A'
and 판매월 in ('200801','200802','200803','200804','200805','200806','200807','200808','200808','200810','200811','200812');
```
between의 비효율은 이미 알고 있다.
이를 개선하기 위한 첫 번째 방법으로 **in list**를 사용하는 것이다.

in은 **union all + equal(=)을 여러 개 연결한 것과 동일**하다.
즉, 각 판매월을 = 조건으로 각각 조회하고 이 결과를 합친 것이기 때문에 인덱스 효과를 볼 수 있다.

이 쿼리의 결과는 ConsistencyRead가 **314**가 된다.
between의 결과가 3090인 것에 비하면 약 10배가 향상된 것을 확인할 수 있다.

### Case 4
인덱스: 판매월 + 판매구분, Skip Scan
```sql
select /* INDEX_SS (t 월별고객별판매집계_IDX2) */ count(*)
from 월별고객판매집계 t
where 판매구분 = 'A'
and 판매월 between 200801 and 200812
```
Case 2의 쿼리와 다른 것으로는, 옵티마이저 힌트로 SkipScan을 제공(`/ *INDEX_SS (t 월별고객별판매집계_IDX2) */`) 한 것이다.
이 경우 인덱스는 불필요한 부분을 Skip하며 스캔을 하게 된다.

![[Pasted image 20250323173054.png]](Index Skip Scan 진행방향)

불필요한 부분을 읽지 않기 때문에 비효율이 많이 개선된다.
이 쿼리의 ConsistencyRead는 **300**이 된다.

### 결론
|  구분   | 인덱스변경 | Between | In LIst | Skip Scan |
| :---: | :---: | :-----: | :-----: | :-------: |
| 블록 IO |  281  |  3090   |   314   |    300    |
- 판매월의 distinct가 낮을수록 in-list가 between보다 유리하다.
	- 즉, 중복된 값이 많을수록 in list 효율은 증가한다.
- 인덱스의 수직적 탐색 (root에서부터 leaf까지의 탐색)이 많은 in-list보다는 Index Skip Scan이 근소하게 유리하다.

## 범위 검색 조건을 남용할 때 발생하는 비효율

회사, 지역, 상품명을 입력하여 '가입상품' 테이블에서 데이터를 조회하는 프로그램을 만든다고 가정해보자.
조건은 다음과 같다.
1. 회사는 반드시 입력
2. 지역은 입력하지 않을 수도 있다.
3. 상품명은 단어 중 일부만 입력하고도 조회 가능

인덱스: 회사 + 지역 + 상품명

위 조건을 만족하기 위해서 보통은 쿼리를 2개로 나눠서 생성한다.
### 지역조건이 있을 경우
```sql
select *
from 가입상품
where 회사 = :com
and 지역 = :reg
and 상품명 like :prod || '%'
```
### 지역조건이 없을 경우
```sql
select ...
from 가입상품
where 회사 = :com
and  상품명 like :prod || '%'
```

이 쿼리들의 인덱스 스캔 범위는 아래와 같다.
![[Pasted image 20250323174458.png]]

지역조건이 있는 쿼리와 없는 쿼리는 인덱스 스캔 범위가 확연히 차이가 난다.
개발을 하다 보면 이렇게 유사한 쿼리를 1개의 쿼리로 수행하려고 작성할 때가 종종 있다.

만약 1개의 쿼리로 작성할 때 아래와 같이 한다면 어떨까?
```sql
select *
from 가입상품
where 회사 = :com
and 지역 like :reg || '%'
and 상품명 like :prod || '%'
```

이렇게 한방쿼리를 작성했을 때 인덱스 탐색 범위는 아래와 같다.
![[Pasted image 20250323174625.png]]
한방쿼리를 작성하니 오히려 지역조건이 있을 때도 비효율이 발생하게 된다.

이럴 경우 좋은 방안이 있다. `union all`을 사용하는 것이다.
```sql
where :reg is not null
and 회사 = :com
and 지역 = :reg
and 상품명 like :prod
union all
where :reg is null
and 회사 = :com
and 상품명 like :prod
```
물론 지역조건이 없을 경우에는 여전히 비효율이 있지만, 지역조건이 있을 때는 효율적으로 인덱스를 탐색하고 1개의 쿼리로 모든 대응을 할 수 있게 된다.

## 같은 컬럼에 두 개 범위검색 조건 사용 시 주의사항

도서 조회용 프로그램을 개발한다고 가정해보자.
'오라클'을 키워드로 입력하면, '오라클'로 시작하는 모든 도서가 조회되는 기능이 필요하며 한 화면에는 10개씩 출력해야 한다.

현재 작성된 쿼리는 아래와 같다.
```sql
select *
from (
	select rownum rnum, 도서번호, 도서명, 가격, 저자, 출판사, isbn
	from (
		select 도서번호, 도서명, 가격, 저자, 출판사, isbn
		from 도서
		where 도서명 like :book_nm || '%'
		order by 도서명
	)
	where rownum <= 100
)
where rnum >= 91
```
위 쿼리는 앞 페이지는 문제가 없지만, 뒤로 갈수록 성능이 늦어지는 문제를 안고있다.
만약 이 상황에서 뒤쪽 어느 페이지로 이동하더라도 빠르게 조회되도록 구현해야 한다면 어떻게 쿼리를 작성해야 할까?

```sql
select *
from (
	---- 이전 조회와 도서명이 같은 경우
	select /*+ index(도서 도서명_idx) */
		rowid rid, 도서번호, 도서명, 가격, 저자, 출판사, isbn
	from 도서
	where 도서명 like : book_nm || '%'
	and 도서명 = :last_book_nm -- 이전 페이지에서 출력된 마지막 도서명
	and rowid > :last_rid -- 이전 페이지에서 출력된 마지막 도서의 rowid
	union all ---- 이전 도서보다 도서명이 큰 경우
	select /*+ index(도서 도서명_idx) */
		rowid rid, 도서번호, 도서명, 가격, 저자, 출판사, isbn
	from 도서
	where 도서명 like :book_nm || '%'
	and 도서명 > :last_book_nm
)
where rownum <= 10;
```
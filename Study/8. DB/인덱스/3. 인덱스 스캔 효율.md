## Index Skip Scan을 이용한 비효율 해소

고객번호, 판매월, 판매구분, 판매금액으로 일어진 `월별고객판매집계` 테이블이 있다고 가정한다.
이때 판매구분 + 판매월을 기준으로 조회해야 할 때 어떻게 개선할 수 있을지 확인해보자.

### Case 1
인덱스: 판매구분 + 판매월
```sql
select count(*)
from 월별고객판매집계 t
where 판매구분 = 'A'
and 판매월 between 200801 and 200812
```

실행계획을 수행해보면 ConsistencyRead(LogicalRead)는 281이 나온다.
만약 `판매월 + 판매구분`으로 인덱스가 잡혀있다면 어떻게 될까?

### Case 2
인덱스: 판매월 + 판매구분
```sql
select count(*)
from 월별고객판매집계 t
where 판매구분 = 'A'
and 판매월 between 200801 and 200812
```

Case 1과 동일하게 조건을 사용하게 되면 ConsistencyRead는 **3090**이 나온다.
즉, 전에 했던 것과 동일하게 between이 먼저 인덱스 조건이 되어 뒤의 판매구분이 전혀 인덱스 효과를 발휘하지 못하고 Case 1에 비해 굉장히 비효율적인 인덱스가 된다.

그럼 `판매구분 + 판매월`로 인덱스를 변경하면 어떻게 될까?
실제 운영환경에서 인덱스를 변경하는 일은 굉장히 부담이 된다. 왜냐하면 해당 테이블의 인덱스를 다시 생성해야 하는데 이 시간동안 해당 테이블에 등록/수정/삭제는 부담이 되기 때문이다.
보통 한번 만든 인덱스는 거의 변경하지 않거나, 가장 사용률이 적은 시간 때에 수정하는 등 최대한 자제하는 편이다.
그럼 이렇게 이미 `판매월 + 판매구분`으로 지정된 상태에서 어떻게 인덱스 효율을 높일지 확인해보자.

### Case 3
인덱스: 판매월 + 판매구분, in list
```sql
select count(*)
from 월별고객판매집계 t
where 판매구분 = 'A'
and 판매월 in ('200801','200802','200803','200804','200805','200806','200807','200808','200808','200810','200811','200812');
```
between의 비효율은 이미 알고 있다.
이를 개선하기 위한 첫 번째 방법으로 **in list**를 사용하는 것이다.

in은 **union all + equal(=)을 여러 개 연결한 것과 동일**하다.
즉, 각 판매월을 = 조건으로 각각 조회하고 이 결과를 합친 것이기 때문에 인덱스 효과를 볼 수 있다.

이 쿼리의 결과는 ConsistencyRead가 **314**가 된다.
between의 결과가 3090인 것에 비하면 약 10배가 향상된 것을 확인할 수 있다.

### Case 4
인덱스: 판매월 + 판매구분, Skip Scan
```sql
select /* INDEX_SS (t 월별고객별판매집계_IDX2) */ count(*)
from 월별고객판매집계 t
where 판매구분 = 'A'
and 판매월 between 200801 and 200812
```
Case 2의 쿼리와 다른 것으로는, 옵티마이저 힌트로 SkipScan을 제공(`/ *INDEX_SS (t 월별고객별판매집계_IDX2) */`) 한 것이다.
이 경우 인덱스는 불필요한 부분을 Skip하며 스캔을 하게 된다.

![[Pasted image 20250323173054.png]](Index Skip Scan 진행방향)

불필요한 부분을 읽지 않기 때문에 비효율이 많이 개선된다.
이 쿼리의 ConsistencyRead는 **300**이 된다.

### 결론
|  구분   | 인덱스변경 | Between | In LIst | Skip Scan |
| :---: | :---: | :-----: | :-----: | :-------: |
| 블록 IO |  281  |  3090   |   314   |    300    |
- 판매월의 distinct가 낮을수록 in-list가 between보다 유리하다.
	- 즉, 중복된 값이 많을수록 in list 효율은 증가한다.
- 인덱스의 수직적 탐색 (root에서부터 leaf까지의 탐색)이 많은 in-list보다는 Index Skip Scan이 근소하게 유리하다.


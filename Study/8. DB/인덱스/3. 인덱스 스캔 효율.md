## Index Skip Scan을 이용한 비효율 해소

고객번호, 판매월, 판매구분, 판매금액으로 일어진 `월별고객판매집계` 테이블이 있다고 가정한다.
이때 판매구분 + 판매월을 기준으로 조회해야 할 때 어떻게 개선할 수 있을지 확인해보자.

### Case 1
인덱스: 판매구분 + 판매월
```sql
select count(*)
from 월별고객판매집계 t
where 판매구분 = 'A'
and 판매월 between 200801 and 200812
```

실행계획을 수행해보면 ConsistencyRead(LogicalRead)는 281이 나온다.
만약 `판매월 + 판매구분`으로 인덱스가 잡혀있다면 어떻게 될까?

### Case 2
인덱스: 판매월 + 판매구분
```sql
select count(*)
from 월별고객판매집계 t
where 판매구분 = 'A'
and 판매월 between 200801 and 200812
```

Case 1과 동일하게 조건을 사용하게 되면 ConsistencyRead는 **3090**이 나온다.
즉, 전에 했던 것과 동일하게 between이 먼저 인덱스 조건이 되어 뒤의 판매구분이 전혀 인덱스 효과를 발휘하지 못하고 Case 1에 비해 굉장히 비효율적인 인덱스가 된다.

그럼 `판매구분 + 판매월`로 인덱스를 변경하면 어떻게 될까?
실제 운영환경에서 인덱스를 변경하는 일은 굉장히 부담이 된다. 왜냐하면 해당 테이블의 인덱스를 다시 생성해야 하는데 이 시간동안 해당 테이블에 등록/수정/삭제는 부담이 되기 때문이다.
보통 한번 만든 인덱스는 거의 변경하지 않거나, 가장 사용률이 적은 시간 때에 수정하는 등 최대한 자제하는 편이다.
그럼 이렇게 이미 `판매월 + 판매구분`으로 지정된 상태에서 어떻게 인덱스 효율을 높일지 확인해보자.

### Case 3
인덱스: 판매월 + 판매구분, in list
```sql
select count(*)
from 월별고객판매집계 t
where 판매구분 = 'A'
and 판매월 in ('200801','200802','200803','200804','200805','200806','200807','200808','200808','200810','200811','200812');
```
between의 비효율은 이미 알고 있다.
이를 개선하기 위한 첫 번째 방법으로 **in list**를 사용하는 것이다.

in은 **union all + equal(=)을 여러 개 연결한 것과 동일**하다.
즉, 각 판매월을 = 조건으로 각각 조회하고 이 결과를 합친 것이기 때문에 인덱스 효과를 볼 수 있다.

이 쿼리의 결과는 ConsistencyRead가 **314**가 된다.
between의 결과가 3090인 것에 비하면 약 10배가 향상된 것을 확인할 수 있다.

### Case 4
인덱스: 판매월 + 판매구분, Skip Scan
```sql
select /* INDEX_SS (t 월별고객별판매집계_IDX2) */ count(*)
from 월별고객판매집계 t
where 판매구분 = 'A'
and 판매월 between 200801 and 200812
```
Case 2의 쿼리와 다른 것으로는, 옵티마이저 힌트로 SkipScan을 제공(`/ *INDEX_SS (t 월별고객별판매집계_IDX2) */`) 한 것이다.
이 경우 인덱스는 불필요한 부분을 Skip하며 스캔을 하게 된다.

![[Pasted image 20250323173054.png]](Index Skip Scan 진행방향)

불필요한 부분을 읽지 않기 때문에 비효율이 많이 개선된다.
이 쿼리의 ConsistencyRead는 **300**이 된다.

### 결론
|  구분   | 인덱스변경 | Between | In LIst | Skip Scan |
| :---: | :---: | :-----: | :-----: | :-------: |
| 블록 IO |  281  |  3090   |   314   |    300    |
- 판매월의 distinct가 낮을수록 in-list가 between보다 유리하다.
	- 즉, 중복된 값이 많을수록 in list 효율은 증가한다.
- 인덱스의 수직적 탐색 (root에서부터 leaf까지의 탐색)이 많은 in-list보다는 Index Skip Scan이 근소하게 유리하다.

## 범위 검색 조건을 남용할 때 발생하는 비효율

회사, 지역, 상품명을 입력하여 '가입상품' 테이블에서 데이터를 조회하는 프로그램을 만든다고 가정해보자.
조건은 다음과 같다.
1. 회사는 반드시 입력
2. 지역은 입력하지 않을 수도 있다.
3. 상품명은 단어 중 일부만 입력하고도 조회 가능

> 인덱스: 회사 + 지역 + 상품명

위 조건을 만족하기 위해서 보통은 쿼리를 2개로 나눠서 생성한다.
### 지역조건이 있을 경우
```sql
select *
from 가입상품
where 회사 = :com
and 지역 = :reg
and 상품명 like :prod || '%'
```
### 지역조건이 없을 경우
```sql
select ...
from 가입상품
where 회사 = :com
and  상품명 like :prod || '%'
```

이 쿼리들의 인덱스 스캔 범위는 아래와 같다.
![[Pasted image 20250323174458.png]]

지역조건이 있는 쿼리와 없는 쿼리는 인덱스 스캔 범위가 확연히 차이가 난다.
개발을 하다 보면 이렇게 유사한 쿼리를 1개의 쿼리로 수행하려고 작성할 때가 종종 있다.

만약 1개의 쿼리로 작성할 때 아래와 같이 한다면 어떨까?
```sql
select *
from 가입상품
where 회사 = :com
and 지역 like :reg || '%'
and 상품명 like :prod || '%'
```

이렇게 한방쿼리를 작성했을 때 인덱스 탐색 범위는 아래와 같다.
![[Pasted image 20250323174625.png]]
한방쿼리를 작성하니 오히려 지역조건이 있을 때도 비효율이 발생하게 된다.

이럴 경우 좋은 방안이 있다. `union all`을 사용하는 것이다.
```sql
where :reg is not null
and 회사 = :com
and 지역 = :reg
and 상품명 like :prod
union all
where :reg is null
and 회사 = :com
and 상품명 like :prod
```
물론 지역조건이 없을 경우에는 여전히 비효율이 있지만, 지역조건이 있을 때는 효율적으로 인덱스를 탐색하고 1개의 쿼리로 모든 대응을 할 수 있게 된다.

## 같은 컬럼에 두 개 범위검색 조건 사용 시 주의사항

도서 조회용 프로그램을 개발한다고 가정해보자.
'오라클'을 키워드로 입력하면, '오라클'로 시작하는 모든 도서가 조회되는 기능이 필요하며 한 화면에는 10개씩 출력해야 한다.

현재 작성된 쿼리는 아래와 같다.
```sql
select *
from (
	select rownum rnum, 도서번호, 도서명, 가격, 저자, 출판사, isbn
	from (
		select 도서번호, 도서명, 가격, 저자, 출판사, isbn
		from 도서
		where 도서명 like :book_nm || '%'
		order by 도서명
	)
	where rownum <= 100
)
where rnum >= 91
```
위 쿼리는 앞 페이지는 문제가 없지만, 뒤로 갈수록 성능이 늦어지는 문제를 안고있다.
만약 이 상황에서 뒤쪽 어느 페이지로 이동하더라도 빠르게 조회되도록 구현해야 한다면 어떻게 쿼리를 작성해야 할까?

```sql
select *
from (
	---- 이전 조회와 도서명이 같은 경우
	select /*+ index(도서 도서명_idx) */
		rowid rid, 도서번호, 도서명, 가격, 저자, 출판사, isbn
	from 도서
	where 도서명 like : book_nm || '%'
	and 도서명 = :last_book_nm -- 이전 페이지에서 출력된 마지막 도서명
	and rowid > :last_rid -- 이전 페이지에서 출력된 마지막 도서의 rowid
	union all ---- 이전 도서보다 도서명이 큰 경우
	select /*+ index(도서 도서명_idx) */
		rowid rid, 도서번호, 도서명, 가격, 저자, 출판사, isbn
	from 도서
	where 도서명 like :book_nm || '%'
	and 도서명 > :last_book_nm
)
where rownum <= 10;
```
읽은 곳 바로 뒤를 읽는 패턴으로 작성된 쿼리이다.

이 쿼리의 실행계획을 보면
![[Pasted image 20250323190530.png]]
아래쪽 인덱스 스캔 단계에서 377블록을 읽었다.
바로 위에 보면 동일한 Range Scan에서 3블록을 읽은 것을 확인할 수 있다.
이렇게 인덱스 스캔이 발생하는 이유는 `union all` 쿼리의 조건에 있는 `도서명 like :book_nm || '%'` 이 인덱스 조건으로 사용되었기 때문이다.
즉, `도서명%` 로 된 도서를 처음부터 스캔하다가 last_book_nm 보다 큰 9개 row를 찾으면 스캔을 멈추게 된다.
뒤 페이지를 찾으려 할수록 last_book_nm보다 큰 9개 row를 찾는 것에 많은 시간이 필요하게 된다.

이 쿼리를 개선하기 위해선 1번째 조건인 like를 인덱스 조건으로 사용하는 것이 아닌, `>` 조건을 인덱스 조건으로 사용하도록 변경하는 것이다.
인덱스를 못태우도록 `도서명 like` 조건을 아래와 같이 변경한다.
```sql
union all
select /*+ index(도서 도서명_idx) */
	rowid rid, 도서번호, 도서명, 가격, 저자, 출판사
from 도서
where trim(도서명) like :book_nm || '%'
and 도서명 > :last_book_nm
```
trim을 통해 컬럼 값을 가공하여 인덱스를 안타도록 강제하였다.
이렇게 되면 `>` 조건을 인덱스의 조건으로 사용하게 된다.

![[Pasted image 20250324181241.png]]
인덱스를 탔기 때문에 RangeScan의 효율도 상승했다.

## between과 like 스캔 범위 비교

일반적으로 Between을 사용하는 것이 정확한 방식이나, 가끔 편리에 의해 like를 사용하는 경우를 보게된다.
(Between을 사용하면 성능적으로 손해볼 것이 없다.)

### Case 1. A가 10%, B가 90%인 경우
대략 A가 전체의 10%, B가 90%일 경우 between과 like의 스캔 범위는 아래와 같다.
![[Pasted image 20250324181432.png]]

첫번째 줄은 between을 나타내며, 두번째 줄은 like를 나타낸다.
1. between은 시작점과 끝점에선 equals(=)와 같은 효과를 발휘한다.
2. like는 조건 그 이상을 검색하게 된다.
	- 예를 들어 `like 200902%` 로 검색하면 실제 데이터가 200901, 200902 등 6자리로만 구성되어 있어도 20090201, 20090202 등의 데이터가 있는지 DB에선 알 수 없으므로 200902로 되어있는 모든 데이터를 스캔하게 된다.

실제 쿼리를 보고 비교해보자.
#### 쿼리 1
```sql
select count(*)
from 월별고객별판매집계
where 판매월 between '200901' and '200902'
and 판매구분 = 'A';
```
#### 쿼리 2
```sql
select count(*)
from 월별고객별판매집계
where 판매월 like '2009%'
and 판매구분 = 'A';
```
#### 쿼리 3
```sql
select count(*)
from 월별고객별판매집계
where 판매월 >= '200901'
and 판매월 < '200903'
and 판매구분 = 'A';
```
- 쿼리 1: 2009년 1월 데이터는 모두, 2009년 2월 데이터는 판매구분이 'A'인 데이터만 읽는다.
- 쿼리 2: 2009년 1월과 2월 데이터를 모두 읽는다.
- 쿼리 3: '200902' || 'A' 구간만 읽고서 멈추지 못해 결국 like 쿼리와 같은 스캔량을 보인다.

### Case 2. A가 90%, B가 10%인 경우
![[Pasted image 20250324181933.png]]

여기서 아래와 같이 쿼리를 실행해보자.
#### 쿼리 1
```sql
select count(*)
from  월별고객별판매집계
where 판매월 between '200901' and '200902'
and   판매구분 = 'B';
```
#### 쿼리 2
```sql
select count(*)
from  월별고객별판매집계
where 판매월 like '2009%'
and   판매구분 = 'B';
```
#### 쿼리 3
```sql
select count(*)
from  월별고객별판매집계
where 판매월 between '200900' and '200902'
and   판매구분 = 'B'; 
```
#### 쿼리 4
```sql
select count(*)
from  월별고객별판매집계
where 판매월 like '200901%'
and   판매구분 = 'B';
```
- 쿼리 1: 2009년 2월 데이터는 모두 읽더라도 1월 데이터는 판매구분이 'B'인 값만 읽는다.
- 쿼리 2: 2009년 1월과 2월 데이터 모두 읽는다. 1월 데이터를 모두 스캔하는 이유는 '2009'로 조회했기 때문
- 쿼리 3: 쿼리 2와 스캔량은 같다. between이라고 하더라도 쿼리 시작 값을 '200900'으로 입력하고 조회하면 LIKE와 스캔량이 같다.
- 쿼리 4: like지만, 인덱스에서 실제 찾아지는 값을 입력하면 스캔 범위를 줄일 수 있다.

### 결론
범위 검색은 like, `<`, `>`  보다 between이 절대 손해 볼 일이 없음을 확인할 수 있다.

## 선분이력의 인덱스 스캔 효율

### 선분이력이란?
시작시점과 종료시점을 관리하는 것을 얘기한다.

예를 들어, `start_date`, `end_date` 2개의 컬럼을 추가하여 테이블에서 관리되고 있는 것을 얘기한다.

여기서 얘기하려고하는 인덱스 스캔 효율이란, 항상 두 개의 부등호 조건을 함께 사용하는 선분이력에선 두 번째 부등호 조건이 스캔 범위를 줄이는 데 전혀 도움을 주지 못해 비효율이 발생하는 현상을 얘기한다.
(범위 조건의 다음 인덱스 조건은 인덱스를 못타는 이슈 때문이다)

### Case 1. 최근 시점 조회

> 인덱스: 고객번호 + 종료일 + 시작일

예를 들어, 고객번호가 123이며 20050131일의 연체금액을 조회한다고 가정해보자.
```sql
select *
from 고객별연체금액
where 고객번호 = '123'
and '20050131' between 시작일 and 종료일;
```
or
```sql
select *
from 고객별연체금액
where 고객번호 = '123'
and 시작일 <= '20050131'
and 종료일 >= '20050131';
```
위 쿼리의 인덱스 스캔 범위는 아래와 같다.

![[Pasted image 20250324183143.png]]
- `=` 조건인 고객번호 다음 인덱스 컬럼(시작일)이 `<=` 조건이므로 2005년 1월 31일 이전의 많은 이력 레코드를 모두 스캔
- 종료일 조건은 시작일보다 훨씬 적은 범위지만 선두 컬럼(시작일)이 부등호 조건이기 때문에 스캔 범위를 줄이는데 기여하지 못한다.
- 종료일이 인덱스 컬럼에 포함되어 있기 때문에 테이블 Random Access 없이 필터링
- 최종 레코드는 한 건이지만 많은 인덱스 레코드를 스캔하는 문제가 있다.

이런 경우엔 쿼리를 아래와 같이 개선할 수 있다.
```sql
select /*+ index_desc(a idx_x01) */ *
from 고객별연체금액
where 고객번호 = '123'
and '20050131' between 시작일 and 종료일
and rownum <= 1;
```
즉, 인덱스 스캔 시작을 desc 순으로 하고 rownum을 1로 제한하여

### Case 2. 과거 시점 조회

> 인덱스: 고객번호 + 시작일 + 종료일

```sql
select *
from 고객별연체금액
where 고객번호 = '123'
and '20050131' between 시작일 and 종료일;
```
or
```sql
select *
from 고객별연체금액
where 고객번호 = '123'
and 시작일 <= '20050131'
and 종료일 >= '20050131';
```
위 쿼리의 인덱스 스캔 범위는 아래와 같다.
![[Pasted image 20250324183821.png]]
- `=` 조건인 고객번호 다음 인덱스 컬럼(종료일)이 `<=`  조건이므로 2002년 9월 30일 이후의 많은 이력 레코드를 모두 스캔
- 스캔해야 할 범위가 아무리 넓더라도 rownum <= 1 조건을 추가하여 개선

```sql
select *
from 고객별연체금액
where 고객번호 = '123'
and '20050131' between 시작일 and 종료일
and rownum <= 1;
```

### 결론
결론적으로 아래와 같이 인덱스 규칙을 정하면 효율적으로 사용됨을 확인할 수 있었다.
- 최근 데이터를 주로 읽을 때: 종료일자 + 시작일자
- 과거 데이터를 주로 읽을 때: 시작일자 + 종료일자
- 인덱스 수정이 불가능할 경우: Index_Desc 힌트
- 중간 데이터를 주로 읽을 때: 어떤 인덱스든 비효율이 발생하지만 `rownum <= 1` 조건 활용
## 클러스터

클러스터란, 간단하게 여러 개를 하나로 묶는다는 것을 뜻한다.

인덱스에서의 클러스터링은 값이 비슷한 것들을 묶어서 저장하는 형태로 구현되는데, 비슷한 값들을 동시에 조회하는 케이스가 많다라는 부분에서 착안되었다.

> MySQL에서는 InnoDB와 TokuDB 스토리지 엔진에서만 지원하고 나머지에서는 지원하지 않는다.

## 클러스터링 인덱스, 넌클러스터링 인덱스

그렇다면 클러스터링 인덱스(Clustering Index)는 무엇일까?

클러스터링 인덱스는 테이블의 **기본 키(Primary Key)** 에 대해서만 적용되는 내용이다.

이는 기본 키값이 비슷한 레코드끼리 묶어서 저장하는 것을 의미하며 **기본 키값에 의해 레코드의 저장 위치가 결정**되고 **기본 키값이 변경된다면 물리적인 저장 위치가 바뀌어야 된다**는 것을 말한다.

방금 말한 것에서 알 수 있듯이, **기본 키값으로 클러스터링 된 테이블은 기본 키에 의존도가 매우 크기 때문에 신중히 결정해야 한다**.

InnoDB와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 기본 키값으로 저장 위치가 결정되기 때문에 기본 키값 기반의 검색이 매우 빠르지만 레코드의 저장이나 기본 키의 변경이 발생하게 된다면 클러스터링 인덱스를 사용하지 않는 다른 스토리지 엔진에 비해 상대적으로 느리다.

이 클러스터링 인덱스는 우리가 흔히 말하는 인덱스와는 조금 다른 개념이다.
우리가 흔히 말하는 인덱스는 **넌클러스터링 인덱스**로 **MySQL에서는 B+Tree**를 사용한다.

클러스터링 인덱스로 검색하는 것은 책의 페이지를 알고 있어 바로 해당 페이지를 여는 행동과 같다.
넌클러스터링 인덱스로 검색하는 것은 책의 목차에서 찾고자 하는 내용의 페이지를 찾고나서 해당 페이지로 이동하는 행동과 같다.

다음 그림을 통해 자세히 살펴보자.
![[Pasted image 20250113184620.png]]
클러스터링 인덱스는 루트 노드와 리프 노드로 구성되어 있으며 **리프 노드가 곧 데이터**이다.

클러스터링 인덱스는 위에서 설명한 것처럼 데이터가 테이블에 삽입되는 순서에 상관없이 기본 키값을 기준으로 정렬되어 삽입된다.
따라서, 위처럼 테이블에서 기본 키값을 기준으로 바로 검색하여 데이터를 바로 찾을 수 있어 **빠르게 데이터를 얻을 수 있지만 CUD에 대한 작업은 느리다**.

또한, 추후에 언급하겠지만 인덱스가 기본 키를 포함하고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많다. 
하지만, **인덱스가 기본 키를 포함하고 있기 때문에 키 값이 클 경우 인덱스의 크기가 전체적으로 커질 수 있다**.
기본 키 값으로 설정하기에 테이블 당 한 개씩만 존재한다.

​기본 키값이 존재하지 않는다면, 어떻게 기본 키를 대체하여 클러스터링 키를 만들까?
- 프라이머리 키가 있다면 기본적으로 프라이머리 키를 클러스터 키로 선택한다.
- NOT NULL 옵션의 유니크 인덱스(UNIQUE INDEX) 중에서 첫 번째 인덱스를 클러스터 키로 선택한다.
- 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후 클러스터 키를 선택한다.

넌클러스터링 인덱스는 클러스터링 인덱스와 비슷하지만 살짝 다르다.

넌클러스터링 인덱스는 루트 노드와 브랜치 노드와 리프 노드로 구성되어 있으며 리프 노드에 기본 키값이 저장되어 있다.
넌클러스터링 인덱스는 기본 키값을 토대로 재탐색하여 데이터를 받아올 수 있다.

넌클러스터링 인덱스는 **물리적으로 데이터를 배열하지 않은 상태로 데이터 페이지가 구성**된다.
따라서, 기본 키값을 찾고 재탐색해야하기 때문에 클러스터링 인덱스에 비해 **검색 속도는 느리지만, 데이터의 CUD 측면에서는 더 빠르다**.
**테이블 당 여러 개 생성이 가능**하다.
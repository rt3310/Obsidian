## 인덱스 튜닝의 두 가지 핵심 요소

### 인덱스 스캔 효율화 튜닝
학생 명부에서 시력이 1.0~1.5인 홍길동 학생을 찾는 경우를 예로 들었을 때, 학생명부를 이름과 시력순으로 정렬해 두었다면 소량만 스캔하면 된다.
반면, 학생명부를 시력과 이름순으로 정렬해두었다면, 똑같이 두 명을 찾는데도 많은 양을 스캔해야 한다.

### 랜덤 엑세스 최소화 튜닝
이름과 시력순으로 정렬한 학생명부가 있으면 가장 좋지만, 만약 이름만으로 정렬한 학생명부와 시력만으로 정렬한 학생명부가 따로 하나씩 있다면 어느 쪽을 사용해야 더 효과적일까?

당연히 이름순으로 정렬한 학생명부다. 교실을 찾아가는 횟수를 줄일 수 있기 때문이다.

인덱스 스캔 효율화 튜닝과 랜덤 엑세스 최소화 튜닝 둘 다 중요하지만, 더 중요한 하나를 고른다면 랜덤 엑세스 최소화 튜닝이다. 성능에 미치는 영향이 더 크기 때문이다.

> [!important] 중요
> SQL 튜닝은 랜덤 I/O와의 전쟁이다.

## SQL 튜닝은 랜덤 I/O와의 전쟁

DB 성능이 느린 이유는 **디스크 I/O** 때문이다. 읽어야 할 데이터량이 많고, 그 과정에 디스크 I/O가 많이 발생할 때 느리다.
인덱스를 많이 사용하는 OLTP 시스템이라면 디스크 I/O 중에서도 **랜덤 I/O**가 특히 중요하다.
조인 메소드 중 가장 일반적으로 사용하는 NL 조인이 대량 데이터 조인할 때 느린 이유도 랜덤 I/O 때문이다. 그래서 소트머지 조인과 해시 조인이 개발됐으므로 이들 조인 메소드도 결국 느린 랜덤 I/O를 극복하기 위해서 개발된 기능이다.

## 인덱스 구조

인덱스는 대용량 테이블에서 필요한 데이터만 빠르게 효율적으로 액세스하기 위해 사용하는 오브젝트다.

DB에서 인덱스 없이 데이터를 검색하려면, 테이블을 처음부터 끝까지 모두 읽어야 한다. 반면, 인덱스를 이용하면 일부만 읽고 멈출 수 있다. 즉, **범위 스캔(Range Scan)** 이 가능하다. 범위 스캔이 가능한 이유는 **인덱스가 정렬돼 있기 때문**이다.

DBMS는 일반적으로 B\*Tree 인덱스를 사용한다.

루트와 브랜치 블록에 있는 각 레코드는 하위 블록에 대한 주소값을 갖는다. 키값은 하위 블록에 저장된 키값의 범위를 나타낸다.
또 루트와 브랜치 블록에는 키값을 갖지 않는 특별한 레코드가 하나 있다. 가장 왼쪽 첫 번째 레코드다. 이를 **LMC**라고 하며 Leftmost Child의 줄임말이다. LMC는 **자식 노드 중 가장 왼쪽 끝에 위치한 블록**을 가리킨다. LMC가 가리키는 주소로 찾아간 블록에는 **키값을 가진 첫 번째 레코드보다 작거나 같은 레코드가 저장돼 있다**.

리프 블록에 저장된 각 레코드는 키값 순으로 정렬돼 있을 뿐만 아니라 **테이블 레코드를 가리키는 주소값**, 즉 **ROWID**를 갖는다.
**인덱스 키값이 같으면 ROWID 순으로 정렬**된다.
인덱스를 스캔하는 이유는, 검색 조건을 만족하는 **소량의 데이터를 빨리 찾고 거기서 ROWID를 얻기 위해서**다. ROWID는 아래와 같이 데이터 블록 주소(DBA, Data Block Address)와 로우 번호로 구성되므로 이 값을 알면 테이블 레코드를 찾아갈 수 있다.
- ROWID = 데이터 블록 주소 + 로우 번호
- 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
- 블록 번호 : 데이터파일 내에서 부여한 상대적 순번
- 로우 번호 : 블록 내 순번

인덱스 탐색 과정은 수직적 탐색과 수평적 탐색으로 나눌 수 있다.
- 수직적 탐색: 인덱스 스캔 시작지점을 찾는 과정
- 수평적 탐색: 데이터를 찾는 과정

## 인덱스 수직적 탐색

정렬된 인덱스 레코드 중 조건을 만족하는 첫 번째 레코드를 찾는 과정이다. 즉, **인덱스 스캔 시작지점을 찾는 과정**이다.

인덱스 수직적 탐색은 루트 블록에서부터 시작한다.
루트를 포함해 브랜치 블록에 저장된 각 인덱스 레코드는 하위 블록에 대한 주소값을 갖는다. 루티에서 시작해 리프 블록까지 수직적 탐색이 가능한 이유다.

수직적 탐색 과정에 찾고자 하는 값보다 크거나 같은 값을 만나면, 바로 직전 레코드가 가리키는 하위 블록으로 이동한다.

> [!warning] 주의
> 수직적 탐색은 조건을 만족하는 레코드를 찾는 과정이 아니라 **조건을 만족하는 첫 번째 레코드**를 찾는 과정임을 반드시 기억하자.

## 인덱스 수평적 탐색

수직적 탐색을 통해 스캔 시작점을 찾았으면 **찾고자 하는 데이터가 더 안 나타날 때까지 인덱스 리프 블록을 수평적으로 스캔**한다. 인덱스에서 본격적으로 데이터를 찾는 과정이다.

인덱스 리프 블록끼리는 서로 앞뒤 블록에 대한 주소값을 갖는다. 즉, **양방향 연결 리스트** 구조다. 좌에서 우로, 또는 우에서 좌로 수평적 탐색이 가능한 이유다.

인덱스를 수평적으로 탐색하는 이유는
1. 첫째, **조건절을 만족하는 데이터를 모두 찾기 위해**서고
2. 둘째, **ROWID를 얻기 위해**서다.
필요한 컬럼을 인덱스가 모두 값고 있어 인덱스만 스캔하고 끝나는 경우도 있지만, **일반적으로 인덱스를 스캔하고서 테이블도 액세스한다. 이때 ROWID가 필요하다**.

## 결합 인덱스 구조와 탐색

인덱스에서 남자 '이재희' 고객을 찾는다고 가정했을 때, 수직적 탐색을 거쳐서 찾은 인덱스 스캔 시작점은 성별 = '남'인 첫 번째 레코드가 아니라, 성별 = '남'이면서 고객명 = '이재희'인 레코드라는 사실을 반드시 기억하자.

인덱스를 [고객명+성별]로 구성하든, [성별+고객명]으로 구성하든 읽는 인덱스 블록 개수는 같다. 즉, 인덱스 선두 컬럼을 모두 "=" 조건으로 검색할 때는 어느 컬럼을 인덱스 앞쪽에 두든 블록 I/O개수가 같으므로 성능도 똑같다.

> [!info] 정보
> delete 작업 때문에 인덱스가 불균형(Unbalanced) 상태에 놓일 수 있다고 설명한 자료들이 여럿 있는데, **B\*Tree 인덱스에서 이런 현상은 절대 발생하지 않는다**. B\*Tree 인덱스의 'B'가 **'Balanced'** 의 약자임을 기억하자.
> Balanced는 어떤 값으로 탐색하더라도 인덱스 루트에서 리프 블록에 도달하기까지 읽는 블록 수가 같음을 의미한다. 즉, **루트로부터 모든 리프 블록까지의 높이는 항상 같다**.

## 인덱스 사용

### 인덱스 컬럼을 가공하면 정상사용할 수 없다
인덱스는 인덱스 컬럼을 가공하지 않아야 정상적으로 사용할 수 있다. 여기서 '인덱스를 정상적으로 사용한다'는 표현은 리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미한다. 즉 리프 블록 일부만 스캔하는 **Index Range Scan**을 의미한다.

인덱스 컬럼을 가공해도 인덱스를 사용할 수는 있지만, 스캔 시작점을 찾을 수 없고 멈출 수도 없어 리프 블록 전체를 스캔해야만 한다. 즉, 일부가 아닌 전체를 스캔하는 **Index Full Scan** 방식으로 작동한다.

#### 인덱스를 Range Scan 할 수 없는 이유
인덱스 컬럼을 가공했을 때 인덱스를 정상적으로 사용할 수 없는 이유는 인덱스 스캔 시작점을 찾을 수 없기 때문이다.
Index Range Scan에서 'Range'는 범위를 의미한다. 즉, Index Range Scan은 인덱스에서 일정 범위를 스캔한다는 뜻이다. 일정 범위를 스캔하려면 '시작점'과 '끝지점'이 있어야 한다.

다음은 Range Scan 할 수 없는 예시이다. 즉 시작점을 찾을 수 없는 경우이다.
```sql
where substr(생년월일, 5, 2) = '05'
```

```sql
where nvl(주문수량, 0) < 100
```

```sql
where 업체명 like '%대한%'
```

```sql
where (전화번호 = :tel_no OR 고객명 = :cust_nm)
```
OR 조건으로 검색할 때, 수직적 탐색을 통해 전화번호가 '01012345678'이거나 고객명이 '홍길동'인 어느 한 시작지점을 바로 찾을 수 없다.

> [!info] OR Expansion
> 
하지만, 아래와 같이 쿼리하면 고객명, 전화번호 인덱스 각각에 대해 Index Range Scan이 가능하다.
> ```sql
> select *
> from 고객
> where 고객명 = :cust_nm
> union all
> select *
> from 고객
> where 전화번호 = :tel_no
> and (고객명 <> :cust_nm or 고객명 is null)
> ```
> OR 조건식을 SQL 옵티마이저가 위와 같은 형태로 변환할 수 있는데, 이를 **'OR Expansion'** 이라고 한다. 아래는 use_concat 힌트를 이용해 OR Expansion을 유도했을 때의 실행 계획이다. Index Range Scan이 작동했음을 확인하자.
> 
> ```sql
> select /*+ use_concat */ * from 고객
> where (전화번호 = :tel_no OR 고객명 = :cust_nm)
> ```
> 
> Execution Plan
> ```
> SELECT STATEMENT Optimizer=ALL_ROWS (Cost=4 Card=2 Bytes=78)
> 	CONCATENATION
> 		TABLE ACCESS (BY INDEX ROWID) OF '고객' (TABLE) (Cost=2 Card=1 ...)
> 			INDEX (RANGE SCAN) OF ' 고객_고객명_IDX' (INDEX) (Cost=1 Card=1)
> 		TABLE ACCESS (BY INDEX ROWID) OF ' 고객' (TABLE) (Cost=2 Card=1 ...)
> 			INDEX (RANGE SCAN) OF '고객_전화번호_IDX' (INDEX) (Cost=1 Card=1)
> ```
> 위와 같은 쿼리 변환이 일어나지 않는다면 OR 조건식에는 Index Range Scan이 불가능하다.

```sql
where 전화번호 in (:tel_no1, :tel_no2)
```
IN 조건도 수직적 탐색을 통해 시작점을 찾는 것이 불가능하다. IN 조건은 OR 조건을 표현하는 다른 방식일 뿐이다.

하지만, 다행이 SQL을 아래와 같이 UNION ALL 방식으로 작성하면, 각 브랜치 별로 인덱스 스캔 시작점을 찾을 수 있다. Range Scan이 가능하다.
```sql
select *
from 고객
where 전화번호 = :tel_no1
union all
select *
from 고객
where 전화번호 = :tel_no2
```
그래서 IN 조건절에 대해서는 SQL 옵티마이저가 IN-List Iterator 방식을 사용한다. IN-List 개수만큼 Index Range Scan을 반복하는 것이다. 이를 통해 SQL을 UNION ALL 방식으로 변환한 것과 같은 효과를 얻을 수 있다.
```
SELECT STATEMENT Optimizer=ALL_ROWS (Cost=2 Card=1 Bytes=39)
	INLIST ITERATOR
		TABLE ACCESS (BY INDEX ROWID)
			INDEX (RANGE SCAN) OF '고객_전화번호_IDX' (INDEX) (Cost=1 Card=1)
```

### 인덱스 선두 컬럼은 조건절에
인덱스를 Range Scan 하기 위한 가정 첫 번째 조건은 인덱스 선두 컬럼이 조건절에 있어야 한다는 사실이다. 가공하지 않은 상태로 말이다.

그럼 다음 쿼리는 인덱스를 Range Scan 할 수 있을까?
```sql
select * from TXA1234
where 기준연도 = :stdr_year
and substr(과세구분코드, 1, 4) = :txtn_dcd
and 보고회차 = :rpt_tmrd
and 실명확인번호 = :rnm_cnfm_no
```
이 쿼리는 인덱스 Range Scan이 가능하다. 인덱스를 Range Scan 하려면 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있어야 한다. 즉 반대로 말해, 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면 인덱스 Range Scan은 무조건 가능하다.

하지만, 문제는 인덱스를 Range Scan 한다고 해서 항상 성능이 좋은 건 아니라는 사실이다.

### 인덱스를 잘 타니까 튜닝 끝?
SQL을 개발하면서 실행계획을 확인하지 않는 개발자가 대다수다. 확인하더라도 인덱스를 타는지, 안 타는지 확인하는 수준에 그친다. 인덱스를 잘 타면 성능도 문제없다고 생각한다.
아래 SQL은 인덱스를 잘 타고 있다. 우리가 흔히 말하는 '인덱스를 탄다'는 표현은 '인덱스를 Range Scan한다'와 같은 의미인 셈이다.
```
SELECT STATEMENT Optimizer=ALL_ROWS
	TABLE ACCESS (BY INDEX ROWID) OF '주문상품' (TABLE)
		INDEX (RANGE SCAN) OF '주문상품_N1' (INDEX)
```
그렇다면 위 실행계획은 인덱스를 잘 타니까 성능에 문제가 없을까?

주문상품_N1 인덱스는 [주문일자+상품번호] 순으로 구성됐고, 이 테이블에 쌓이는 데이터량은 하루 평균 100만 건이라고 가정하자.

아래 조건절은 인덱스가 선두 컬럼인 주문일자가 조건절에 있고, 가공하지 않은 상태이므로 인덱스를 Range Scan하는 데 문제가 없다. 스캔 시작점을 찾아 스캔하다가 중간에 멈출 수 있다. 그런 의미에서는 인덱스를 잘 탄다고 할 수 있다. 그런데 인덱스를 정말 잘 타는지는 **인덱스 리프 블록에서 스캔하는 양을 따져봐야 알 수 있다**.
```sql
SELECT *
FROM 주문상품
WHERE 주문일자 = :ord_dt
AND 상품번호 LIKE '%PING%';

SELECT *
FROM 주문상품
WHERE 주문일자 = :ord_dt
AND SUBSTR(상품번호, 1, 4) = 'PING';
```
위 SQL 에서 상품번호는 스캔 범위를 줄이는 데 전혀 역할을 하지 못한다.
첫 번째 SQL은 중간 값 검색이기 때문이고, 두 번째 SQL은 컬럼을 가공했기 때문이다. 따라서  위 조건절을 처리할 때 인덱스에서 스캔하는 데이터량은 주문일자 조건을 만족하는 100만 건이다. 이를 두고 인덱스를 잘 탄다고 말할 수 있을까?

## 인덱스를 이용한 소트 연산 생략

테이블과 달리 인덱스는 정렬돼있다. 우리가 인덱스를 사용하는 이유다. 인덱스가 정렬돼 있기 때문에 Range Scan이 가능하고, 소트 연산 생략 효과도 부수적으로 얻게 된다.

PK를 [장비번호+변경일자+변경순번] 순으로 구성한 상태변경이력 테이블이 있다고 하자. PK 인덱스에서 장비번호, 변경일자가 같은 레코드는 변경순번 순으로 정렬돼있다.

아래와 같이 장비번호와 변경일자를 모두 '=' 조건으로 검색할 때 PK 인덱스를 사용하면 결과집합은 변경순번 순으로 출력된다.
```sql
SELECT *
FROM 상태변경이력
WHERE 장비번호 = 'C'
AND 변경일자 = '20180316'
```

```
Execution Plan
----------------------------------------------------------------------------
SELECT STATEMENT Optimizer=ALL_ROWS (Cost=85 Card=81 Bytes=5K)
	TABLE ACCESS (BY INDEX ROWID) OF '상태변경이력' (TABLE) (Cost=85 ...)
		INDEX (RANGE SCAN) OF '상태변경이력_PK' (INDEX (UNIQUE)) (Cost=3 ...)
```
옵티마이저는 이런 속성을 활용해 아래와 같이 SQL에 ORDER BY가 있어도 정렬 연산을 따로 수행하지 않는다. PK 인덱스를 스캔하면서 출력한 결과집합은 어차피 변경순번 순으로 정렬되기 때문이다.

```sql
SELECT *
FROM 상태변경이력
WHERE 장비번호 = 'C'
AND 변경일자 = '20180316'
ORDER BY 변경순번
```
```
Execution Plan
----------------------------------------------------------------------------
SELECT STATEMENT Optimizer=ALL_ROWS (Cost=85 Card=81 Bytes=5K)
	TABLE ACCESS (BY INDEX ROWID) OF '상태변경이력' (TABLE) (Cost=85 ...)
		INDEX (RANGE SCAN) OF '상태변경이력_PK' (INDEX (UNIQUE)) (Cost=3 ...)
```
만약 정렬 연산을 생략할 수 있게 인덱스가 구성돼 있지 않다면, 아래와 같이 SORT ORDER BY 연산 단계가 추가된다.
```
Execution Plan
----------------------------------------------------------------------------
SELECT STATEMENT Optimizer=ALL_ROWS (Cost=85 Card=81 Bytes=5K)
	SORT (ORDER BY) (Cost=86 Card=81 Bytes=5K)
		TABLE ACCESS (BY INDEX ROWID) OF '상태변경이력' (TABLE) (Cost=85 ...)
			INDEX (RANGE SCAN) OF '상태변경이력_PK' (INDEX (UNIQUE)) (Cost=3 ...)
```
인덱스 리프 블록은 양방향 연결 리스트 구조기 때문에 내림차순(Desc) 정렬에도 인덱스를 활용할 수 있다.

오름차순(Asc) 정렬일 때는 조건을 만족하는 가장 작은 값을 찾아 좌측으로 수직적 탐색한 후 우측으로 수평적 탐색을 한다.
내림차순(Desc) 정렬일 때는 조건을 만족하는 가장 큰 값을 찾아 우측으로 수직적 탐색한 후 좌측으로 수평적 탐색을 한다.

## ORDER BY 절에서 컬럼 가공

"인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다." 에서 말하는 "인덱스 컬럼"은 대개 조건절에 사용한 컬럼을 말한다.
그런데 조건절이 아닌 ORDER BY 또는 SELECT-LIST에서 컬럼을 가공함으로 인해 인덱스를 정상적으로 사용할 수 없는 경우도 종종 있다.

위처럼 PK 인덱스를 [장비번호+변경일자+변경순번] 순으로 구성했다면 아래 SQL도 정렬 연산을 생략할 수 있다. 수직적 탐색을 통해 장비번호가 'C'인 첫 번째 레코드를 찾아 인덱스 리프 블록을 스캔하면, 자동으로 [변경일자 + 변경순번]순으로 정렬되기 때문이다.
```sql
SELECT *
FROM 상태변경이력
WHERE 장비번호 = 'C'
ORDER BY 변경일자, 변경순번
```
그런데 만약 개발자가 SQL을 아래와 같이 작성했다면, 정렬 연산을 생략할 수 없다.
인덱스에는 가공하지 않은 상태로 값을 저장했는데, 가공한 값 기준으로 정렬해 달라고 요청했기 때문이다.
```sql
SELECT *
FROM 상태변경이력
WHERE 장비번호 = 'C'
ORDER BY 변경일자 || 변경순번 /* concat */
```


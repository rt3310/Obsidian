## WAL

WAL(Write-Ahead Logging)은 데이터를 변경하기 전에, 변경 내용을 먼저 로그에 기록하는 방식을 말한다.
즉, DB가 디스크의 데이터를 바꾸기 전에 변경 내역을 로그 파일에 선기록(write-ahead) 하는 것이다.

WAL은 데이터베이스의 쓰기를 빠르게 완료하며, 데이터의 무결성과 일관성 유지에 매우 큰 역할을 한다.

### Data Write
DB에 데이터를 변경하면, 저장되어 있는 해당 디스크의 값을 바꿔주어야 한다. 삽입과 삭제도 마찬가지다.

DB 성능에 가장 큰 영향을 주는 것이 물리적인 Disk I/O인데, 과연 조그만 데이터 하나가 바뀔 때마다 Disk I/O가 발생하면 얼마나 빠를 수 있겠는가.

DB 엔진에서 WAL을 활용하여 디스크에 데이터를 쓰는 과정은 전반적으로 아래와 같다.
1. 물리적 Disk에서 변경될 데이터 블럭을 찾아서 해당 블럭을 읽어와 메모리 버퍼에 캐싱한다.
2. 캐싱 된 데이터 블럭에 데이터를 변경한다.
3. 캐싱 된 데이터 블럭의 데이터를 더티 블럭이라 표시하고, 해당 변경 사항을 WAL에 트랜잭션 순으로 저장한다.
4. 특정 시점에 체크포인트가 발생하면, WAL에 쓴 변경사항을 디스크에 쓴다.

대략적으로 이 과정에서 데이터 쓰기가 진행되며 WAL에 기록이 완료된 시점부터는 데이터 유실이 방지되며, 이 상태부터 Commit 상태이다.

데이터를 쓰는데 있어서 메모리 버퍼에서 수정을 완료하며, 그 내용을 WAL에 순차적으로 기록하는데, WAL 또한 물리적인 파일이기에 Disk I/O가 발생한다.
똑같은 Disk I/O가 발생하지만 WAL에 기록하는 것이 데이터 블럭에 쓰는 것보다 빠른 이유는 아래와 같다.
- 데이터 블럭에는 하나하나 찾아가며 기록해야 하지만, WAL에는 순차적으로 기록한다.
	- 데이터 블럭을 쓰는데 있어서 랜덤 I/O냐, 순차 I/O냐의 차이다.
- WAL에 기록되는 내용은 특정 시점에 발생하는 체크포인트에 의해 일괄적으로 데이터 블럭에 쓰인다.
	- 발생된 내용을 모아 일괄적으로 반영하기에 랜덤 I/O를 최소화할 수 있다.


## WAL의 목적

DB는 트랜잭션의 ACID 특성을 보장해야 한다.

| 속성                   | 의미                                               | WAL이 담당하는 부분     |
| ---------------------- | -------------------------------------------------- | ----------------------- |
| A(Atomicity, 원자성)   | 트랜잭션은 전부 실행되거나 전혀 실행되지 않아야 함 | 로그를 이용한 Undo      |
| C(Consistency, 일관성) | 일관된 상태로 유지                                 | Redo/Undo로 복원        |
| I(Isolation, 독립성)   | 동시에 실행돼도 서로 간섭하지 않음                 | 별도 매커니즘 (lock 등) |
| D(Durability, 지속성)  | 커밋된 데이터는 시스템이 꺼져도 유지               | WAL 로그의 영속화       |

WAL은 "Atomicity(원자성) + Durability(지속성)"의 핵심 장치이다.
데이터 페이지를 직접 디스크에 동기화 하기엔 비용이 크기 때문에, 먼저 작은 로그 파일에 기록해서 커밋을 빠르게 끝내고, 나중에 실제 데이터를 반영하는 방식이다.

## 기본 원리

"데이터 페이지를 디스크에 쓰기 전에, 해당 변경 내용이 담긴 로그 레코드가 먼저 디스크에 저장돼야 한다."

이 규칙을 지키면,
- 로그만 남아도 REDO(재실행)를 통해 데이터 복원이 가능하다.
- 아직 반영되지 않은 트랜잭션은 로그를 보고 UNDO(되돌리기) 할 수 있다.

## 동작 과정

### 1. 트랜잭션 실행 중
1. 트랜잭션이 테이블 데이터를 수정 -> 변경 내용은 메모리 버퍼(버퍼 캐시)에 반영됨
2. 동시에, 이 변경 내역이 WAL 버퍼(메모리)에 로그 레코드로 작성됨
	- 로그에는 "어느 페이지의 어떤 값이 어떻게 바뀌었는가"가 들어있다.

### 2. 커밋 시점
1. 트랜잭션이 커밋될 때, WAL 버퍼의 로그를 디스크(WAL 파일)에 동기화(fsync)
2. 동기화가 끝나면 커밋 성공으로 간주
	- 이때는 데이터 페이지가 아직 디스크에 써지지 않아도 된다.

### 3. 체크포인트 시점
1. 일정 주기마다 백그라운드에서 Dirty Page(변경된 데이터 페이지)를 실제 데이터 파일에 기록
	- 이 시점을 "체크포인트(checkpoint)"라고 한다.
2. 체크포인트 이후에는, 그 이전의 로그는 복구 시 다시 재실행할 필요가 없어짐

## 장애 발생 시 - 복구 절차

1. 분석 단계
	- 마지막 체크포인트 이후의 로그를 읽으며 어떤 트랜잭션이 완료/미완료인지 파악
2. REDO 단계
	- 커밋된 트랜잭션의 로그를 재적용 → 디스크에 반영되지 않았던 변경 복원
3. UNDO 단계
	- 미완료(롤백되지 않은) 트랜잭션의 변경 내용을 되돌림

## 장단점

### 장점
- 내구성 보장: 로그를 먼저 디스크에 쓰므로 커밋 데이터가 손실되지 않는다.
- 빠른 커밋: 실제 데이터 페이지 대신 작은 로그만 기록하므로 커밋 속도 향상
- 복구 용이: 로그만 있으면 언제든 복원 가능
- 복제/백업 용이: WAL 로그를 전송해 복제본을 쉽게 유지 가능(streaming replication)
### 단점
- 로그 공간 증가: 모든 변경 내역이 로그로 쌓임
- 체크포인트 비용: 로그가 너무 많아지면 복구 시간이 길어짐
- fsync 오버헤드: 커밋마다 로그 flush가 많을 경우 지연 발생
- 디스크 병목: 로그 파일이 순차 I/O에 의존하므로 느린 디스크에서는 병목이 생김
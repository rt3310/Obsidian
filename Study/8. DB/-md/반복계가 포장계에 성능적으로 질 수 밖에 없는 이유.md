- **SQL 실행의 오버헤드**
	- SQL을 실행할 때는 데이터를 검색하거나 연산하는 실제의 SQL 처리 이외에도 다양한 처리가 이루어진다.
		- 전처리
			- SQL 구문을 네트워크로 전송
			- 데이터베이스 연결
			- SQL 구문 parse
			- SQL 구문의 실행 계획 생성 또는 평가
		- 후처리
			- 결과 집합을 네트워크로 전송
	- 오버헤드 중에서 가장 영향이 큰 것은 SQL 구문 parse와 SQL 구문의 실행 계획 생성 또는 평가이다.
	- parse는 DBMS마다 하는 방법도 미묘하게 다르고 종류도 굉장히 많다. 특히 종류에 따라 느린 부분은 0.1 ~ 1초 정도 걸린다. 이는 다른 오버헤드가 밀리 초로 영향을 미치는 것에 비해 굉장히 큰 값이다.
	- parse는 데이터베이스가 SQL을 받을 때 마다 실행되므로 작은 SQL을 여러 번 반복하는 반복계에서는 오버헤드가 높아질 수 밖에 없다.
- **병렬 분산이 힘들다**
	- 반복계는 반복 1회마다 처리를 굉장히 단순화한다. 따라서 리소스를 분산해서 병렬 처리하는 최적화가 안된다.
	- 데이터베이스의 서버 저장소는 대부분 RAID 디스크로 구성되어 I/O 부하를 분산할 수 있게 되어있다. 하지만 반복계에서 실행하는 SQL 구문은 대부분 단순해서 1회의 SQL 구문이 접근하는 데이터양이 적다. 따라서 I/O를 병렬화하기 힘들다는 단점이 있다.
- **데이터베이스의 진화로 인한 혜택을 받을 수 없다**
	- 데이터베이스가 처리해야 하는 데이터양은 최근 급격히 증가하고 있으며, 그에 따라 DBMS 벤더(vendor)는 어떻게 해야 SQL을 빠르게 할 수 있을지 계속 연구하고 있다.
	- 따라서 DBMS의 버전이 오를수록 옵티마이저는 보다 효율적으로 실행 계획을 세우며, 데이터에 고속으로 접근할 수 있는 아키텍처를 구현한다. 이런 문제 의식은 소프트웨어 벤더뿐만 아니라 하드웨어 벤더도 공유하고 있다.
	- 최근 특히 주목을 모으고 있는 것이 기존의 디스크를 초월하는 I/O 성능을 가진 SSD 등의 매체이다. SSD가 실용화되면 저장소 넥(storage neck)에 시달리던 데이터베이스 세계에 혁명이 일어날 가능성이 있다.
	- 하지만 이러한 모든 노력의 중심은 기본적으로 '대규모 데이터를 다루는 복잡한 SQL 구문'을 빠르게 하려는 데 있다. 단순한 SQL 구문과 같은 '가벼운'처리를 빠르게 만드는 것은 사실 안중에도 없다.
	- 따라서 반복계는 미들웨어 또는 하드웨어의 진화에 따른 혜택을 거의 받을 수 없다. 실제로 반복계의 처리가 느려서 문제가 되는 경우 그냥 대충 스케일업을 하는 경우도 있다. 하지만 물리 리소스가 바틀넥(bottle neck)이 걸리는 경우가 아니라면 스케일업을 해도 속도가 빨라지지 않는 경우도 많다.
## 인덱스 자료구조

### Hash Table
해시 테이블은 Key - Value로 이루어진 데이터를 저장하는데 특화된 자료 구조이다.
예를 들어, user_name에 대한 인덱스를 만든다고 했을 때 user_name(key)과 주소값(value)로 이루어진 해시 테이블을 만든다면 합리적일 것이다.
하지만, 해시 테이블은 안타깝게도 인덱스 자료구조로 쓰이는 경우가 적다.

1. 부적절한 해시 함수로 인해 중복된 해시 값이 발생해 해시 충돌이 일어날 경우에는 시간 복잡도가 O(N)까지 상승할 수 있다. -> 중복된 이름이 많은 경우 해시 충돌이 지속적으로 발생할 것이다.
2. 등호 연산에만 효율적이고 부등호 연산에는 부적합하다. user_name 처럼 등호 연산만 사용할 수도 있지만 부등호 연산이 필요한 컬럼에는 부적합하다.

### B-Tree
![[Pasted image 20250310130707.png]]
B-Tree는 **자식 노드가 2개 이상인 트리**이다. 각 key의 왼쪽 자식은 항상 key 보다 작은 값을, 오른쪽 자식은 큰 값을 가진다.
B-Tree를 인덱스로 사용한다면 user_name(key)로 하고 데이터의 위치(value)로 저장한다. 그리고, B-Tree는 항상 key를 기준으로 오름차순 정렬이다. 때문에, 부등호 연산에 대해 해시 테이블보다 효율적인 데이터 탐색이 가능하다.

하지만, 테이블에 데이터가 갱신(Insert, Update, Delete)가 많이 발생하면 트리의 균형이 깨져버려 성능이 악화된다. 추가로, 순차 탐색을 해야 할 경우 **중위 순회**를 하기 때문에 검색 효율이 좋지 않다.

이러한 이유 때문에 MySQL 엔진인 InnoDB는 B-Tree를 확장/개선한 B+Tree를 인덱스의 자료 구조로 사용한다.

### B+Tree
![[Pasted image 20250310130717.png]]B+Tree는 말단의 리프 노드에만 데이터의 위치를 관리한다. 중간 브랜치 노드에 value가 없기 때문에 B-Tree보다 메모리를 덜 차지하고 노드의 메모리에 더 많은 key를 저장할 수 있다. 때문에 트리의 높이가 낮아져서 검색 속도가 증가한다.


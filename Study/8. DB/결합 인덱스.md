## 결합 인덱스

인덱스를 생성할 때 두 개 이상의 컬럼을 합쳐서 인덱스를 만드는 것을 말한다.

결합 인덱스는 AND 조건으로 검색되는 경우 성능에 아주 중요한 역할을 한다. 두 개 이상의 조건이 OR로 조회되는 경우는 결합 인덱스를 만들면 안된다.

## 결합 인덱스를 구성하는 컬럼의 순서

인덱스를 이용하여 성능 향상의 효과를 기대할 수 있으려면 먼저 해당 인덱스를 이용하여 처리 범위를 최대한 감소시켜야 한다. 성능을 향상시키기 위해서는 결합 인덱스를 구성하는 컬럼은 반드시 다음의 순서에 맞도록 생성해야 한다.
- **1순위**: 컬럼이 사용한 연산자에 의한 인덱스 컬럼 선정
- **2순위**: 랜덤 액세스를 고려한 인덱스 컬럼 선정
- **3순위**: 정렬 제거를 위한 인덱스 컬럼 선정
- **4순위**: 단일 컬럼의 분포도를 고려한 인덱스 컬럼 선정

이 4단계 우선 순위에 의해 우리는 결합 인덱스를 생성해야한다. 이 우선 순위를 지키지 않는다면 애당초 해당 인덱스를 이용한 성능 향상은 기대하기 조차 힘들어질 것이다.

물론, 결합 인덱스를 생성하는 우선 순위에서 WHERE 조건에 사용하는 컬럼으로 인덱스를 구성한다는 사실은 너무나 자명하기 때문에 제외한 것이다. 해당 SQL에서 사용되지 않는 컬럼을 특별한 이유 없이 인덱스에 추가하는 경우는 그다지 많지 않다.

이런 결합 인덱스 구성 규칙은 왜 생긴 걸까? 조금만 생각해보면 그 답은 쉽게 얻을 수 있다. **디스크 I/O을 가장 적게 발생시키기 위해서**다.
결국, 이런 우선 순위로 인덱스를 생성한다면 우리가 원하는 데이터를 추출할 때 최소의 디스크 I/O를 발생시키게 되어 성능을 보장 받을 수 있게 된다.

## 결합 인덱스를 구성하는 컬럼의 연산자에 주목하라

인덱스를 생성하는 경우 해당 컬럼의 분포도를 고려하는 경우가 많다. 이는 잘못된 지식에서 시작된 오류다.

다음 예제를 통해 인덱스를 생성한다고 가정해보자.
```sql
SELECT 카드번호, 사용액
FROM 거래내역
WHERE 카드번호 = '111'
AND 거래일자 BETWEEN '20080501' AND '20080510';
```

예제와 같이 SQL을 수행하는 경우에는 어떠한가? 카드번호 컬럼의 분포도는 매우 좋으며 거래일자 컬럼의 분포도는 매우 안 좋다고 가정하자.
분포도가 좋다는 뜻은 해당 테이블의 데이터에서 카드번호의 값이 '111'을 만족하는 데이터는 매우 적다는 의미다. 분포도가 나쁘다는 의미는 이와 반대의 의미를 가지게 된다.
따라서, 분포도가 좋은 컬럼인 카드번호 컬럼을 인덱스의 가장 앞에 두고 분포도가 나쁜 거래일자 컬럼을 뒤로해서 인덱스를 구성했다고 가정하자.
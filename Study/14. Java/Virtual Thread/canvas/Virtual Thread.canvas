{
	"nodes":[
		{"id":"13582db3306434c4","type":"text","text":"# 가상 스레드","x":-580,"y":-72,"width":187,"height":39},
		{"id":"38d1d9b9473c6055","type":"text","text":"기존의 전통적인 Java 스레드에 더하여 새롭게 추가되는 경량 스레드이다. `Project Loom`의 결과물로 추가된 기능으로 OS 스레드를 그대로 사용하지 않고 JVM 자체적으로 내부 스케줄링을 통해서 사용할 수 있는 경량의 스레드를 제공한다.\n하나의 Java 프로세스가 수십만 ~ 수백만개의 스레드를 동시에 실행할 수 있게끔 설계되었다.","x":-89,"y":-113,"width":640,"height":118},
		{"id":"64f9b9ea9c4f8bd2","type":"text","text":"Project Loom이란 경량의 스레드를 Java의 추가하기 위해서 가상 스레드를 비롯한 여러가지 기능들을 개발하는 프로젝트로 Loom이란 단어는 Thread의 사전적 정의가 **실**이라는데 착안하여 실을 엮어 **직물을 만든다는 뜻**이다.\nLoom 프로젝트의 결과로 탄생한 Virtual Thread도 처음에는 Fiber-섬유 라고하는 별도의 기능으로 개발되었으나, 최종적으로는 기존 스레드 문법과 호환될 수 있는 형태로 발전했다.","x":-83,"y":180,"width":626,"height":147},
		{"id":"1ae24fd0cf409247","type":"text","text":"Project Loom의 결과로 탄생한 가상 스레드는 다음과 같은 목적으로 가지고 있는데, 기존의 Reactive Programming과 비교해서 생각해보자.\n\n#### 해결하고자 하는 문제\n1. Java 개발자가 하드웨어의 성능을 잘 활용하는 높은 처리량(throughput)의 서버를 작성하는 것\n\t1. 가상 스레드는 Blocking이 발생하면 내부적으로 스케줄링을 활용하여 플랫폼 스레드가 그냥 대기하게 두지 않고 다른 가상 스레드가 작업할 수 있도록 한다.\n\t2. 따라서 Reactive Programming의 Non-blocking과 동일하게 플랫폼 스레드의 리소스를 낭비하지 않는다.\n2. 동시에 Java 플랫폼의 디자인과 조화를 이루는 코드를 생성할 수 있도록 하는 것\n\t1. 기존 Reactive Programming의 장점에도 불구하고 전통적인 Java 언어의 구조는 스레드를 기반으로 하였기 때문에 Webflux 등을 사용할 때 디버깅, 성능 테스트가 어려웠다.\n\t2. 하지만 가상 스레드는 기존 스레드 구조를 그대로 사용하기 때문에 디버깅, 프로파일링 등 기존의 도구도 그대로 사용할 수 있다.\n#### Reactive Programming 과의 비교\n- Reactive Programming이 달성하고자 하는, 리소스를 효율적으로 사용하여 높은 처리량을 감당하려는 목적은 동일하다.\n- 가상 스레드를 사용하면 Non-blocking에 대한 처리를 JVM 레벨에서 담당해준다.\n- 따라서 Spring Web MVC 스타일로 코드를 작성하더라고 내부에서 가상 스레드가 기존의 플랫폼 스레드를 직접 사용하는 방식보다 효율적으로 스케줄링하여 처리량을 높일 수 있다.\n- 결론적으로 가상 스레드는 기존 스레드 방식의 이점을 누리면서도 Reactive Programming의 장점을 취할 수 잇다.","x":-120,"y":-940,"width":700,"height":694},
		{"id":"c33f8838d83b4ba7","type":"file","file":"Study/14. Java/Virtual Thread/md/Virtual Thread가 나오게 된 배경.md","x":865,"y":-784,"width":800,"height":1157},
		{"id":"709f8c640ea77aca","type":"file","file":"Study/14. Java/Virtual Thread/md/플랫폼 스레드와 가상 스레드 구조 차이.md","x":-826,"y":160,"width":680,"height":1597},
		{"id":"7c8bbab242e2c818","type":"file","file":"Study/14. Java/Virtual Thread/md/Virtual Thread 사용 자원 차이.md","x":-806,"y":1920,"width":640,"height":205},
		{"id":"dbbe198c92c80787","type":"text","text":"### 준비\n- Java 21 설치\n```shell\nsdk install java 21.ea.18-open\n```\n\n```java\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\trun();\n\t}\n\n\tpublic static void run() throws Exception {\n\t\t// Virtual Thread 방법 1\n\t\tThread.startVirtualThread(() -> {\n\t\t\tSystem.out.println(\"Hello Virtual Thread\");\n\t\t});\n\t\t\n\t\t// Virtual Thread 방법 2\n\t\tRunnable runnable = () -> System.out.println(\"Hi Virtual Thread\");\n\t\tThread virtualThread1 = Thread.ofVirtual().start(runnable);\n\t\t\n\t\t// Virtual Thread 이름 지정\n\t\tThread.Builder builder = Thread.ofVirtual().name(\"JVM-Thread\");\n\t\tThread virtualThread2 = builder.start(runnable);\n\t\t\n\t\t// 스레드가 Virtual Thread 인지 확인하여 출력\n\t\tSystem.out.println(\"Thread is Virtual? \" + virtualThread2.isVirtual());\n\t\t\n\t\ttry (ExecutorService executorService = Executors.newVirtualThreadPerTaskExecutor()) {\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\texecutorService.submit(runnable);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n```shell\n$ java --version\nopenjdk 21-ea 2023-09-19\nOpenJDK Runtime Environment (build 21-ea+18-1480)\n<OpenJDK 64-Bit Server VM (build 21-ea+18-1480, mixed mode, sharing)\n$ javac Main.java\n$ ls\nMain.class Main.java\n$ java Main\nHello Virtual Thread\nHi Virtual Thread\nHi Virtual Thread\nThread is Virtual? true\nHi Virtual Thread\nHi Virtual Thread\nHi Virtual Thread\n```\n\n기존의 스레드(플랫폼 스레드)를 생성하던 문법과 큰 차이가 없이 가상 스레드를 만들 수 있다는 걸 알 수 있다. 이번에는 Executors를 사용하여 10만개의 가상 스레드를 만들고 2초간 대기하도록 한 뒤에 전체 실행시간을 측정해보자.\nBlocking이 발생하면 다른 가상 스레드가 실행되기 때문에 제대로 동작한다면 약 2초를 조금 넘기는 시간 안에 완료되어야 한다.\n\n```java\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\trun();\n\t }\n\t \n\t public static void run() throws Exception {\n\t\twhile (true) {\n\t\t\tlong start = System.currentTimeMillis();\n\t\t\t\n\t\t\ttry (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n\t\t\t// 10만개의 Virtual Thread 실행\n\t\t\t\tfor (int i = 0; i < 100_000; i++) {\n\t\t\t\t\texecutor.submit(() -> {\n\t\t\t\t\t\tThread.sleep(Duration.ofSeconds(2));\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong end = System.currentTimeMillis();\n\t\t\tSystem.out.println((end - start) + \"ms\");\n\t\t}\n\t}\n}\n```\n\n```shell\n$ java --version\nopenjdk 21-ea 2023-09-19\nOpenJDK Runtime Environment (build 21-ea+18-1480)\nOpenJDK 64-Bit Server VM (build 21-ea+18-1480, mixed mode, sharing)\n$ javac Main.java\n$ ls\nMain.class Main.java\n$ java Main\n2550ms\n2562ms\n2073ms\n2089ms\n2102ms\n2099ms\n```\n결과를 보면 알 수 있지만 2초에 가까운 시간이 출력된다. `Thread.sleep`에 의해서 Blocking 되었지만 내부 가상 스레드 스케줄러에 의해서 다음 가상 스레드가 실해오디기 때문에 전체 처리 시간은 2초에 가깝게 나온다.\n이것을 통해서 Blocking 코드가 있더라도 가상 스레드를 사용하면 처리량이 늘어날 수 있다는 것을 예상할 수 있다.","x":-2000,"y":-1133,"width":871,"height":2162},
		{"id":"f80abc9c65f007fd","type":"file","file":"Study/14. Java/Virtual Thread/resources/Virtual Thread 비교.png","x":-46,"y":-1492,"width":552,"height":359},
		{"id":"4cc07002324a9e5e","type":"text","text":"### 요약\n- 처리량을 높이기 위해서 기존에는 Reactive Programming과 같은 방식을 사용했지만 가상 스레드를 사용하면 Reactive Programming이 추구하는 Non-blocking을 통한 효율적인 자원 사용이 가능해진다.\n- 가상 스레드가 JVM 내부에서 알아서 스케줄링 해주기 때문에 가상 스레드 풀을 사용하지 않는다.\n- Reactive Programming 보다 가독성 좋은 코드를 유지할 수 있고, 기존 스레드와 동일하게 동작하므로 디버깅이 용이하다.\n\n### 생각해 볼 부분\n- 가상 스레드 기능이 추가되었다고 해서 기존의 스레드(플랫폼 스레드)를 사용하지 못하는 것은 아니다.\n\t- 기존의 스레드도 사용 가능하고, 추가된 가상 스레드도 사용 가능하다. 서로 대치되는 것이 아니라 공존하는 것이다.\n- 가상 스레드를 사용하더라도 응답 속도가 빨라지지는 않는다\n\t- 오히려 약간 느려질 수도 있다.\n\t- 다만 처리량이 늘어날 수 있다.\n- 일반적으로 애플리케이션을 개발할 때 스레드를 직접 다루거나 Executors를 사용하는 코드를 많이 작성하지는 않는다. 오히려 기존의 라이브러리들이 가상 스레드를 사용할 수 있도록 개선될 것 같다.\n- Reactive Programming과 같이 높은 처리량을 필요로 하는 부분들은 가상 스레드를 사용하는 방식으로 전환될 수도 있을 것 같다.","x":-980,"y":-872,"width":733,"height":558}
	],
	"edges":[
		{"id":"4ca44f4b7aa79f2c","fromNode":"13582db3306434c4","fromSide":"right","toNode":"38d1d9b9473c6055","toSide":"left","label":"가상 스레드?"},
		{"id":"7830d41e7ce55a05","fromNode":"38d1d9b9473c6055","fromSide":"bottom","toNode":"64f9b9ea9c4f8bd2","toSide":"top","label":"Loom Project?"},
		{"id":"fc291d0b1b110c32","fromNode":"38d1d9b9473c6055","fromSide":"right","toNode":"c33f8838d83b4ba7","toSide":"left","label":"나오게 된 배경"},
		{"id":"a9180f986e940cbf","fromNode":"38d1d9b9473c6055","fromSide":"top","toNode":"1ae24fd0cf409247","toSide":"bottom","label":"해결하고자 하는 문제"},
		{"id":"7670ae461b56d018","fromNode":"1ae24fd0cf409247","fromSide":"top","toNode":"f80abc9c65f007fd","toSide":"bottom"},
		{"id":"6c448afa4cee513e","fromNode":"13582db3306434c4","fromSide":"bottom","toNode":"709f8c640ea77aca","toSide":"top","label":"구조"},
		{"id":"3478e7eb20f62cb8","fromNode":"709f8c640ea77aca","fromSide":"bottom","toNode":"7c8bbab242e2c818","toSide":"top"},
		{"id":"af5cbb367d208c4d","fromNode":"13582db3306434c4","fromSide":"left","toNode":"dbbe198c92c80787","toSide":"right","label":"사용"},
		{"id":"b1b0bd12002bb193","fromNode":"13582db3306434c4","fromSide":"top","toNode":"4cc07002324a9e5e","toSide":"bottom","label":"정리 및 요약"}
	]
}
#### 자바의 스레드는 OS의 스레드를 기반으로 한다.
- 자바의 전통적인 스레드는 OS 스레드를 wrapping 한 것으로 이를 **플랫폼 스레드**라고 정의한다.
- 따라서 Java Application에서 스레드를 사용하는 코드는 실제적으로는 OS 스레드를 이용하는 방식으로 동작했다. 
- OS 커널에서 사용할 수 있는 스레드는 개수가 제한적이고 생성과 유지 비용이 비싸다.
- 이 때문에 기존에 애플리케이션들은 비싼 자원인 플랫폼 스레드를 효율적으로 사용하기 위해서 **스레드 풀(Thread Pool)**을 만들어서 사용해왔다.
#### 처리량(throughput)의 한계
- Spring Boot와 같은 애플리케이션의 기본적인 사용자 요청 처리 방식은 **Thread Per Request**이다. 이는 하나의 request(요청)을 처리하기 위해서 하나의 스레드를 사용한다.
- 애플리케이션에서 처리량을 늘리려면 스레드를 늘려야 하지만 스레드를 무한정 늘릴 수 없다. (OS 스레드를 무한정 늘릴 수 없기 때문
- 따라서 애플리케이션의 처리량(throughput)은 **스레드 풀**에서 감당할 수 있는 범위를 넘어서 늘어날 수 없다.
#### Blocking으로 인한 리소스 낭비
- **Thread Per Request** 모델에서는 요청을 처리하는 스레드에서 I/O 작업을 처리할 때 **Blocking**이 일어난다.
- 이 때문에 스레드는 I/O 작업이 마칠 때까지 다른 요청을 처리하지 못하고 기다려야 한다. (Blocking 동안 대기)
- 애플리케이션이 유입되는 요청이 많지 않거나 또는 스케일 아웃으로 충분히 커버할 수 있는 정도라면 문제가 없지만, 아주 많은 요청을 처리해야하는 상황이라면 **Blocking 방식으로 인해 발생하는 낭비를 줄여야 할 필요가 있다**.
- 이 때문에 Blocking이 아니라 **Non-Blocking** 방식의 **Reactive Programming**이 발전하였다.
#### Reactive Programming의 단점
- 처리량을 높이기 위한 방법으로 비동기 방식의 Reactive 프로그래밍이 발전해왔다.
- 한정된 자원인 플랫폼 스레드가 Blocking 되면서 대기하는 데 소요된 스레드 자원을 Non-Blocking 방식으로 변경하면서 다른 요청을 처리하는 데 사용할 수 있게 되었다.
- 대표적으로 Webflux가 이렇게 Non-Blocking으로 동작한다.
- 다만 이런 Reactive 코드는 작성하고 이해하는 비용을 높게 만들었다. (Mono, Flux)
- 또한 기존의 자바 프로그래밍의 패러다임은 스레드를 기반으로 하기 때문에 라이브러리들 모두 Reactive 방식에 맞게 새롭게 작성해야 하는 문제가 있다.
#### 자바 플랫폼의 디자인
- 자바 플랫폼은 전통적으로 **스레드를 중심**으로 구성되어 있었다.
- 스레드 호출 스택은 Thread Local을 사용하여 데이터와 컨텍스트를 연결하도록 설계되어 있다.
- 이 외에도 Exception, Debugger, Profile(JFR)이 모둔 스레드를 기반으로 하고 있다.
- Reactive 스타일로 코드를 작성하면 사용자의 요청이 스레드를 넘나들면서 처리되는데, 이 때문에 컨텍스트 확인이 어려워져 결국 디버깅이 힘들어졌다.
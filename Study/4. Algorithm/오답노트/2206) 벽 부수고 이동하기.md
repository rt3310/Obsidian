https://www.acmicpc.net/problem/2206

##### 가중치가 없는 최단 경로는  무조건 BFS이다.
- DFS는 왜 안되나?
	- 특정 칸에 처음 도달했을 때까지의 경로의 길이가 다른 경로를 통해 도달한 길이보다 짧다는 보장이 전혀 없기 때문이다.

##### 벽을 하나씩 다 부셔보는 걸로는 해결할 수 없다.
- $1 \leq N \leq 1000$, $1\leq M \leq 1000$ 이기 때문에, 벽이 있을 수 있는 경우는 $O(NM)$이다. 여기서 벽 하나당 NM개의 칸을 탐색하므로 총 시간복잡도는 $O((NM)^2)$이다.

##### 칸마다 방문 체크 하나씩만 하는 방법으로는 풀 수 없다.
- 어떤 칸에 도달했을 때 나는 "아직 벽을 부술 수 있는 상태"일 수도 있고, "더 이상 벽을 부술 수 없는 상태"일 수도 있다.

##### 큐에 그 상태를 넣은 것만으로 되는 것이 아니다.
- 현재 칸까지 벽을 안 부수고 최단으로 올 수 있었다고 가정해보자. 현재 지점에서 목표 지점까지 가는 데, 벽을 한 개 부수고 가는 것이 안 부수고 가는 것보다 최적이 나온다고 해보자. 그렇다면 지금 내가 벽을 더 부술 수 있는 상태라는 사실을 알고 있어야 한다.
- 벽을 안 부수고도 현재 칸까지 도달이 가능하지만, 벽을 부수고 오는 것이 더 짧다고 가정해보자. 현재 지점에서 목표 지점까지 가려면 무조건 벽을 한 개 부숴야만 된다고 해보자. 비록 현재 칸 까지는 벽을 부수고 오는 것이 최적이었지만, 이 상태로는 끝에 아예 도달을 못한다.

> 같은 칸에 방문하는 경우 벽을 안 부순 것이 더 유리하기 때문에 벽을 부쉈는지 여부를 방문 배열에 기록하여 부순 횟수가 더 적을 때만 방문하는 방법도 된다. 그러나 이는 문제의 특성 때문에 이 문제에서만 통하는 그리디이므로 다른 문제에도 함부로 사용해서는 안된다.
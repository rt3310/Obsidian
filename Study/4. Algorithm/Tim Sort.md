## 새로운 정렬의 필요성

다음은 잘 알려진 비교 정렬 알고리즘들을 비교하여 정리한 표이다.

![](https://d2.naver.com/content/images/2020/01/img.png)

흔히 Bubble sort, Insertion sort는 평균 시간 복잡도 $O(n2)$으로 느린 정렬 알고리즘, Merge sort, Heap sort, Quick sort는 평균 $O(n\log n)$으로 빠른 알고리즘으로 알려져 있다. 정렬의 성능을 파악하는 지표에 시간은 필수이므로 Merge sort, Heap sort, Quick sort를 사용하는 것이 좋을 것 같다. 이 세 개의 정렬 알고리즘 중 어떤 것을 표준 정렬 알고리즘으로 선정하는 것이 좋을까?

최선의 경우 $O(n)$, 최악의 경우 $O(n\log n)$에 추가 메모리도 들지 않는 Heap sort가 제일 성능이 좋은 알고리즘이 아닐까 하는 생각이 들 수도 있지만 평균 시간 복잡도가 $O(n\log n)$이라는 의미를 좀 더 자세히 살펴볼 필요가 있다.

시간 복잡도가 $O(n\log n)$이라는 말은 실제 동작 시간은 $C×n\log ⁡n+α$라는 의미이다. 상대적으로 무시할 수 있는 부분인 $α$ 부분을 제하면 $n\log n$에는 앞에 $C$라는 상수가 곱해져 있어 이 값에 따라 실제 동작 시간에 큰 차이가 생긴다. 이 $C$라는 값에 큰 영향을 끼치는 요소로 '알고리즘이 **참조 지역성**(Locality of reference) 원리를 얼마나 잘 만족하는가'가 있다.

참조 지역성 원리란, CPU가 미래에 원하는 데이터를 예측하여 속도가 빠른 장치인 캐시 메모리에 담아 놓는데 이때의 예측률을 높이기 위하여 사용하는 원리이다. 쉽게 말하자면, 최근에 참조한 메모리나 그 메모리와 인접한 메모리를 다시 참조할 확률이 높다는 이론을 기반으로 캐시 메모리에 담아놓는 것이다. 메모리를 연속으로 읽는 작업은 캐시 메모리에서 읽어오기에 빠른 반면, 무작위로 읽는 작업은 메인 메모리에서 읽어오기에 속도의 차이가 있다.

참조 지역성 원리의 개념과 함께 다시 한 번 세 정렬 알고리즘을 비교해보겠다.


![](https://d2.naver.com/content/images/2020/01/img.gif)

Heap sort

Heap sort의 경우 대표적으로 참조 지역성이 좋지 않은 정렬이다. 위의 이미지에서 확인할 수 있듯이 한 위치에 있는 요소를 해당 요소의 인덱스 두 배 또는 절반인 요소와 반복적으로 비교하기에 캐시 메모리에서는 예측하기가 매우 어렵다. 그렇기에 $C$는 상대적으로 다른 두 정렬들보다 큰 값으로 정의된다.

![](https://d2.naver.com/content/images/2020/01/img-1-.gif)

Merge sort

이와 달리, Merge sort의 경우 인접한 덩어리를 병합하기에 참조 지역성의 원리를 어느 정도 잘 만족한다. 그러나 입력 배열 크기만큼의 메모리를 추가로 사용한다는 단점이 있다.

![](https://d2.naver.com/content/images/2020/01/img-2-.gif)

Quick sort

Quick sort의 경우 pivot 주변에서 데이터의 위치 이동이 빈번하게 발생하기에 참조 지역성이 좋으며 메모리를 추가로 사용하지 않는다. 실제로도 $C$의 값은 다른 두 정렬들보다 작은 값으로 정의되어 있고 평균 시간 복잡도는 셋 중에 가장 빠르다고 알려져 있다. 그러나 pivot을 선정하는 방법에 따라 최악의 경우 $O(n2)$이 될 수 있다는 단점이 있다.

위와 같이 모든 정렬 알고리즘에는 장단점이 있어 어떤 한 정렬이 탁월하게 좋다고 선택할 수가 없었다. 상수 $C$의 값이 너무 커지지 않게 동작하며, 추가 메모리도 많이 사용하지 않고, 최악의 경우에도 $O(n\log n)$으로 동작하는 정렬 알고리즘이 필요했다.

## Tim sort의 등장

2002년 소프트웨어 엔지니어 Tim Peters에 의하여 Tim sort가 등장했다. 이 정렬 알고리즘은 Insertion sort와 Merge sort를 결합하여 만든 정렬이다.

실생활 데이터의 특성을 고려하여 더욱 빠르게 고안된 이 알고리즘은 최선의 시간 복잡도는 $O(n)$, 평균은 $O(n\log n)$, 최악의 경우 시간 복잡도는 $O(n\log⁡n)$이다. Tim sort는 안정적인 두 정렬 방법을 결합했기에 안정적이며, 추가 메모리는 사용하지만 기존의 Merge sort에 비해 적은 추가 메모리를 사용하여 다른 $O(n\log⁡n)$ 정렬 알고리즘의 단점을 최대한 극복한 알고리즘이다. 현재 2.3 이후 버전의 Python, Java SE 7, Android, Google chrome (V8), 그리고 swift까지 많은 프로그래밍 언어에서 표준 정렬 알고리즘으로 채택되어 사용되고 있다.

## Tim sort의 기본 원리

Tim sort 알고리즘은 Insertion sort와 Merge sort를 결합한 알고리즘이다. 여기에 시간 복잡도 O(n2)O(n2)으로 알려져 있는 Insertion sort를 왜 결합했을까?

![](https://d2.naver.com/content/images/2020/01/img-3-.gif)

Insertion sort

Insertion sort는 위와 같은 방법으로 동작한다. 인접한 메모리와의 비교를 반복하기에 참조 지역성의 원리를 매우 잘 만족하고 있는 것을 확인할 수 있다. 이에 따라 Insertion sort의 상수 $C$를 $C_i$, $O(n\log ⁡n)$ 정렬 알고리즘 중 $C$ 값이 가장 작다고 알려져 있는 Quick sort의 상수 $C$를 $C_q$​라 할 때, 작은 $n$에 대하여 $C_i×n^2<C_q×n\log ⁡n$이 성립한다. 즉, 작은 $n$에 대하여 Insertion sort가 빠르다는 것이다.

이것을 이용하여 전체를 작은 덩어리로 잘라 각각의 덩어리를 Insertion sort로 정렬한 뒤 병합하면 좀 더 빠르지 않을까 하는 것이 기본적인 아이디어이다.

$2^x$개 씩 잘라 각각을 Insertion sort로 정렬하면 일반적인 Merge sort보다 덩어리 별 $x$개의 병합 동작이 생략되어, Merge sort의 동작 시간을 $C_m×n\log ⁡n$이라 할 때 Tim sort의 동작 시간은 $C_m×n(\log ⁡n−x)+α$가 된다. 이때의 $x$ 값을 최대한 크게 하고 $α$ 값을 최대한 줄이기 위해 여러 가지 최적화 기법이 사용된다.
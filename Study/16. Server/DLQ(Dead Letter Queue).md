## DLQ?

정상 큐(메인 큐)에서 소비(consume)나 처리에 실패한 메시지를 보관하는 보조 큐

일반적인 메시지 큐 시스템(Kafka, RabbitMQ, AWA SQS 등)에서는 메시지를 소비자(consumer)가 가져가서 처리하는데, 어떤 이유로든 처리가 실패하면 그 메시지를 계속 재시도할 수 없다.
이때 그냥 버리면 데이터 손실이 발생하므로, DLQ에 옮겨서 나중에 재처리하거나 분석할 수 있게 하는 것이다.

## 동작 흐름

### 예) 주문 처리 시스템
1. 정상 흐름
	- 프로듀서가 `order.created` 메시지를 MQ에 전송
	- Consumer가 해당 메시지를 받아 DB에 저장
	- 처리 성공 -> 메시지 삭제
2. 실패 상황
	- DB 연결 오류, 포맷 문제 등으로 메시지 처리 실패
	- 시스템이 지정된 횟수(ex. 3회)만큼 재시도
	- 그래도 실패 -> 메시지를 DLQ로 이동
3. 사후 처리
	- DLQ에 쌓인 메시지를 모니터링
	- 수동 or 자동으로 재처리 / 원인 분석
	- 포맷 오류, 잘못된 데이터, 일시적 장애 등 구분하여 대응

## 설계 시 고려할 점

- 언제 DLQ로 보낼지
	- 재시도 횟수, 에러 타입, TTL 설정
- DLQ의 처리 전략
	- 수동 확인 / 자동 재처리 스케줄러
- 모니터링
	- DLQ에 메시지가 쌓이는 속도는 장애의 신호일 수 있음
- 포맷/스키마 검증 강화
	- DLQ 원인 중 절반 이상은 데이터 포맷 오류

## 장단점

### 장점
1. 데이터 손실 방지
	- 처리에 실패한 메시지를 버리지 않고 보관함으로써 데이터 유실을 방지한다. 장애가 나도 나중에 메시지를 복구하거나 재처리할 수 있다.
2. 문제 원인 분석 가능
	- 실패한 메시지를 따로 모아두기 때문에 왜 실패했는지 추적/분석이 쉽다.
	- ex) 포맷 오류, 비즈니스 로직 예외, 외부 API 장애 등
3. 재처리 가능
	- 일시적 오류(ex. DB 장애, 네트워크 끊김)로 실패한 메시지를 DLQ에서 다시 가져와 재시도할 수 있다.
4. 메인 큐 부하 감소
	- 실패한 메시지가 메인 큐에 남지 않고 빠져나가므로, 정상 메시지 처리 흐름이 지연되지 않는다.
5. 운영 안정성 향상
	- 운영자가 "DLQ에 메시지가 쌓이는지"를 모니터링함으로써, 장애의 조기 징후를 감지할 수 있다.
6. 유연한 오류 처리 정책 구현
	- DLQ로 보낼 기준(재시도 횟수, 특정 에러 타입 등)을 설정해 에러에 따라 유연한 대응이 가능하다.

### 단점 / 주의점
1. 메시지 누적 위험(2차 장애)
	- DLQ를 운영자가 신경 쓰지 않으면, 실패 메시지가 계속 쌓여 용량 초과 또는 모니터링 알림 폭주가 발생할 수 있다.
2. 자동 복구는 아님
	- DLQ에 쌓였다고 해서 자동으로 해결되지 않는다. 수동 분석 및 재처리 로직을 별도로 만들어야 한다.
3. 시스템 복잡도 증가
	- DLQ를 운영하려면 추가 Queue/Topic, 설정, 모니터링, 재처리 파이프라인이 필요하다. 운영 및 코드 복잡도가 높아진다.
4. 중복 처리 위험
	- DLQ에서 재처리 시 이미 일부 처리된 메시지를 중복 처리할 위험이 있다. Idenmpotency(멱등성) 설계가 필요하다.
5. 비즈니스 로직 고려 필요
	- 단순한 기술적 실패 외에도, 비즈니스 제약(ex. 결제 실패, 주문 상태 불일치)로 인한 메시지를 어떻게 처리할지 정책이 필요하다.
6. 원인 불명 메시지
	- 포맷 오류나 버전 불일치로 DLQ에 들어간 메시지는 재처리 불가한 경우가 많다. 이런 경우엔 수동 검토가 필요하다.
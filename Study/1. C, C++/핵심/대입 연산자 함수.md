```cpp
Test& operator=(const Test& t);
```
기본적으로 대입 연산자 함수는, 기존의 사칙연산 연산자 함수와 다르게, 자기 자신을 가리키는 레퍼런스(`Test&`)를 반환한다. 왜 굳이 대입 연산자가 자기 자신을 반환해야 되냐면,
```cpp
a = b = c;
```
위와 같은 코드에서 `b = c;`가 `b`를 반환해야지, `a = b;`가 성공적으로 수행될 수 있기 때문이다.

이 때 `Test` 타입을 반환하지 않고 굳이 `Test&` 타입을 반환하냐면, 대입 연산 이후에 **불필요한 복사를 방지**하기 위해서이다.

이와 같은 사실을 바탕으로 `operator=` 함수를 완성시켜 보면 아래와 같다.
```cpp
Test& Test::operator=(const Test& t) {
	_value = t.getValue();
	return *this;
} 
```

```cpp
int main() {
	Test test1(1);
	Test test2(2);
	test2 = test1;
	test2.show(); // 1
}
```
여기서 `operator=`를 만들지 않더라도, 위 소스를 컴파일하면 잘 작동한다. 이는 컴파일러 차원에서 디폴트 대입 연산자(default assignment operator)를 지원하고 있기 때문이다.

디폴트 복사 생성자와 마찬가지로 디폴트 대입 연산자 역시 얕은 복사를 수행한다. 따라서, 깊은 복사가 필요한 클래스의 경우 대입 연산자 함수를 꼭 만들어주어야 할 필요가 있다.

그럼 이제 다음 두 문장의 차이를 이해할 수 있을 것이다.
1)
```cpp
Test test1 = test2;
```
2)
```cpp
Test test1;
test1 = test2;

```
1)의 경우, 아예 `test1`의 복사 생성자가 호출되는 것이고, 2)의 경우 `test1`의 기본 생성자가 호출된 다음, 다음 문장에서 대입 연산자 함수가 실행되는 것이다.
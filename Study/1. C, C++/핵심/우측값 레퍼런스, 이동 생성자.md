## 복사 생략(Copy Elision)

아래 코드를 실행시켜보면 결과가 어떻게 나올까?
```cpp
#include <iostream>

class A {
	int data_;
	
public:
	A(int data) : data_(data) { std::cout << "일반 생성자 호출!" << std::endl; }
	
	A(const A& a) : data_(a.data_) {
		std::cout << "복사 생성자 호출!" << std::endl;
	}
};

int main() {
	A a(1);  // 일반 생성자 호출
	A b(a);  // 복사 생성자 호출
	
	// 그렇다면 이것은?
	A c(A(2));
}
```

```
일반 생성자 호출!
복사 생성자 호출!
일반 생성자 호출!
```
위와 같이 나온다. 뭔가 예상한 것과 결과가 조금 다르다.

```cpp
// 그렇다면 이것은?
A c(A(2));
```
이 부분에서 "일반 생성자 호출!" 한 번만 출력되었다. 아마 정석대로 였다면,
```cpp
A(2);
```
를 만들면서 "일반 생성자 호출!"이 한 번 출력되어야 하고, 생성된 임시 객체로 `c`가 복사 생성되면서 "복사 생성자 호출!"이 될 것이기 때문이다. 그런데 왜 "일반 생성자 호출!" 한 번 밖에 출력되지 않았을까? 복사 생성자가 왜 불리지 않았을까?

사실 생각해보면 굳이 임시 객체를 한 번 만들고, 이를 복사 생성할 필요가 없다. 어차피 `A(2)`로 똑같이 `c`를 만들거면 차라리 `c` 자체를 `A(2)`로 만들어진 객체로 해버리는 것이랑 똑같기 때문이다.

따라서 똑똑한 컴파일러는 복사 생성을 굳이 수행하지 않고, 임시로 만들어진 `A(2)` 자체를 `c`로 만들어버린다. 이렇게, 컴파일러 자체에서 복사를 생략해버리는 작업을 복사 생략(copy elision)이라고 한다.

컴파일러가 복사 생략을 하는 경우는 (함수의 인자가 아닌)함수 내부에서 생성된 객체를 그대로 반환할 때, 수행할 수 있다. 물론 C++ 표준을 읽어보면 반드시 복사 생략을 해라 라는 식이 아니라, 복사 생략을 할 수도 있다 라는 뜻으로 써 있다.

> [!info]
> C++17 부터 일부 경우에 대해(예를 들어, 함수 내부에서 객체를 만들어서 return 할 경우) 반드시 복사 생략을 해야되는 것으로 바뀌었다.

즉, 경우에 따라서는 복사 생략을 해도 되는 경우에, 복사 생략을 하지 않을 수도 있다는 뜻이다.


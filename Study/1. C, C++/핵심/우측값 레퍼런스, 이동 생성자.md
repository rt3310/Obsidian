## 복사 생략(Copy Elision)

아래 코드를 실행시켜보면 결과가 어떻게 나올까?
```cpp
#include <iostream>

class A {
	int data_;
	
public:
	A(int data) : data_(data) { std::cout << "일반 생성자 호출!" << std::endl; }
	
	A(const A& a) : data_(a.data_) {
		std::cout << "복사 생성자 호출!" << std::endl;
	}
};

int main() {
	A a(1);  // 일반 생성자 호출
	A b(a);  // 복사 생성자 호출
	
	// 그렇다면 이것은?
	A c(A(2));
}
```

```
일반 생성자 호출!
복사 생성자 호출!
일반 생성자 호출!
```
위와 같이 나온다. 뭔가 예상한 것과 결과가 조금 다르다.

```cpp
// 그렇다면 이것은?
A c(A(2));
```
이 부분에서 "일반 생성자 호출!" 한 번만 출력되었다. 아마 정석대로 였다면,
```cpp
A(2);
```
를 만들면서 "일반 생성자 호출!"이 한 번 출력되어야 하고, 생성된 임시 객체로 `c`가 복사 생성되면서 "복사 생성자 호출!"이 될 것이기 때문이다. 그런데 왜 "일반 생성자 호출!" 한 번 밖에 출력되지 않았을까? 복사 생성자가 왜 불리지 않았을까?

사실 생각해보면 굳이 임시 객체를 한 번 만들고, 이를 복사 생성할 필요가 없다. 어차피 `A(2)`로 똑같이 `c`를 만들거면 차라리 `c` 자체를 `A(2)`로 만들어진 객체로 해버리는 것이랑 똑같기 때문이다.

따라서 똑똑한 컴파일러는 복사 생성을 굳이 수행하지 않고, 임시로 만들어진 `A(2)` 자체를 `c`로 만들어버린다. 이렇게, 컴파일러 자체에서 복사를 생략해버리는 작업을 복사 생략(copy elision)이라고 한다.

컴파일러가 복사 생략을 하는 경우는 (함수의 인자가 아닌)함수 내부에서 생성된 객체를 그대로 반환할 때, 수행할 수 있다. 물론 C++ 표준을 읽어보면 반드시 복사 생략을 해라 라는 식이 아니라, 복사 생략을 할 수도 있다 라는 뜻으로 써 있다.

> [!info]
> C++17 부터 일부 경우에 대해(예를 들어, 함수 내부에서 객체를 만들어서 return 할 경우) 반드시 복사 생략을 해야되는 것으로 바뀌었다.

즉, 경우에 따라서는 복사 생략을 해도 되는 경우에, 복사 생략을 하지 않을 수도 있다는 뜻이다.

```cpp
#include <iostream>
#include <cstring>

class MyString {
	char *string_content;  // 문자열 데이터를 가리키는 포인터
	int string_length;     // 문자열 길이
	
	int memory_capacity;  // 현재 할당된 용량
	
public:
	MyString();
	
	// 문자열로 부터 생성
	MyString(const char *str);
	
	// 복사 생성자
	MyString(const MyString &str);
	
	void reserve(int size);
	MyString operator+(const MyString &s);
	~MyString();
	
	int length() const;
	
	void print();
	void println();
};

MyString::MyString() {
	std::cout << "생성자 호출 ! " << std::endl;
	string_length = 0;
	memory_capacity = 0;
	string_content = nullptr;
}

MyString::MyString(const char *str) {
	std::cout << "생성자 호출 ! " << std::endl;
	string_length = strlen(str);
	memory_capacity = string_length;
	string_content = new char[string_length];
	
	for (int i = 0; i != string_length; i++) string_content[i] = str[i];
}
MyString::MyString(const MyString &str) {
	std::cout << "복사 생성자 호출 ! " << std::endl;
	string_length = str.string_length;
	memory_capacity = str.string_length;
	string_content = new char[string_length];
	
	for (int i = 0; i != string_length; i++)
		string_content[i] = str.string_content[i];
}
MyString::~MyString() { delete[] string_content; }
void MyString::reserve(int size) {
	if (size > memory_capacity) {
		char *prev_string_content = string_content;
	
		string_content = new char[size];
		memory_capacity = size;
		
		for (int i = 0; i != string_length; i++)
			string_content[i] = prev_string_content[i];
		
		if (prev_string_content != nullptr) delete[] prev_string_content;
	}
}
MyString MyString::operator+(const MyString &s) {
	MyString str;
	str.reserve(string_length + s.string_length);
	for (int i = 0; i < string_length; i++)
		str.string_content[i] = string_content[i];
	for (int i = 0; i < s.string_length; i++)
		str.string_content[string_length + i] = s.string_content[i];
	str.string_length = string_length + s.string_length;
	return str;
}
int MyString::length() const { return string_length; }
void MyString::print() {
	for (int i = 0; i != string_length; i++) std::cout << string_content[i];
}
void MyString::println() {
	for (int i = 0; i != string_length; i++) std::cout << string_content[i];

	std::cout << std::endl;
}

int main() {
	MyString str1("abc");
	MyString str2("def");
	std::cout << "-------------" << std::endl;
	MyString str3 = str1 + str2;
	str3.println();
}
```

```
생성자 호출!
생성자 호출!
-------------
생성자 호출!
복사 생성자 호출!
abcdef
```
위 코드를 실행시켜보면 위와 같이 나온다.

```cpp
MyString str3 = str1 + str2;
```
이 부분에서 두 개의 문자열을 더 한 새로운 문자열로 `str3`을 생성하고 있다.

```cpp
MyString MyString::operator+(const MyString &s) {
	MyString str;
	str.reserve(string_length + s.string_length);
	for (int i = 0; i < string_length; i++)
		str.string_content[i] = string_content[i];
	for (int i = 0; i < s.string_length; i++)
		str.string_content[string_length + i] = s.string_content[i];
	str.string_length = string_length + s.string_length;
	return str;
}
```
위 함수가 `str1 + str2`를 실행 할 때 호출되는데, 먼저 빈 `MyString` 객체인 `str`을 생성한다(생성자 호출! 출력). 그 후에, `reserve()` 함수를 이용해서 공간을 할당하고, `str1`과 `str2`를 더한 문자열을 복사하게 된다.
이렇게 반환된 `str`은 `str3`을 생성하는데 전달돼서, `str3`의 복사 생성자가 호출된다.

하지만 여기서, 굳이 `str3`의 복사 생성자를 또 호출할 필요가 없다. 왜냐하면, 어차피 똑같이 복사해서 생성할 것이면, 이미 생성된 `str1 + str2`가 반환한 객체를 `str3` 셈 치고 사용하면 되기 때문이다.
이전의 예제에서는 컴파일러가 불필요한 복사 생성자 호출을 복사 생략을 통해 수행하지 않았지만, 이 예제의 경우, 컴파일러가 복사 생략 최적화를 수행하지 않았다.

과정을 그림으로 간단히 살펴보면 다음과 같다.
![[996BBA465AB638B019DAE7 1.webp]]
```cpp
#include <iostream>
#include <string>
using namespace std;

class Test {
	int value;
	
public:
	Test(int value);
	Test(const Test& other);
};

Test::Test(int value) {
	cout << "기본 생성자" << endl;
}

Test::Test(const Test& other) {
	cout << "복사 생성자" << endl;
}

int main() {
	Test test1(1); // 생성자 호출
	Test test2(test1); // 복사 생성자 호출
	Test test3 = test2; // 복사 생성자 호출
}
```

```cpp
Test test3 = test2;
```
C++ 컴파일러는 위 문장을 아래와 동일하게 해석한다. 
```cpp
Test test3(test2);
```
다라서 복사 생성자가 호출되게 되는 것이다.

> [!warning] 생성 시에만 대입해야 한다.
> ```cpp
> Test test3 = test2;
> ```
> 와
> ```cpp
> Test test3;
> test3 = test2;
> ```
> 는 엄연히 다른 문장이다. 왜냐하면 위는 말 그대로 복사 생성자가 1번 호출되는 것이고, 아래는 그냥 생성자가 1번 호출되고, `test3 = test2;`라는 명령이 실행되는 것이기 대문이다.
> 즉, 복사 생성자는 오직 '생성' 시에만 호출된다.

### 디폴트 복사 생성자(default copy constructor)
디폴트 생성자와 디폴트 소멸자처럼, C++ 컴파일러는 이미 디폴트 복사 생성자를 지원해주고 있다.
디폴트 복사 생성자의 경우 기존의 디폴트 생성자와 소멸자가 하는 일이 아무 것도 없었던 것과는 달리, 실제로 '복사'를 해준다.

### 디폴트 복사 생성자의 한계
```cpp
#include <iostream>
#include <string>
using namespace std;

class Test {
	char* _value;
public:
	Test(const char* value);
	~Test();
};

Test::Test(const char* value) {
	_value = new char[strlen(value) + 1];
	strcpy(_value, value);
}

Test::~Test() {
	// 0이 아닌 값은 if 문에서 true로 처리되므로, 0인가 아닌가를 비교할 때 그냥 if(_value) 하면
	// if(_value != 0) 과 동일한 의미를 가질 수 있다.
	if (_value)
		delete[] _value;_
}

int main() {
	Test test1("test");
	Test test2 = test1;
}
```
컴파일 후 실행해보면 아래와 같은 오류를 만나게 된다.
![[Pasted image 20251106230858.png]]
이는 test1의 \_value와  test2의 \_value가 같은 메모리를 가리키는데, 둘 다 메모리 해제를 수행하는 소멸자를 호출하기 때문이다.

때문에 메모리를 새로 할당해서 복사하는 **깊은 복사(deep copy)** 를 통해 복사를 해주는 것이 좋다. 이를 위해선 직접 복사 생성자를 만들어야 한다.
```cpp
Test::Test(const Test& other) {
	_value = new char[strlen(other._name) + 1];
	strcpy(_value, other._value);
}
```
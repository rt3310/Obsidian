## static_cast

static_cast는 C스타일 캐스터와 똑같은 의미와 형변환 능력을 가지고 있는 기본적인 캐스트 연산자이다.
static_cast는 컴파일 시간에 타입 체크를 수행하며, 기본적인 타입 변환, 클래스 계층 내에서의 업캐스트(자식 → 부모 변환)와 다운캐스트(부모 → 자식 변환)를 모두 지원한다. 주로 업캐스팅에 사용된다.

다만, 강제 캐스팅(C 스타일 캐스트)과 다른 점은 논리상 맞지 않는 변환을 막아주는 역할을 한다는 것이다.
```cpp
const int num = 10;
int* p = NULL;
p = static_cast<int*>(&num); // 컴파일 에러
```

단, 다운캐스트의 경우 static_cast는 타입 안전성을 보장하지 않는다. 즉, 실제 객체가 변환하려는 타입이 아닌 경우에도 컴파일러는 오류를 발생시키지 않는다.

때문에 다음 코드를 살펴보면
```cpp
class Base {
	std::string s;

public:
	Base() : s("기반") { std::cout << "기반 클래스" << std::endl; }

	void what() { std::cout << s << std::endl; }
};

class Derived : public Base {
	std::string s;

public:
	Derived() : s("파생"), Base() { std::cout << "파생 클래스" << std::endl; }

	void what() { std::cout << s << std::endl; }
};

int main() {
	Base p;
	Derived c;
	
	std::cout << "=== 포인터 버전 ===" << std::endl;
	Base* p_p = &p;
	
	Derived* p_c = static_cast<Derived*>(p_p);
	p_c->what();
	
	return 0;
}
```
컴파일 에러가 발생하지 않아 정상적으로 실행될 것 같지만, 실행시켜보면 런타임 에러가 발생하는 것을 알 수 있다.

이렇게 강제적으로 다운 캐스팅을 하는 경우, 컴파일 타임에서 오류를 찾아내기 매우 힘들기 때문에 다운 캐스팅은 작동이 보장되지 않는 한 매우 권장하지 않는다.
이러한 캐스팅에 따른 오류를 미연에 방지하기 위해서, C++에서는 상속 관계에 있는 두 포인터들 간에 캐스팅을 해주는 `dynamic_cast`라는 것을 지원한다.

## dynamic_cast

dynamic_cast는 런타임에 타입 안전성을 검사(RTTI)한다. 주로 다형성을 가진 클래스(가상 함수를 가진 클래스)의 포인터나 참조 간의 변환에 사용된다. 또 주로 다운 캐스팅에 사용된다.

dynamic_cast는 다운 캐스팅 시 실제 객체 타입이 목표 타입과 일치하는지 확인하고, 일치하지 않으면 nullptr을 반환한다(포인터의 경우). 이는 타입 안전성을 제공한다.

사용하는 방법은 `static_cast`와 거의 동일하다.
안전하게 다운캐스팅을 할 때 가장 많이 활용되고, 하나 이상의 가상함수가 있는 상속관계에서 사용된다.
```cpp
Derived* p_c = dynamic_cast<Derived*>(p_p);
```
위 코드로 작성하고 컴파일하게 되면 캐스팅 할 수 없다는 컴파일 에러가 발생하는 것을 확인할 수 있다. 

## const_cast

const_cast는 객체의 `const` 또는 `volatile` 속성을 추가하거나 제거한다. 이는 주로 상수 객체에 대한 수정이 필요할 때 사용된다.
즉, 타입 자체의 변환보다는 객체의 속성을 변경하는데 초점을 맞춘다.

## reinterpret_cast

reinterpret_cast는 서로 관련 없는 타입 간의 변환을 위해 사용된다.
포인터 타입을 다른 포인터 타입으로, 포인터를 충분한 크기의 정수 타입으로 변환하는 데 주로 사용된다. 이는 매우 낮은 저수준의 변환을 수행하며, 안전하지 않을 수 있다.


> [!info] 출처
> https://strawvery-devlog.tistory.com/33
## shared_ptr

`unique_ptr`을 사용해서 다 해결할 수 있으면 좋겠지만, 때에 따라서 여러 개의 스마트 포인터가 하나의 객체를 같이 소유해야 하는 경우가 발생한다.
예를 들어, 여러 객체에서 하나의 자원을 사용하고자 한다. 후에 자원을 해제하기 위해서는 이 자원을 사용하는 모든 객체들이 소멸되어야 하는데, 어떤 객체가 먼저 소멸되는지 알 수 없기 때문에 이 자원 역시 어느 타이밍에 해제시켜야 할 지 알 수 없게 된다.

따라서 이 경우에 특정 자원을 몇 개의 객체에서 가리키는지 추적한 다음, 그 수가 0이 되어야만 해제를 시켜주는 방식의 포인터가 필요하다. 이를 `shared_ptr`이 수행한다.

`shared_ptr`은 기존에 유일하게 객체를 소유하는 `unique_ptr`과는 다르게, `shared_ptr`로 객체를 가리킬 경우, 다른 `shared_ptr` 역시 그 객체를 가리킬 수 있다.
```cpp
std::shared_ptr<A> p1(new A());
std::shared_ptr<A> p2(p1);  // p2 역시 생성된 객체 A 를 가리킨다.

// 반면에 unique_ptr 의 경우
std::unique_ptr<A> p1(new A());
std::unique_ptr<A> p2(p1);  // 컴파일 오류!
```

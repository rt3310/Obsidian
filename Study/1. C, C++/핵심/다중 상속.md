C++에서는 한 클래스가 다른 여러 개의 클래스들을 상속 받는 것을 허용한다. 이를 가리켜 **다중 상속(multiple inheritance)** 이라고 부른다.
```cpp
#include <iostream>

class A {
public:
	int a;
	
	A() { std::cout << "A 생성자 호출" << std::endl; }
};

class B {
public:
	int b;
	
	B() { std::cout << "B 생성자 호출" << std::endl; }
};

class C : public A, public B {
public:
	int c;
	
	C() : A(), B() { std::cout << "C 생성자 호출" << std::endl; }
};
int main() { C c; }
```
위 경우, 클래스 `C`가 `A`와 `B`로 부터 동시에 같이 상속 받고 있다.

그리고 실행해보면 생성자가 `A` → `B` → `C` 순으로 호출됨을 알 수 있다. 그리고 상속 순서를 바꿔
```cpp
class C : public B, public A
```
이렇게 해보면 이번에는 `B` → `A` → `C` 순으로 호출됨을 알 수 있다.

즉, 순서는 단순히 상속하는 순서에 좌우됨을 알 수 있다.

## 주의할 점

### 멤버 변수/함수 중복
```cpp
class A {
public:
	int a;
};

class B {
public:
	int a;
};

class C : public B, public A {
public:
	int c;
};
```
위와 같이 두 개의 클래스에서 이름이 같은 멤버 변수나 함수가 있다고 해보자. 이를 다음처럼 클래스 `C`의 객체를 생성해서, 중복되는 멤버 변수에 접근한다면,
```cpp
int main() {
	C c;
	c.a = 3;
}
```
`B`의 `a`인지, `A`의 `a`인지 구분할 수 없어 컴파일 에러가 발생하는 것을 볼 수 있다.

### 다이아몬드 상속(diamond inheritance)
```cpp
class Human {
	// ...
};
class HandsomeHuman : public Human {
	// ...
};
class SmartHuman : public Human {
	// ...
};
class Me : public HandsomeHuman, public SmartHuman {
	// ...
};
```
위와 같은 코드를 살펴보자. 이 클래스 들의 상속 구조는 다음과 같이 다이아몬드 형태를 띄는 것을 볼 수 있다.
![[Pasted image 20251108012122.png]]

여기서 만약  `Human`에 `name`이라는 멤버 변수가 있다고 해보자. 그러면 `HandsomeHuman`과 `SmartHuman`은 모두 `Human`을 상속받고 있으므로, 여기에도 `name`이라는 변수가 들어가게 된다.

그런데, `Me`가 이 두 개의 클래스를 상속 받으니 `Me`에서는 `name`이라는 변수가 겹치게 된다.
결과적으로 볼 때 `HandsomeHuman`과 `SmartHuman`을 아무리 안겹치게 만든다고 해도, `Human`의 모든 내용이 중복되는 문제가 발생하게 된다.

다행히 이를 해결할 수 있는 방법이 있다.
```cpp
class Human {
public:
	// ...
};
class HandsomeHuman : public virtual Human {
	// ...
};
class SmartHuman : public virtual Human {
	// ...
};
class Me : public HandsomeHuman, public SmartHuman {
	// ...
};
```
이러한 형태로 `Human`을 `virtual`로 상속 받는다면, `Me`에서 다중 상속 시에도, 컴파일러가 언제나 `Human`을 한 번만 포함하도록 지정할 수 있게 된다.
참고로, 가상 상속 시에, `Me`의 생성자에서 `HandsomeHuman`과 `SmartHuman`의 생성자 호출은 당연하고, `Human`의 생성자 또한 호출해주어야만 한다.
## 사칙연산자

만일 다음과 같이 연산자의 오버로딩을 모른다고 가정하고 `Complex`(복소수) 클래스를 구성해보자.
```cpp
class Complex {
private:
	double real, img;

public:
	Complex(double real, double img) : real(real), img(img) {}

	Complex plus(const Complex& c);
	Complex minus(const Complex& c);
	Complex times(const Complex& c);
	Complex divide(const Complex& c);
};
```
이렇게 된다면 만일 `int`형 변수였다면
```cpp
a + b / c + d;
```
로 간단하게 쓸 수 있던 명령을
```cpp
a.plus(b.divide(c)).plus(d);
```
와 같이 복잡한 함수식을 이용해서 표현해야만 한다. 이는 가독성이 떨어질 뿐더러 위 식을 딱 보고 무슨 작업을 하려고 하는지도 쉽게 알 수 없다.

하지만 연산자 오버로딩을 이용해서 `plus` 를 `operator+` 로, `divide` 를 `operator/` 로, 등등 바꿔준다면 단순히 프로그래머가`a + b/c + d;` 게 쓴다고 해도, 컴파일러가 `a.operator+(b.operator/(c)).operator+(d);` 로 알아서 변환시켜서 처리하기 때문에 속도나 다른 면의 어떠한 차이 없이 뛰어난 가독성과 편리함을 얻을 수 있게 된다.
이를 바탕으로 간단히 `Complex` 클래스를 만들어본다면
```cpp
#include <iostream>

class Complex {
private:
	double real, img;

public:
	Complex(double real, double img) : real(real), img(img) {}
	Complex(const Complex& c) { real = c.real, img = c.img; }

	Complex operator+(const Complex& c) const;
	Complex operator-(const Complex& c) const;
	Complex operator*(const Complex& c) const;
	Complex operator/(const Complex& c) const;

	void println() { std::cout << "( " << real << " , " << img << " ) " << std::endl; }
};

Complex Complex::operator+(const Complex& c) const {
	Complex temp(real + c.real, img + c.img);
	return temp;
}
Complex Complex::operator-(const Complex& c) const {
	Complex temp(real - c.real, img - c.img);
	return temp;
}
Complex Complex::operator*(const Complex& c) const {
	Complex temp(real * c.real - img * c.img, real * c.img + img * c.real);
	return temp;
}
Complex Complex::operator/(const Complex& c) const {
	Complex temp(
		(real * c.real + img * c.img) / (c.real * c.real + c.img * c.img),
		(img * c.real - real * c.img) / (c.real * c.real + c.img * c.img));
	return temp;
}

int main() {
	Complex a(1.0, 2.0);
	Complex b(3.0, -2.0);

	Complex c = a * b;

	c.println();
}
```
성공적으로 컴파일 했다면
```
(7, 4)
```
와 같이 잘 나옴을 알 수 있다. 여기서 가장 중요하게 봐야 할 부분은 바로, 사칙연산 연산자 함수들의 리턴 타입이다.
```cpp
  Complex operator+(const Complex& c) const;
  Complex operator-(const Complex& c) const;
  Complex operator*(const Complex& c) const;
  Complex operator/(const Complex& c) const;
```
위 4 개의 연산자 함수 모두 `Complex&` 가 아닌 `Complex` 를 리턴하고 있다. 간혹가다,
```cpp
Complex& operator+(const Complex& c) {
	real += c.real;
	img += c.img;
	return *this;
}
```
로 잘못 생각하는 경우도 있다.
물론 이렇게 설계하였을 경우, 복사 대신 레퍼런스만 복사하는 것이므로, 값의 복사가 일어나는 `Complex`리턴 방식보다 큰 속도의 저하는 나타나지 않는다.

하지만, 위와 같이 `operator+` 를 정의할 경우 다음과 같은 문장이 어떻게 처리되는지 생각해보자.
```cpp
Complex a = b + c + b;
```

아마도 위 문장을 쓴 사람 입장에서는 결과적으로 `a = 2 * b + c;` 를 의도하였을 것이다.

하지만, 실제로 처리되는 것을 보자면, `(b.plus(c)).plus(b)` 가 되는데, `b.plus(c)` 를 하면서 `b` 에는 `(b + c)` 가 들어가고, 거기에 다시 `plus(b)` 를 하게 된다면 값 자체만 보자면 `(b + c) + (b + c)` 가 돼서 (왜냐하면 현재 `b` 에는 `b + c` 가 들어가 있으니까) `a = 2 * b + 2 * c` 가 되기 때문이다.
이러한 문제를 막기 위해서는 반드시 사칙 연산의 경우 반드시 값을 리턴해야만 한다.

또한 함수 내부에서 읽기만 수행되고 값이 바뀌지 않는 인자들에 대해서는 `const` 키워드를 붙여주는 것이 바람직하다. `operator+` 의 경우, `c` 의 값을 읽기만 하지 `c` 의 값에 어떠한 변화도 주지 않으므로 `const Complex&` 타입으로 인자를 받았다.

> [!WARNING]
> 인자의 값이 함수 내부에서 바뀌지 않는 다고 확신할 때에는 `const` 키워드를 붙이자. 이는 나중에 발생할 수 있는 실수들을 줄여준다.

또한 이 버전의 `operator+` 들의 경우 객체 내부의 값을 변경하지 않기 때문에 상수 함수로 선언하였다.

> [!WARNING]
> 상수 함수로 선언할 수 있는 경우 상수 함수로 선언하는 것이 바람직하다.

## 첨자 연산자 (`operator[]`)

```cpp
#include <iostream>
#include <cstring>

class MyString {
	char* string_content;  // 문자열 데이터를 가리키는 포인터
	int string_length;     // 문자열 길이
	
	int memory_capacity;  // 현재 할당된 용량
public:
	// 문자 하나로 생성
	MyString(char c);
	
	// 문자열로 부터 생성
	MyString(const char* str);
	
	// 복사 생성자
	MyString(const MyString& str);
	
	~MyString();
	
	int length();
	
	void print() const;
	void println() const;
	
	char& operator[](const int index);
};

MyString::MyString(char c) {
	string_content = new char[1];
	string_content[0] = c;
	memory_capacity = 1;
	string_length = 1;
}
MyString::MyString(const char* str) {
	string_length = strlen(str);
	memory_capacity = string_length;
	string_content = new char[string_length];
	
	for (int i = 0; i != string_length; i++) string_content[i] = str[i];
}
MyString::MyString(const MyString& str) {
	string_length = str.string_length;
	string_content = new char[string_length];
	
	for (int i = 0; i != string_length; i++)
	string_content[i] = str.string_content[i];
}
MyString::~MyString() { delete[] string_content; }
int MyString::length() { return string_length; }
void MyString::print() const {
	for (int i = 0; i != string_length; i++) {
		std::cout << string_content[i];
	}
}
void MyString::println() const {
	for (int i = 0; i != string_length; i++) {
		std::cout << string_content[i];
	}
	std::cout << std::endl;
}

char& MyString::operator[](const int index) { return string_content[index]; }

int main() {
	MyString str("abcdef");
	str[3] = 'c';
	
	str.println();
}
```

커스텀 `MyString` 클래스에 `operator[]`를 추가한 코드이다.
```cpp
char& operator[](const int index);
```
여기서 `char&`를 인자로 반환하는 이유는
```cpp
str[10] = 'c';
```
와 같은 명령을 수행하기 때문에, 그 원소의 레퍼런스를 반환하게 되는 것이다.

## 타입 변환 연산자 (`operator (type)`)

`int` 자료형을 감싸는 Wrapper 클래스를 구현한다 해보자.
```cpp
class Int {
	int data;
	// some other data
 public:
	 Int(int data) : data(data) {}
	 Int(const Int& i) : data(i.data) {}
};
```
이 Wrapper 클래스가 연산을 잘 수행하기 위해서 모든 연산자 함수를 만들어주면 될 것이라 생각할 것이다.
물론 그렇게 할 수 있지만 그 수 많은 연산자들을 일일이 오버로딩 하는 것은 꽤 힘든 작업일 것이다.

그렇게 하는 것 보다 그냥 이 Wrapper 클래스의 객체를 마치 '`int` 형 변수'라고 컴파일러가 생각할 수 있게 하는 것이 편할 것이다.
이를 타입 변환 연산자를 통해 수행할 수 있다.
```cpp
operator (변환하고자 하는 타입) ()
```

한 가지 주의할 점은, 생성자처럼 함수의 반환 타입을 쓰면 안된다는 것이다. 이는 C++에서 변환 연산자를 정의하기 위한 언어 상의 규칙으로 볼 수 있다. 그러면 다음과 같이 간단히 작성할 수 있다.
```cpp
operator int() { return data; }
```

```cpp
class Int {
	int data;
	// some other data
 public:
	 Int(int data) : data(data) {}
	 Int(const Int& i) : data(i.data) {}
	 
	 operator int() { return data; }
};

int main() {
	Int x = 3;
	int a = x + 4;
	
	x = a * 2 + x + 4;
	cout << x << endl;
}
```

## 전위/후위 증감 연산자 `operator++, operator--`

C++ 컴파일러는 전위/후위 증감을 구분해서 오버로딩 시켜준다.

### 선언 방법
#### 전위 증감 연산자
```cpp
operator++();
operator--();
```
#### 후위 증감 연산자
```cpp
operator++(int x);
operator--(int x);
```
여기서 인자  `x`는 아무 의미가 없다. 단순히 컴파일러 상에서 전위와 후위를 구별하기 위해 int 인자를 넣어주는 것이다.
실제로 `++`를 구현하면서 인자로 들어가는 값을 사용하는 경우는 없다. 따라서 그냥
```cpp
operator++(int);
operator--(int);
```
와 같이 해도 무방하다.

한 가지 중요한 점은,
전위 증감 연산의 경우 값이 바뀐 자기 자신을 반환해야 하고,
후위 증감 연산의 경우 값이 바귀기 이전의 객체를 반환해야 한다는 점이다.

때문에 다음과 같이 구현할 수 있다.
### 구현 방법
#### 전위 증감 연산자
```cpp
A& operator++() {
	// A++을 수행한다.
	return *this;
}
```
#### 후위 증감 연산자
```cpp
A operator++(int) {
	A temp(A);
	// A++을 수행한다.
	return temp;
}
```

후위 증감 연산의 경우 추가적으로 복사 생성자를 호출하기 때문에 전위 증감 연산보다 더 느리다.
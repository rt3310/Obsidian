1. 자신과 타입이 정확히 일치하는 함수를 찾는다.
2. 정확히 일치하는 타입이 없는 경우 아래와 같은 형변환을 통해서 일치하는 함수를 찾아본다.
	- `char`, `unsigned char`, `short`는 `int`로 변환된다.
	- `unsigned short`는 `int`의 크기에 따라 `int` 혹은 `unsigned int`로 변환된다.
	- `float`은 `double`로 변환된다.
	- `enum`은 `int`로 변환된다.
3. 위와 같이 변환해도 일치하는 것이 없다면, 아래의 좀 더 포괄적인 형변환을 통해 일치하는 함수를 찾는다.
	- 임의의 숫자(numeric) 타입은 다른 숫자 타입으로 변환된다. (예를 들어 `float` -> `int`)
	- `enum`도 임의의 숫자 타입으로 변환된다. (예를 들어 `enum` -> `double`)
	- `0`은 포인터 타입이나 숫자 타입으로 변환된다.
	- 포인터는 `void` 포인터로 변환된다.
4. 유저 정의된 타입 변환으로 일치하는 것을 찾는다. 
	- [참고](https://www.learncpp.com/cpp-tutorial/introduction-to-function-overloading/)

만약 컴파일러가 위 과정을 통해더라도 일치하는 함수를 찾을 수 없거나 같은 단계에서 두 개 이상이 일치하는 경우에 모호하다(ambiguous)라고 판단해서 오류가 발생하게 된다.

## 모호한 오버로딩

```cpp
#include <iostream>

void print(int x) { std::cout << "int : " << x << std::endl; }
void print(char x) { std::cout << "double : " << x << std::endl; }

int main() {
	int a = 1;
	char b = 'c';
	double c = 3.2f;

	print(a);
	print(b);
	print(c);

	return 0;
}
```

**결과: 컴파일 오류**
```
 error C2668: 'print' : ambiguous call to overloaded function
 could be 'void print(char)'
 or       'void print(int)'
while trying to match the argument list '(double)'
```

왜 오류가 발생했는지 살펴보자.
일단 위 소스에서는 함수가 `print(int x)` 와 `print(char x)` 밖에 없으므로 관건은 `print(c);`를 했을 때 어떠한 함수가 호출되어야 하는지 결정하는 것이다.

1. `print(c)`를 했을 때 1단계에서는 명백하게 일치하는 것이 없다.
2. 2단계에서는 마찬가지로 `double`의 캐스팅에 관련한 내용이 없기에 일치하는 것이 없고 비로소 3단계로 넘어오게 된다.
3. 3단계에서는 '임의의 숫자 타입이 임의의 숫자 타입'으로 변환돼서 생각되기 때문에 `double`은 `char`도 `int`도 변환될 수 있게 되는 것이다.
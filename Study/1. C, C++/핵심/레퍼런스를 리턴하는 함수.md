
```cpp
class Test {
	int _value;
public:
	Test(int value) : _value(value) {}
	
	int& accessValue() { return _value; }
	int getValue() { return _value; }
	void showValue() { cout << _value << endl; }
};

int main() {
	Test test(5);
	test.showValue(); // 5
	
	int& v1 = test.accessValue();
	v1 = 4;
	test.showValue(); // 4
	
	int v2 = test.accessValue();
	v2 = 3;
	test.showValue(); // 4
	
	// int& v3 = test.getValue(); // error
	// v3 = 2;
	// test.showValue();
	
	int v4 = test.getValue();
	v3 = 1;
	test.showValue(); // 4
}
```
위 코드의 실행 결과를 보고 다음을 살펴보자.

```cpp
int& v1 = test.accessValue();
v1 = 4;
test.showValue();
```
여기서 레퍼런스 `v1`은 `_value`의 레퍼런스, 즉 `_value`의 별명을 받았다. 따라서, `v1`은 `_value`의 별명으로 탄생하게 되는 것이다.
레퍼런스를 리턴하는 함수는 그 함수 부분을 원래의 변수로 치환했다고 생각해도 상관이 없다. 다시 말해
```cpp
int& v1 = _value;
```
와 동일한 말이라는 것이다. 따라서 `v1`의 값을 바꾸는 것은 `Test`의 `_value`의 값을 바꾸는 것과 동일한 의미이므로 `showValue()`를 실행 시에 `_value`의 값이 5에서 4로 바뀌었음을 알 수 있다.

```cpp
int v2 = test.accessValue();
v2 = 3;
test.showValue();
```
이번에는 `int&`가 아닌 그냥 `int` 변수에 '`_value`의 별명'을 전달했다. 만약 `v2`가`int&` 였다면 `_value`의 별명을 받아서 `v2`역시 또 다른 `_value`의 별명이 되었겠지만, `v2`가 그냥 `int` 변수이므로, 값의 복사가 일어나, `_value`의 값이 들어가게 된다. 그리고 당연히, `v2`는 `_value`의 별명이 아닌 또 다른 독립적인 변수이기에, `v2 = 3;`을 해도 `_value`의 값은 바뀌지 않은 채, 그냥 4가 출력된다.

```cpp
// int& v3 = test.getValue(); // error
// v3 = 2;
// test.showValue();
```
이 케이스는 다음과 같이 컴파일 에러가 발생하는 상황이다.
```
error C2440: 'initializing' : cannot convert from 'int' to 'int &'
```
그 이유는 레퍼런스가 아닌 타임을 리턴하는 경우는 '값'의 복사가 이루어지기 때문에 임시 객체가 생성되는데, 임시 객체의 레퍼런스를 가질 수 없기 때문이다(임시객체는 문장이 끝나면 소멸된다).

정확히 말하면, `int&`는 좌측값에 대한 레퍼런스이고, `test.getValue()`는 우측값이기 때문에 레퍼런스를 만들 수 없다.
> 포인터가 주소값만 보관하는데 왜 굳이 타입이 필요할까? 어차피 주소값은 32 비트 시스템에서 항상 4 바이트이고, 64 비트 시스템에서는 8 바이트 인데 그냥 `pointer` 라는 타입을 만들어버리면 안될까?

만약 `pointer`라는 타입이 있다고 생각하고 아래 코드를 살펴보자
```cpp
int a;
pointer *p;
p = &a;
*p = 4;
```

컴퓨터 입장에서 위 코드를 어떤 식으로 해석할 지 생각해보자.
```cpp
int a;
pointer *p;
p = &a;
```
위 세 문장까지는 아주 좋다. 메모리에 `a`를 위해서 4 bytes 공간을 마련해줬고, 마찬가지로 `p`를 위해 메모리 상에 8 bytes 공간을 마련하였다. 그리고 `p`에 `a`의 주소값을 잘 전달했다.

문제는 아래 문장이다.
```cpp
*p = 4;
```

포인터 `p`에는 명백히 변수 `a`의 주소값이 들어있다. 여기서 문제는 `a`가 메모리에서 차지하는 모든 주소들의 위치가 들어있는 것이 아니라 **시작 주소**만 들어가 있다는 점이다.

따라서, `*p`라고 했을 때 컴퓨터는 메모리에서 얼마만큼을 읽어들어야 할지 알 길이 없다.

한편
```cpp
int a;
int *p;
p = &a;
*p = 4;
```
라고 한다면 어떨까? 컴퓨터는 포인터 `p`가 `int*`라는 사실을 보고 '이 포인터는 `int` 데이터를 가리키는구나' 라고 알게 되어 시작 주소로부터 정확히 4 bytes를 읽어 들여 값을 바꾸게 된다.

## 포인터도 변수다

```cpp
#include <stdio.h>
int main() {
	int a;
	int b;
	int *p;

	p = &a;
	*p = 2;
	p = &b;
	*p = 4;

	printf("a: %d \n", a);
	printf("b: %d \n", b);
	return 0;
}
```
결과
```
a: 2
b: 4
```

포인터는 **변수**이다.

즉, 포인터에 들어간 주소 값이 바꿀 수 있다는 것이다. 위와 같이 처음에 `a`를 가리켰다가(즉 `p`에 변수 `a`의 주소값이 들어갔다가), 나중에 `b`를 가리킬 수 있다는 것이다.

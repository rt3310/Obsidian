index = X.hashCode() % M을 계산할 때 사용하는 M 값은 **소수일 때 index 값 분포가 가장 균등할 수 있다**. 그러나 M 값이 소수가 아니기 때문에 별도의 보조 해시 함수를 이용하여 index 값 분포가 가급적 균등할 수 있도록 해야 한다.

보조 해시 함수(supplement hash function)의 목적은 **'키'의 해시 값을 변형하여, 해시 충돌 가능성을 줄이는 것**이다. 이 보조 해시 함수는 JDK 1.4에 처음 등장했다. Java 5 ~ Java 7은 같은 방식의 보조 해시 함수를 사용하고, **Java 8부터는 다시 새로운 방식의 보조 해시 함수를 사용**하고 있다.

Java 7 HashMap에서의 보조 해시 함수
```java
final int hash(Object k) {
	// Java 7부터는 JRE를 실행할 때, 데이터 개수가 일정 이상이면 String 객체에 대해서 JVM에서 제공하는 별도의 옵션으로 해시 함수를 사용하도록 할 수 있다.
	// 만약 이 옵션을 사용하지 않으면 hashSeed의 값은 0이다.
	int h = hashSeed;
	if (0 != h && k instanceof String) {
		return sun.misc.Hashing.stringHash32((String) k);
	}
	h ^= k.hashCode();
	// 해시 버킷의 개수가 2a이기 때문에 해시 값의 a비트 값만을 해시 버킷의 인덱스로 사용한다.
	// 따라서 상위 비트의 값이 해시 버킷의 인덱스 값을 결정할 때 반영될 수 있도록 shift 연산과 XOR 연산을 사용하여, 원래의 해시 값이 a비트 내에서 최대한 값이 겹치지 않고 구별되게 한다.
	h ^= (h >>> 20) ^ (h >>> 12);
	return h ^ (h >>> 7) ^ (h >>> 4);
}
```
그런데 Java 8에서는 Java 7보다 훨씬 더 단순한 형태의 보조 해시 함수를 사용한다.
```java
static final int hash(Object key) {
	int h;
	return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
위 예제에서 볼 수 있는 것처럼, Java 8 HashMap 보조 해시 함수는 상위 16비트 값을 XOR 연산하는 매우 단순한 형태의 보조 해시 함수를 사용한다.
이유로는 두 가지가 있는데,
첫 번째는 Java 8에서는 해시 충돌이 많이 발생하면 **LinkedList 대신 Tree를 사용하므로 해시 충돌 시 발생할 수 있는 성능 문제가 완화되었기 때문**이다.
두 번째로는 **최근의 해시 함수는 균등 분포가 잘 되게 만들어지는 경향이 많아, Java 7까지 사용했던 보조 해시 함수의 효과가 크지 않기 때문**이다. 두 번째 이유가 좀 더 결정적인 원인이 되어 Java 8에서는 보조 해시 함수의 구현을 바꾸었다.

개념상 해시 버킷 인덱스를 계산할 때에는 index = X.hashCode() % M처럼 나머지 연산을 사용하는 것이 맞지만, M값이 2a일 때는 해시 함수의 하위 a비트 만을 취한 것과 값이 같다. 따라서 **나머지 연산 대신 '1 << a – 1' 와 비트 논리곱(AND, &) 연산을 사용하면 수행이 훨씬 더 빠르다**.
## Rate Limiting

Rate Limiting이란 특정 시간 내에 할 수 있는 API 호출 수를 의미한다. 사용자의 API 호출 수가 Rate Limit 값을 초과하면 API 호출이 제한되며 요쳥이 실패하게 된다. 즉, 단어 그대로 API의 속도를 제한한다. Rate Limiter를 적용하면 고가용성과 안정성을 보장할 수 있다.

### Why use it?

#### Protection against DDos
Distributed Denial of Service(DDos)는 악의적인 의도를 가진 사용자에 의해 대량의 패킷 또는 대량의 요청을 보내 대상 시스템을 마비시키는 공격이다. DDos 공격으로 인해 시스템이 마비되면 해당 시스템뿐만 아니라, 영향 범위가 같은 서버와 연결된 DB까지 미친다.
이 공격은 패킷이나 요청의 크기가 서버가 감당할 수 없게 만들어 CPU 사용량을 급증시키기 때문이다.

#### Server Stability and Consistency
서버 안정성을 보장하고 서버를 유지하는데 용이하다. 최대 호출 수를 제한하기 때문에 총 호출에 대한 예상이 가능하며, 서버에 무리가 가지 않는 선으로 제한 기준을 정하기 때문에 서버의 안정적인 관리가 가능하다.

#### Cost Control
요청이나 응답, 혹은 프로세스 중 리소스 사용량이 많은 경우를 따져보았을 때, 해당 요청에 금액적인 부담이 커질 수 있다. 가령, 대용량 파일 업로드 기능에 무작위로 들어오는 요청들을 떠올려 볼 수 있다. 서비스 운영 비용 관리는 비즈니스의 가장 큰 비중을 두기 대문에 결코 무시할 수 없으며, Rate Limit을 설정함으로써 비용에 대한 예상을 하고 비용을 절감할 수 있다.

## Algorithm

### Token Bucket
- 요청마다 토큰을 소비하여 bucket안의 토큰이 모두 소진되면 요청 제한

Token Bucket 알고리즘은 Bucket안에 Token을 담아두고, 요청이 들어올 때 토큰의 수를 하나씩 감소하여 더 이상 사용할 토큰이 없을 때 요청을 제한한다.
![[Pasted image 20250901220507.png]]만약 1분에 5개의 요청을 받겠다고 설정해보자. 처음에는 Bucket에 Token이 3개 들어있고, 첫 요청이 들어오면 2개로 바뀌고 또 하나가 더 들어온다면 1개로 줄어든다. 1분 내에 3개의 요청이 들어와서 토큰이 0개가 되면 다음 refill할 시기(다음 1분)까지 요청을 받아들이지 않는다.

이 알고리즘은 메모리 효율적이지만, 분산 환경에서 동시에 들어오는 요청에 대해 Race Condition이 발생할 수 있다는 문제가 있다.

### Leaky Bucket
- FIFO 형식의 Bucket(Queue)에 요청을 차례로 담아 크기가 다 차면 요청 제한

Leaky Bucket은 단어에서 느껴지듯이 Bucket에 요청을 담고, 가득 차면 더 담지 못하여 새어 나간다(Leaky)는 개념을 가진다.
Leaky Bucket 알고리즘의 예시로 1분에 3개의 요청을 받는다고 가정해보자.
![[Pasted image 20250901220740.png]]이 때 Bucket들은 Queue라고 생각하면 된다. 인입되는 요청을 FIFO 형식으로 처리한다.
인입되는 요청은 순서대로 큐에 추가되고 그 크기만큼 요청을 받을 수 있다. 현재 2개의 Bucket으로 가정했기 때문에 두 번째까지 요청들이 큐에 순서대로 쌓인다. 만약 1분이 지나지 않은 상태에서 3개 이상의 요청이 들어오면 이후 요청들은 버려지게(spilled out)된다. 만약 1분 내에 6개의 요청이 왔다고 한다면 Bucket은 모두 담지 못할 것이다(Burst). 3개의 요청은 Bucket에 담고 나머지 3개의 요청을 버린다. 이 상태에서 1분이 지나면 가장 먼저 들어온 요청을 버리고(Leaky) 7번째 요청을 Bucket에 담는다.

### Fixed Window Counter

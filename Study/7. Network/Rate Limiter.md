## Rate Limiting

Rate Limiting이란 특정 시간 내에 할 수 있는 API 호출 수를 의미한다. 사용자의 API 호출 수가 Rate Limit 값을 초과하면 API 호출이 제한되며 요쳥이 실패하게 된다. 즉, 단어 그대로 API의 속도를 제한한다. Rate Limiter를 적용하면 고가용성과 안정성을 보장할 수 있다.

### Why use it?

#### Protection against DDos
Distributed Denial of Service(DDos)는 악의적인 의도를 가진 사용자에 의해 대량의 패킷 또는 대량의 요청을 보내 대상 시스템을 마비시키는 공격이다. DDos 공격으로 인해 시스템이 마비되면 해당 시스템뿐만 아니라, 영향 범위가 같은 서버와 연결된 DB까지 미친다.
이 공격은 패킷이나 요청의 크기가 서버가 감당할 수 없게 만들어 CPU 사용량을 급증시키기 때문이다.

#### Server Stability and Consistency
서버 안정성을 보장하고 서버를 유지하는데 용이하다. 최대 호출 수를 제한하기 때문에 총 호출에 대한 예상이 가능하며, 서버에 무리가 가지 않는 선으로 제한 기준을 정하기 때문에 서버의 안정적인 관리가 가능하다.

#### Cost Control
요청이나 응답, 혹은 프로세스 중 리소스 사용량이 많은 경우를 따져보았을 때, 해당 요청에 금액적인 부담이 커질 수 있다. 가령, 대용량 파일 업로드 기능에 무작위로 들어오는 요청들을 떠올려 볼 수 있다. 서비스 운영 비용 관리는 비즈니스의 가장 큰 비중을 두기 대문에 결코 무시할 수 없으며, Rate Limit을 설정함으로써 비용에 대한 예상을 하고 비용을 절감할 수 있다.

## Algorithm

### Token Bucket
- 요청마다 토큰을 소비하여 bucket안의 토큰이 모두 소진되면 요청 제한

Token Bucket 알고리즘은 Bucket안에 Token을 담아두고, 요청이 들어올 때 토큰의 수를 하나씩 감소하여 더 이상 사용할 토큰이 없을 때 요청을 제한한다.
![[Pasted image 20250901220507.png]]만약 1분에 5개의 요청을 받겠다고 설정해보자. 처음에는 Bucket에 Token이 3개 들어있고, 첫 요청이 들어오면 2개로 바뀌고 또 하나가 더 들어온다면 1개로 줄어든다. 1분 내에 3개의 요청이 들어와서 토큰이 0개가 되면 다음 refill할 시기(다음 1분)까지 요청을 받아들이지 않는다.

이 알고리즘은 메모리 효율적이지만, 분산 환경에서 동시에 들어오는 요청에 대해 Race Condition이 발생할 수 있다는 문제가 있다.

### Leaky Bucket
- FIFO 형식의 Bucket(Queue)에 요청을 차례로 담아 크기가 다 차면 요청 제한

Leaky Bucket은 단어에서 느껴지듯이 Bucket에 요청을 담고, 가득 차면 더 담지 못하여 새어 나간다(Leaky)는 개념을 가진다.
Leaky Bucket 알고리즘의 예시로 1분에 3개의 요청을 받는다고 가정해보자.
![[Pasted image 20250901220740.png]]이 때 Bucket들은 Queue라고 생각하면 된다. 인입되는 요청을 FIFO 형식으로 처리한다.
인입되는 요청은 순서대로 큐에 추가되고 그 크기만큼 요청을 받을 수 있다. 현재 2개의 Bucket으로 가정했기 때문에 두 번째까지 요청들이 큐에 순서대로 쌓인다. 만약 1분이 지나지 않은 상태에서 3개 이상의 요청이 들어오면 이후 요청들은 버려지게(spilled out)된다. 만약 1분 내에 6개의 요청이 왔다고 한다면 Bucket은 모두 담지 못할 것이다(Burst). 3개의 요청은 Bucket에 담고 나머지 3개의 요청을 버린다. 이 상태에서 1분이 지나면 가장 먼저 들어온 요청을 버리고(Leaky) 7번째 요청을 Bucket에 담는다.

### Fixed Window Counter
- 고정된 크기 내에 일정 요청 개수만을 허용

Fixed Window 기술은 굉장히 간단하다. 고정된 크기 내에 일정 요청 개수만을 허용하는 규칙을 지정한다.
예를 들어 특정 API에 15분 동안 5개의 요청 만을 받는다고 지정해두고, 15분 동안 5개의 요청을 받고나서 해당 API의 접근을 차단시키는 것이다. 이 때 10분 동안의 요청 Window Size를 5로 지정한다고 말할 수 있더.
Twitter API에서 실제 예시를 확인해 볼 수 있다.
![[Pasted image 20250901222530.png]]
위 그림에서 볼 수 있듯이, 15분을 기준으로 각 제공 API의 요청 횟수를 제한한 것을 확인할 수 있다.
앱(Per App)과 유저(Per User)에 따라 따로 명시하지 않는 한 15분 간격으로(Requests per 15-minute window unless otherwise stated) 조회, 작성, 삭제 등의 호출 제한을 지정했으며, API 마다 설정할 요청 횟수를 예상하고 제각각 다르게 설정한 것을 확인할 수 있다.

![[Pasted image 20250901222940.png]]하지만 이 방법은 **특정 간격 사이에서 부하**가 올 가능성이 있다.
1분에 5개의 요청을 받는다고 가정해보자. 만약 11:00:00에서 11:01:00로 넘어갈 때를 생각해보자. 11:00:58초에 5개의 요청이 들어오고 11:01:02에 5개의 요청이 들어왔을 때와 같이 4초 안에 10개의 요청이 들어올 수 있다. 굉장히 편향된 시간에 요청이 들어올 수 있다는 것이다.

### Sliding Logs
- 모든 요청을 타임스탬프로 기록하고 현재 시점을 기준으로 시간 범위 내의 요청 개수에 따라 요청 제한.

모든 요청은 인입된 타임스탬프로 저장된다. 로그를 이용한 슬라이딩 윈도우는 모든 요청을 타임스탬프로 기록하고 현재 시점을 기준으로 윈도우 크기 만큼의 시분초 전의 요청 시간을 확인해서 그 개수를 확인한다.
가령 1분에 10개의 요청을 받는다고 가정해보자. 현재 시간이 10:30:30일 때 1분을 기준으로 판별하기 때문에 슬라이딩 윈도우로 판별할 크기는 10:29:30부터 10:30:30의 크기를 가진다. 이 때 로그는 요청자 명을 key로 설정하고 타임스탬프를 value로 갖는 쌍의 형태로, 원하는 key-value 자료구조로 자유롭게 사용할 수 있다.
![[Pasted image 20250901223301.png]]이 시간 범위의 요청을 확인할 대 만약 2개의 요청이 있다면 앞으로 3개의 요청을 더 받아들일 수 있다.
만약 5개 이후에 요청이 더 들어온다면 그 이후의 요청을 막는다. 하지만 이런 방법은 **유저별로 로깅해야 하기 때문에 상당한 메모리를 소비해야 한다**.

### Sliding Window Counter
- Fixed Window + Sliding Log, 타임스탬프를 모두 저장하지 않고 카운터를 세어 요청 개수에 따라 요청 제한

Fixed Window의 단점인 경계값 부하를 Sliding Log와 같이 범위를 조금씩 움직이는 시간 단위로 측정하고, Sliding Log의 단점인 메모리 소비를 줄이게끔 만든 알고리즘이다.
Fixed Window와 동일하게 각 고정된 윈도우마다 Counter가 존재하며, 타임스탬프를 기준으로 카운팅되는 요청 수를 집계해 이전 윈도우와의 가중치를 고려하여 요청을 제한하는 형식이다.
![[Pasted image 20250901223635.png]]
가령, 1분 당 10건을 처리한다고 가정해보자. 동시에, 11시 정각과 11시 1분 사이에는 9건, 11시 1분과 2분 사이에는 5건의 요청이 들어온다고 가정한다.
이 때, 11:01:15에 요청이 인입된다. 그럼 해당 시점에 요청을 받을지 말지 판별해야 하는데, 11:01:00 ~ 11:01:15 사이의 요청은 시간 범위로 따졌을 때 25%의 지점이며, 그 이전의 시간인 11:00:00 ~ 11:01:00 사이에서의 비중은 75%(1-25%)가 된다.

요청 제한을 위해서 다음과 같은 계산을 진행한다.
$$9 \times 0.75 + 5 = 14.75 $$이고 10건의 제한을 넘었기 때문에 11:01:15에 들어온 요청은 거부된다.
마찬가지로  11:01:30에 요청이 인입되면 $$ 9 \times 0.5 + 5 = 9.5 $$로 계산할 수 있다.


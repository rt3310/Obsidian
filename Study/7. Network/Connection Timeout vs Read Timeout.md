## RTT, RTO
먼저 다음 용어를 숙지하고 넘어가자.

### RTT
Round Trip Time의 줄임말로 **패킷이 목적지에 도달하고 나서 해당 패킷에 대한 응답이 출발지로 다시 돌아오기까지의 시간**이다. 물리적으로 먼 거리와 통신하려고 한다면 RTT도 커진다.

네트워크 성능을 측정하기 위한 지표로도 사용된다.

### RTO
Retransmission Timeout의 줄임말로, **재전송 타임아웃 시간**이다. **RTO를 넘은 시간에도 응답이 오지 않으면 재전송을 하기 위해 설정하는 시간**이다.

**RTO는 RTT를 기반으로 설정된다**. 두 노드 간에 패킷이 전달되는 시간들을 보고 재전송 타임아웃을 설정하는 것이다.

### InitRTO
하지만, 첫 통신에 응답을 받지 못하면 RTT를 알 수 없기 때문에 RTO를 설정할 수 없다. 따라서 InitRTO라는 초기 RTO 값이 존재한다. **리눅스에는 기본값으로 1초가 지정되어 있다**.

중요한 점은, InitRTO는 **실패할 때마다 값이 2의 제곱으로 증가한다**는 점이다.
#### Exponential Backoff
$2^0$ → $2^1$ → $2^2$ → $2^3$ → $2^4$

retry를 빨리 하지 않는 이유는 요청하는 측의 서버에 문제가 있을 수 있으니까, 바로 요청해도 똑같은 문제를 겪을 것이기 때문에 바로 보내지 않는 것이다.

### 최소 RTO
RTO는 최솟값을 가지고 있다. **리눅스에서 최솟값은 200ms**로 설정되어 있다.
**RTT를 통해서 RTO를 도출한 값이 200ms보다 작아도 RTO는 200ms가 된다**.

## Connection Timeout

Connection Timeout은 종단 간 연결하는데 소요되는 최대 시간을 의미한다. 이 시간을 넘기게 되면 연결할 수 없는 것으로 판단하고 에러가 발생한다.
즉, Connection이라는 단어가 의미하는 것처럼 종단 간 연결에 사용되는 타임아웃으로, 이 때의 연결이란 우리가 잘 알고 있는 TCP 3 way handshake를 통해 TCP 연결이 생성되는 것을 의미한다.

## Read Timeout

Read Timeout은 연결된 종단 간에 데이터를 주고 받을 때 소요되는 최대 시간을 의미한다. 이 시간을 넘기게 되면 데이터를 받을 수 없는 것으로 판단하고 에러가 발생한다.
즉, Read라는 단어가 의미하는 것처럼 연결되어 있는 종단 간 데이터를 주고 받을 때 사용되는 타임아웃이다.


Rest API 클라이언트의 경우라면 TCP 통신 과정에서 Connection Timeout과 Read Timeout이 적용되는 구간은 아래와 그림과 같다.
![[Pasted image 20251209111505.png]]
그렇다면 두 타임아웃의 값은 어떻게 설정하는 게 좋을까?

## 타임아웃 설정을 위한 기준 정하기

타임아웃 값을 설정하기에 앞서 기준을 정해야 한다. 그리고 그 기준은 아래 두 가지 조건을 만족시키도록 설정될 수 있다.
- 네트워크 상에서 패킷 유실은 꼭 장애 상황이 아니더라도 언제든 발생할 수 있다.
- 네트워크 상에서 문제가 발생했다면 가능한 빨리 인지해야 한다.

위 두 가지 조건을 바탕으로 적당한 값을 찾아야 한다.

네트워크는 항상 100% 완벽하게 동작하지 않는다. 요즘에는 기술이 좋아져서 비교적 덜 하겠지만 패킷 유실이라는 것은 언제든 발생할 수 있다는 것을 유념해 두어야 한다.

실제로 네트워크 장애가 발생했다면 가급적 빨리 발견해서 필요한 조치를 할 수 있어야 한다.
만약 타임아웃 값을 너무 짧게 둔다면 간헐적으로 발생할 수 있는 패킷 유실에 대해 너무 민감하게 반응하게 되고, 타임아웃 값을 너무 길게 둔다면 네트워크 장애를 발견하는 데 긴 시간이 소요되게 된다.

### Connection Timeout 값
Connection Timeout은 TCP 3 way handshake 시 발생할 수 있는 연결 지연이기 때문에 연결을 맺는 과정에서 발생할 수 있는 패킷 유실에 대해 생각해 봐야 한다.

고려해 볼 수 있는 경우의 수는 세 가지 이다.
- SYN 패킷이 유실되었을 때
- SYN + ACK 패킷이 유실되었을 때
- 마지막 ACK 패킷이 유실되었을 때

먼저 A와 B가 연결을 맺기 위해 보낸 SYN 패킷이 유실되었다고 가정해보자.
![[Pasted image 20251209112507.png]]
A는 B로부터 SYN+ACK를 받을 준비를 하고 있는데 SYN 패킷이 유실되어 B에게 도착하지 않았기 때문에 B는 SYN+ACK를 보낼 수 없다. 따라서 A는 자신이 보낸 SYN 패킷이 유실되었다고 판단하고 다시 보내게 된다. 그리고 이 때 사용되는 재전송을 판단하기 위한 타임아웃을 **InitRTO** 라고 부른다.

패킷의 유실 여부를 판단하는 타임아웃 값을 RTO라고 부르는데, RTO는 두 종단 간의 RTT(Round Trip Time)을 기준으로 생성된다. 즉, 패킷이 두 종단 간을 흘러가는 데 물리적인 시간이 필요하기 때문에 그 값을 기반으로 RTO를 계산해낸다.

두 종단 간에 패킷이 흐르는 데 100ms가 필요하다면, 보내는데 100ms 받는데 100ms 합쳐서 최소한 200ms가 소요되기 때문에 200ms 이상은 기다려야 패킷이 유실되었는지 여부를 알 수 있다. 하지만 방금 본 예제처럼 연결을 최초에 맺는 경우에는 종단 간 RTT 값을 알 수 없기 때문에 무조건 이 만큼은 기다려보자라는 설정 값이 필요하고 이 값이 바로 InitRTO이다.
이 값은 리눅스 상에서는 1초로 하드코딩 되어있다. 따라서 SYN 패킷이 한 번 유실된다면 최소한 연결을 맺는데 1초 이상의 시간이 소요된다.


다음으로 SYN+ACK가 유실되었을 때를 생각해보자.
![[Pasted image 20251209112529.png]]
이 경우도 SYN이 유실되었을 때와 동일한 시나리오로 흘러간다.
SYN 패킷이 B에게 정상적으로 도착했고, 이에 따라 B가 A에게 SYN+ACK 패킷을 전달했지만 중간에서 SYN+ACK 패킷이 유실되었다.

SYN+ACK 패킷이 유실되었음을 알 수 없는 A는 당연히 SYN이 유실되었다고 판단하고 1초 후에 다시 한번 SYN을 보내게 된다. 그래서 원인은 다르지만 실질적으로 동작하는 방식은 SYN 패킷이 유실되었을 때랑 동일하다.


그럼 마지막으로 ACK 패킷이 유실되었을 때를 생각해보자.
![[Pasted image 20251209112725.png]]ACK 패킷 유실의 경우는 앞의 두 경우와는 조금 다르다. 왜냐하면 SYN와 SYN+ACK 패킷을 서로 주고 받으면서 A와 B는 이제 둘 사이의 RTT를 알게 되었기 때문이다.

ACK 패킷 부터는 InitRTO의 적용을 받지 않고 RTT를 기반으로 계산된 RTO를 적용받는다. 그리고 RTO의 기본값은 RTT를 기반으로 계산된 복잡한 값(이 값이 200ms보다 작다면 200ms)이 적용된다.
따라서 ACK의 유실에 의한 재전송은 최소 200ms가 소요된다. 대부분의 경우 1초를 넘기지 않을 것이다.

### Read Timeout 값
Read Timeout은 Connection Timeout에 비해 좀 더 짧게 가져가게 된다.
Read Timeout에 영향을 주는 패킷 재전송을 위한 타임아웃 값인 RTO가 RTT를 기준으로 만들어져서 보통 1초보다 짧기 때문이다.
![[Pasted image 20251209113309.png]]
RTO의 최소값은 200ms이기 때문에 Read Timeout 역시 한 번의 패킷 유실을 고려해서 200ms보다는 크게 잡는다. 하지만 Read Timeout의 요소들이 있는데, 바로 **RTT**와 받은 쪽에서 요청을 처리하기 위해 소요되는 **프로세싱 타임**이다.

종단 간 RTT가 10ms이고 요청을 처리하는 데 소요되는 시간이 300ms라고 가정해보자. 그렇다면 A와 B가 통신하기 위해 필요한 최소한의 시간은 310ms가 된다. 여기에 한 번의 패킷 유실이 발생한다고 생각하면 어떻게 될까?
![[Pasted image 20251209113447.png]]
위 그림과 같이 B가 A로부터 요청을 받고 요청을 처리하는 데 소요된 시간 300ms와 B가 A에게 보낸 패킷이 유실되었음을 인지하고 재전송에 소요되는 시간(RTO) 200ms가 필요하다. 여기에 두 패킷이 서로 간에 도착하기 위해 필요한 최소한의 시간인 RTT도 염두에 두어야 한다.
그래서 한 번의 패킷 유실로 인해 310ms 안에 처리할 수 있는 요청이 510ms가 소요된다. 이렇게 Read Timeout은 RTO 외에 RTT와 프로세싱 시간까지 고려해서 설정해야 한다.
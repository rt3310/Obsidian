- 프로그램 수행에 필요한 블록(페이지)만 적재하므로, 비사용 블록 적재로 인한 낭비절감 -> **요구 페이징(demand paging)**
- **블록(페이지) 적재 요구가 얼마나 빈번한지**가 가상메모리 실용성의 최대 관건
	- 프로세스 수행 시간 중 임의의 짧은 구간을 관찰했을 떄 **메모리 참조 행태가 너무 분산되지 않아야 하며**, **한 번 주기억장치에 적재된 블록들이 내보내지기 전까지 최대한 많이 참조되도록** 관리해야 한다.
	- 시스템이 안정상태에 있을 경우 주기억장치 전체가 각 프로세스의 블록들로 채워지며, 이 때 주기억장치에 적재되지 않은 블록이 참조되면 이미 적재된 블록을 교체해야 한다 (교체 대상을 잘못 선정할 경우 바로 재적재해야 하는 상황이 발생한다).
	- 결론적으로 **쓰레싱**(thrashing: 시스템이 프로세스 수행보다 블록 교체에 대부분의 시간을 소비하게 되는 현상) 방지가 관건이다.

- **성긴(sparse) 주소공간의 활용**
	- 스택은 위에서 아래로, 힙은 아래에서 위로 할당
	- 중간의 공백도 가상 주소 공간의 일부
	- 이들 공백은 스택이나 힙이 확장되어야만 실제 물리 페이지를 요구하게 된다.
	- 가상 메모리에서 공백은 실제 메모리가 할당되지 않는다.
- **공유 라이브러리(shared library)**
	- 라이브러리를 여러 프로세스가 공유
	- 데이터용 공유 메모리(shared memory)
	- Fork() 시 자식 프로세스의 빠른 생성이 가능
		- 복사가 아니고 페이지들을 공유
- **쓰기 시 복사(Copy-on-write)**
	- 초기에는 부모, 자식 프로세스가 페이지들을 공유
	- 공유된 페이지의 내용을 변경 시에만 해당 페이지를 복사하여 새로운 페이지를 만들고 해당 프로세스의 페이지 테이블을 갱신
- **메모리 사상 파일(Memory-mapped File)**
	- 디스크의 파일을 메모리에 사상(mapping)을 시키고, 메모리에 접근하듯이 파일을 사용 -> 파일 접근과 사용을 단순화 -> read(), write() 호출 없이 파일 데이터 사용
	- mmap() 시스템 호출로 기능을 제공
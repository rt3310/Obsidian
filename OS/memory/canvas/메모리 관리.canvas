{
	"nodes":[
		{"id":"28bd8edc5be1a8f5","type":"file","file":"OS/memory/md/메모리 관리.md","x":-339,"y":-220,"width":694,"height":218},
		{"id":"dd1f4e279a11de73","type":"text","text":"주기억장치 = 운영체제 + 수행 중인 프로그램을 위한 공간","x":-229,"y":-360,"width":473,"height":29},
		{"id":"3c23aea662b6ad82","type":"text","text":"- 연속 메모리 관리\n- 불연속 메모리 관리","x":596,"y":-143,"width":237,"height":64},
		{"id":"438184394c8f8582","type":"text","text":"> [!INFO]\n> 메모리 집약과는 다르게 이동은 하지 않고 단지 연속된 빈 공간들을 모아서 더 큰 공간을 만드는 것을 **통합(garbage collection)**이라고 한다.","x":2133,"y":-143,"width":592,"height":154,"color":"#0000ff"},
		{"id":"8f8ced8f0d5f3b65","type":"file","file":"OS/memory/canvas/메모리 집약 vs 메모리 통합.md","x":2913,"y":-176,"width":715,"height":220},
		{"id":"5981179a0fc035f7","type":"file","file":"OS/memory/canvas/동적 분할.md","x":2135,"y":-564,"width":588,"height":280},
		{"id":"8c2fec2be65feb97","type":"file","file":"OS/memory/canvas/배치 알고리즘.md","x":2935,"y":-578,"width":660,"height":309},
		{"id":"d194936f7b285366","type":"file","file":"OS/memory/canvas/균등 분할.md","x":2935,"y":-1202,"width":440,"height":188},
		{"id":"93a919bfb6b2da49","type":"file","file":"OS/memory/canvas/비균등 분할.md","x":2935,"y":-860,"width":424,"height":218},
		{"id":"57fb5db33a6670c1","type":"text","text":"- 프로그램이 파티션보다 클 경우 -> overlay 기법 필요\n- 주기억장치 이용률 저조\n- 내부단편화 발생","x":3555,"y":-1156,"width":471,"height":96},
		{"id":"41cc81e78b95570c","type":"text","text":"- 파티션 수에 의해 활성화 된 프로세스 수 제한\n- 크기가 작은 작업일수록 파티션 공간을 비효율적으로 사용\n- 내부 단편화 발생","x":3535,"y":-799,"width":511,"height":96},
		{"id":"5c44bdeee23d5cdd","type":"file","file":"OS/memory/canvas/연속 메모리 관리.md","x":1280,"y":-794,"width":701,"height":220},
		{"id":"32ae751b00adf2f0","type":"file","file":"OS/memory/canvas/버디(Buddy) 시스템.md","x":1329,"y":-1118,"width":603,"height":181},
		{"id":"354f49708636790a","type":"file","file":"OS/memory/canvas/고정 분할.md","x":2135,"y":-1014,"width":677,"height":154},
		{"id":"3863cd4d62ed4c8c","type":"file","file":"OS/memory/canvas/단편화(Fragmentation).md","x":413,"y":-794,"width":604,"height":253},
		{"id":"918a071ee1e6c80c","type":"text","text":"- 재배치(Relocation)\n- 보호(Protection)\n- 공유(Sharing)\n- 논리적 구성(Logical organization)\n- 물리적 구성(Physical organization)","x":-1028,"y":-192,"width":343,"height":163},
		{"id":"26f7aeefe02b2574","type":"file","file":"OS/memory/canvas/재배치(Relocation).md","x":-1274,"y":-722,"width":589,"height":119},
		{"id":"f1185f216a15c7e5","type":"text","text":"- 논리 주소\n\t- 데이터가 적재된 메모리와는 독립적인 위치에 대한 참조로 접근전에 물리주소로 변환 필요\n\t- 처리기, 운영체제가 관리 (ex: 가상 메모리)\n- 상대 주소\n\t- 처리기의 레지스터 값으로부터 떨어진 주소\n- 물리 주소(절대 주소)\n\t- 주기억장치 내의 실제 주소","x":-880,"y":-1139,"width":458,"height":259},
		{"id":"9cc049e80f0f7ea7","type":"text","text":"- 적재 시 베이스(시작 주소)/경계 레지스터 사용\n- 실행 시 처리기는 '베이스 + 상대 주소'를 사용\n\t- 경계 범위 밖이면 인터럽트 발생(보호)","x":-1540,"y":-1057,"width":426,"height":96},
		{"id":"f5cf05458f2eb94e","type":"file","file":"OS/memory/canvas/보호(Protection).md","x":-1967,"y":-756,"width":640,"height":187},
		{"id":"024e43ba5b21e256","type":"file","file":"OS/memory/canvas/공유(Sharing).md","x":-2160,"y":-204,"width":688,"height":188},
		{"id":"4f0553220394ab9a","type":"file","file":"OS/memory/canvas/물리적인 구성.md","x":-1271,"y":360,"width":620,"height":220},
		{"id":"a084a1b10be6ef6b","type":"text","text":"- 모듈의 작성과 컴파일이 독립적으로 이루어진다.\n- 비교적 적은 추가비용으로 모듈마다 서로 다른 보호 등급을 적용할 수 있다.\n- 프로세스 간 모듈 공유 기법을 제공한다.","x":-2045,"y":622,"width":641,"height":96},
		{"id":"b81205c4aa37ebe5","type":"file","file":"OS/memory/canvas/논리적인 구성.md","x":-1978,"y":300,"width":506,"height":121},
		{"id":"c67247f8582359cc","type":"file","file":"OS/memory/canvas/불연속 메모리 관리.md","x":1280,"y":232,"width":604,"height":238},
		{"id":"f71eaa91927a4198","x":2083,"y":259,"width":640,"height":184,"type":"file","file":"OS/memory/canvas/페이징.md"},
		{"id":"ab819c9cb4fec40d","x":2992,"y":270,"width":557,"height":163,"type":"text","text":"- 외부 단편화 발생 안함 -> 프로세스가 하나가 아니라 쪼개져 있다\n- 내부 단편화\n\t- 각 프로세스의 마지막 페이지에서만 발생 (프레임 = 페이지)\n- 단순 페이징\n\t- 고정 분할 방법과 유사"},
		{"id":"e4368f9ce9ae6ba8","x":2083,"y":44,"width":452,"height":153,"type":"text","text":"- 페이지(age)"}
	],
	"edges":[
		{"id":"5b612337588bbd15","fromNode":"28bd8edc5be1a8f5","fromSide":"left","toNode":"918a071ee1e6c80c","toSide":"right","label":"요구조건"},
		{"id":"08221c19f3dc00cf","fromNode":"28bd8edc5be1a8f5","fromSide":"top","toNode":"dd1f4e279a11de73","toSide":"bottom","label":"주기억장치"},
		{"id":"e6e95f0774b00a86","fromNode":"918a071ee1e6c80c","fromSide":"top","toNode":"26f7aeefe02b2574","toSide":"bottom","label":"재배치"},
		{"id":"af4944b77e88c036","fromNode":"918a071ee1e6c80c","fromSide":"top","toNode":"f5cf05458f2eb94e","toSide":"bottom","label":"보호"},
		{"id":"f0d02403fa6b2941","fromNode":"918a071ee1e6c80c","fromSide":"left","toNode":"024e43ba5b21e256","toSide":"right","label":"공유"},
		{"id":"6fbbce06524a65a2","fromNode":"918a071ee1e6c80c","fromSide":"bottom","toNode":"b81205c4aa37ebe5","toSide":"top","label":"논리적인 구성"},
		{"id":"174c9d74f56ab696","fromNode":"b81205c4aa37ebe5","fromSide":"bottom","toNode":"a084a1b10be6ef6b","toSide":"top","label":"운영체제 및 하드웨어의 모듈 단위 처리 시 이점"},
		{"id":"9c859b0cd23abd1e","fromNode":"918a071ee1e6c80c","fromSide":"bottom","toNode":"4f0553220394ab9a","toSide":"top","label":"물리적인 구성"},
		{"id":"a6c99e5e40ff7044","fromNode":"28bd8edc5be1a8f5","fromSide":"right","toNode":"3c23aea662b6ad82","toSide":"left","label":"메모리 분할"},
		{"id":"a3d5db0f5f424bc8","fromNode":"3c23aea662b6ad82","fromSide":"right","toNode":"5c44bdeee23d5cdd","toSide":"left","label":"연속 메모리 관리"},
		{"id":"50fd57a29bf14bac","fromNode":"3c23aea662b6ad82","fromSide":"right","toNode":"c67247f8582359cc","toSide":"left","label":"불연속 메모리 관리"},
		{"id":"91eb92e61ee6ee3a","fromNode":"3c23aea662b6ad82","fromSide":"top","toNode":"3863cd4d62ed4c8c","toSide":"bottom","label":"메모리 분할 문제"},
		{"id":"92a01e0804d6fbaf","fromNode":"5c44bdeee23d5cdd","fromSide":"right","toNode":"354f49708636790a","toSide":"left","label":"고정 분할"},
		{"id":"53369e16e234f705","fromNode":"354f49708636790a","fromSide":"right","toNode":"d194936f7b285366","toSide":"left","label":"균등 분할"},
		{"id":"6f0440bed1f4e6ac","fromNode":"354f49708636790a","fromSide":"right","toNode":"93a919bfb6b2da49","toSide":"left","label":"비균등 분할"},
		{"id":"4f57927e3d86e84f","fromNode":"d194936f7b285366","fromSide":"right","toNode":"57fb5db33a6670c1","toSide":"left","label":"문제점"},
		{"id":"5ac4b2606555cf32","fromNode":"93a919bfb6b2da49","fromSide":"right","toNode":"41cc81e78b95570c","toSide":"left","label":"문제점"},
		{"id":"55b1e50c4b9cf159","fromNode":"5c44bdeee23d5cdd","fromSide":"right","toNode":"5981179a0fc035f7","toSide":"left","label":"동적 분할"},
		{"id":"a3eaebc20f67dcba","fromNode":"5981179a0fc035f7","fromSide":"bottom","toNode":"438184394c8f8582","toSide":"top"},
		{"id":"3655825484c400b6","fromNode":"438184394c8f8582","fromSide":"right","toNode":"8f8ced8f0d5f3b65","toSide":"left","label":"집약 vs 통합"},
		{"id":"b076ba55c7283ba0","fromNode":"5981179a0fc035f7","fromSide":"right","toNode":"8c2fec2be65feb97","toSide":"left","label":"배치 알고리즘"},
		{"id":"04962aac36be70ea","fromNode":"5c44bdeee23d5cdd","fromSide":"top","toNode":"32ae751b00adf2f0","toSide":"bottom","label":"버디 시스템"},
		{"id":"4db093fc15f1fd3f","fromNode":"26f7aeefe02b2574","fromSide":"top","toNode":"f1185f216a15c7e5","toSide":"bottom","label":"재배치 지원 시 사용되는 주소 유형"},
		{"id":"6cd77ded24cd036e","fromNode":"26f7aeefe02b2574","fromSide":"top","toNode":"9cc049e80f0f7ea7","toSide":"bottom","label":"처리기에 의한 재배치"},
		{"id":"67fc894c04784fe1","fromNode":"c67247f8582359cc","fromSide":"right","toNode":"f71eaa91927a4198","toSide":"left"},
		{"id":"8d6c3312ed436bf1","fromNode":"f71eaa91927a4198","fromSide":"right","toNode":"ab819c9cb4fec40d","toSide":"left","label":"장점"},
		{"id":"ac97079c2f1b3d2e","fromNode":"f71eaa91927a4198","fromSide":"top","toNode":"e4368f9ce9ae6ba8","toSide":"bottom"}
	]
}
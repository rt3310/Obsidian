index = X.hashCode() % M을 계산할 때 사용하는 M 값은 **소수일 때 index 값 분포가 가장 균등할 수 있다**. 그러나 M 값이 소수가 아니기 때문에 별도의 보조 해시 함수를 이용하여 index 값 분포가 가급적 균등할 수 있도록 해야 한다.

보조 해시 함수(supplement hash function)의 목적은 **'키'의 해시 값을 변형하여, 해시 충돌 가능성을 줄이는 것**이다. 이 보조 해시 함수는 JDK 1.4에 처음 등장했다. Java 5 ~ Java 7은 같은 방식의 보조 해시 함수를 사용하고, **Java 8부터는 다시 새로운 방식의 보조 해시 함수를 사용**하고 있다.

Java 7 HashMap에서의 보조 해시 함수
```java
final int hash(Object k) {
	// Java 7부터는 JRE를 실행할 때, 데이터 개수가 일정 이상이면 String 객체에 대해서 JVM에서 제공하는 별도의 옵션으로 해시 함수를 사용하도록 할 수 있다.
	// 만약 이 옵션을 사용하지 않으면 hashSeed의 값은 0이다.
	int h = hashSeed;
	if (0 != h && k instanceof String) {
		return sun.misc.Hashing.stringHash32((String) k);
	}
	h ^= k.hashCode();
	// 해시 버킷의 개수가 2a이기 때문에 해시 값의 a비트 값만을 해시 버킷의 인덱스로 사용한다.
	// 따라서 상위 비트의 값이 해시 버킷의 인덱스 값을 결정할 때 반영될 수 있도록 shift 연산과 XOR 연산을 사용하여, 원래의 해시 값이 a비트 내에서 최대한 값이 겹치지 않고 구별되게 한다.
	h ^= (h >>> 20) ^ (h >>> 12);
	return h ^ (h >>> 7) ^ (h >>> 4);
}
```
그런데 Java 8에서는 Java 7보다 훨씬 더 단순한 형태의 보조 해시 함수를 사용한다.
```java
static final int hash(Object key) {
	int h;
	return (key == null) ? 0 : (h = key.hash)
}
```
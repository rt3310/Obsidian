{
	"nodes":[
		{"id":"f4a31f64ebf099f5","x":2442,"y":1200,"width":678,"height":1220,"type":"file","file":"Java/HashMap/canvas/Java 8 HashMap에서의 Separate Chaning.md"},
		{"id":"2a7a1b3281fd1480","type":"file","file":"Java/HashMap/canvas/HashMap vs HashTable.md","x":-260,"y":-120,"width":740,"height":490},
		{"id":"be4544eef9902c1f","type":"file","file":"Java/HashMap/canvas/해시 분포.md","x":638,"y":-38,"width":584,"height":688},
		{"id":"60c0d83b025e0fa1","type":"file","file":"Java/HashMap/canvas/해시 충돌.md","x":1400,"y":-250,"width":633,"height":1112},
		{"id":"94ea83d7cb4bbf47","type":"text","text":"Java HashMap에서 사용하는 방식은 Separate Channing이다.\nOpen Addressing은 데이터를 삭제할 때 처리가 효율적이기 어려운데, HashMap에서 remove() 메서드는 매우 빈번하게 호출될 수 있기 때문이다.\n게다가 HashMap에 저장된 키-값 쌍 개수가 일정 개수 이상으로 많아지면, 일반적으로 Open Addressing은 Separate Chaining보다 느리다. Open Addressing의 경우 해시 버킷을 채운 밀도가 높아질수록 Worst Case 발생 빈도가 더 높아지기 때문이다. 반면 Separate Chaining 방식의 경우 해시 충돌이 잘 발생하지 않도록 '조정'할 수 있다면 Worst Case 또는 Worst Case에 가까운 일이 발생하는 것을 줄일 수 있다.\n\n```java\ntransient Entry<K, V>[] table = (Entry<K, V>[]) EMPTY_TABLE;\n\nstatic class Entry<K, V> implements Map.Entry<K, V> {\n\tfianl K key;\n\tV value;\n\tEntry<K, V> next;\n\tint hash;\n\n\tEntry(int h, K k, V v, Entry<K, V> n) {\n\t\tvalue = v;\n\t\tnext = n;\n\t\tkey = k;\n\t\thash = h;\n\t}\n\n\tpublic final K getKey() { ... }\n\tpublic final V getValue() { ... }\n\tpublic final V setValue(V newValue) { ... }\n\tpublic final boolean equals(Object o) { ... }\n\tpublic final int hashCode() { ... }\n\tpublic final String toString() { ... }\n\n\tvoid recordAccess(HashMap<K, V> m) { ... }\n\tvoid recordRemoval(HashMap<K, V> m) { ... }\n}\n```\n\nSeparate Chaining 방식을 사용하기 때문에, Java 7에서의 put() 메서드 구현은 다음 예제에서 보는 것과 같다.\n```java\npublic V put(K key, V value) {\n\tif (table == EMPTY_TABLE) {\n\t\tinflateTable(threshold); // table 배열 생성\n\t}\n\t// HashMap에서는 null을 키로 사용할 수 있다.\n\tif (key == null)\n\t\treturn putForNullKey(value); // value.hashCode() 메서드를 사용하는 것이 아니라, 보조 해시 함수를 이용하여 변형된 해시 함수를 사용한다.\n\n\t// i 값이 해시 버킷의 인덱스이다.\n\t// indexFor() 메서드는 hash % table.length와 같은 의도의 메서드다.\n\tint i = indexFor(hash, table.length);\n\n\t// 해시 버킷에 있는 LinkedList를 순회한다.\n\t// 만약 같은 키가 이미 저장되어 있다면 교체한다.\n\tfor (Entry<K, V> e = table[i]; e != null; e = e.next) {\n\t\tObject k;\n\t\tif (e.hash == hash && ((k == e.key) == key || key.equals(k))) {\n\t\t\tV oldValue = e.value;\n\t\t\te.value = value;\n\t\t\te.recordAccess(this);\n\t\t\treturn oldValue;\n\t\t}\n\t}\n\n\t// 삽입, 삭제 등으로 이 HashMap 객체가 몇 번이나 변경되었는지 관리하기 위한 코드다.\n\t// ConcurrentModificationException을 발생시켜야 하는지 판단할 때 사용한다.\n\tmodCount++;\n\n\t// 아직 해당 키-값 쌍 데이터가 삽입된 적이 없다면 새로 Entry를 생성한다.\n\taddEntry(hash, key, value, i);\n\treturn null;\n}\n```","x":1345,"y":1040,"width":744,"height":1582}
	],
	"edges":[
		{"id":"f2e5993fcf00241a","fromNode":"2a7a1b3281fd1480","fromSide":"right","toNode":"be4544eef9902c1f","toSide":"left"},
		{"id":"90b35b2135cfab1b","fromNode":"be4544eef9902c1f","fromSide":"right","toNode":"60c0d83b025e0fa1","toSide":"left"},
		{"id":"10e58c5d6d5ae74d","fromNode":"60c0d83b025e0fa1","fromSide":"bottom","toNode":"94ea83d7cb4bbf47","toSide":"top","label":"자바에서는?"},
		{"id":"144c845717619e3b","fromNode":"94ea83d7cb4bbf47","fromSide":"right","toNode":"f4a31f64ebf099f5","toSide":"left"}
	]
}
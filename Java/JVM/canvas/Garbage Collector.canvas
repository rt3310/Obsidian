{
	"nodes":[
		{"id":"118349ead357f16c","type":"text","text":"가비지 컬렉션(Garbage Collection, GC)은 자바의 메모리 관리 방법 중 하나로 **JVM의 Heap 영역에서 동적으로 할당했던 메모리 중 필요 없게 된 메모리 객체(garbage)를 모아 주기적으로 제거하는 프로세스**를 말한다.","x":460,"y":-397,"width":754,"height":58},
		{"id":"6ceb7188b6505ed9","type":"text","text":"# Garbage Collector","x":-161,"y":-388,"width":305,"height":41},
		{"id":"1e0368a6ba106e7e","type":"file","file":"Java/JVM/G1 GC.md","x":-960,"y":3560,"width":720,"height":962},
		{"id":"288ad78baa324a23","type":"text","text":"```bash\njava -XX:+UseG1GC -jar Application.java\n```","x":-765,"y":4680,"width":331,"height":45},
		{"id":"531468359f520a87","type":"text","text":"C / C++ 에서는 이러한 가비지 컬렉션이 없어 프로그래머가 수동으로 메모리 할당과 해제를 일일이 해줘야 했었다.\n하지만 Java에서는 가비지 컬렉터가 메모리 관리를 대행해주기 때문에 Java 프로세스가 한정된 메모리를 효율적으로 사용할 수 있게 하고, **개발자 입장에서 메모리 관리, 메모리 누수(Memory Leak) 문제에 대해 관리하지 않아도 되어 개발에 집중할 수 있다는 장점**이 있다.","x":-172,"y":-825,"width":632,"height":148},
		{"id":"69cdcbccc610b342","type":"text","text":"자동으로 처리해준다 해도 메모리가 언제 해제되는지 정확하게 알 수 없어 제어하기 힘들며, **가비지 컬렉션(GC)이 동작하는 동안에는 다른 동작을 멈추기 때문에 오버헤드가 발생되는 문제점**이 있다.\n\n이를 전문적인 용어로 **Stop-The-World**라 한다.\n\n이로 인해 **GC가 너무 자주 실행되면 소프트웨어 성능 하락의 문제**가 되기도 한다.\n예를 들면, IE는 이 가비지 컬렉션을 너무 자주 실행하여 성능 문제를 일으키는 것으로 악명이 높았다.\n\n이런 특성에 따라 실시간 성이 매우 강조되는 프로그램일 경우 GC에게 메모리를 맡기는 것은 맞지 않을 수 있다.\n따라서 애플리케이션 사용성을 유지하면서 효율적이게 GC를 실행하는 최적화 작업이 개발자의 숙제가 된다\n이러한 GC 최적화 작업을 **GC 튜닝**이라고 한다.","x":600,"y":-969,"width":757,"height":292},
		{"id":"8881f9c1ea063717","type":"file","file":"Java/JVM/STW(Stop The World).md","x":1733,"y":-897,"width":569,"height":145},
		{"id":"70970824d92d8855","type":"file","file":"Java/JVM/resources/Stop The World.png","x":1821,"y":-1520,"width":382,"height":400},
		{"id":"1b5caf9a31100229","type":"text","text":"가비지 컬렉션은 특정 객체가 garbage인지 아닌지 판단하기 위해서 도달성, 도달능력(Reachability)이라는 개념을 적용한다.\n객체에 레퍼런스가 있다면 Reachable로 구분되고, 객체에 유효한 레퍼런스가 없다면 Unreachable로 구분하고 수거해버린다.\n1. **Reachable**: 객체가 참조되고 있는 상태\n2. **Unreachable**: 객체가 참조되고 있지 않은 상태 (GC 대상이 됨)\n\n예를 들어, JVM 메모리에서는 객체들은 실질적으로 힙 영역에서 생성되고 메소드 영역이나 스택 영역에서는 영역에 생성된 객체의 주소만 참조하는 형식으로 구성된다.\n하지만 이렇게 생성된 힙 영역의 객체들이 메소드가 끝나는 등의 특정 이벤트들로 인하여 **힙 영역 객체의 메모리 주소를 가지고 있는 참조 변수가 삭제되는 현상이 발생하면, 힙 영역에서 어디서든 참조하고 있지 않은 객체(Unreachable)들이 발생**한다.\n이러한 객체들을 주기적으로 가비지 컬렉터가 제거해주는 것이다.","x":1821,"y":-556,"width":589,"height":377},
		{"id":"45e3b0d99d0b9709","type":"file","file":"Java/JVM/resources/Unreachable Object.png","x":2600,"y":-478,"width":513,"height":221},
		{"id":"0a057899f7e06bde","type":"file","file":"Java/JVM/Mark And Sweep.md","x":985,"y":-167,"width":600,"height":1020},
		{"id":"82c370f33ddb3268","type":"file","file":"Java/JVM/GC의 Root Space.md","x":1821,"y":72,"width":941,"height":543,"color":"5"},
		{"id":"f6aa0f44654132ed","type":"text","text":"1. 객체의 age가 임계값(여기선 8로 설정)에 도달하게 되면,\n   ![[major gc 1.png]]\n2. 이 객체들은 Old Generation으로 이동된다. 이를 **promotion**이라 부른다.\n   ![[major gc 2.png]]\n3. 위 과정이 반복되어 Old Generation 영역의 공간(메모리)가 부족하게 되면 Major GC가 발생하게 된다.\n   ![[major gc 3.gif]]","x":2109,"y":2118,"width":680,"height":660},
		{"id":"952469617b567d2a","type":"text","text":"![[가비지 컬렉션 동작 과정.png]]","x":-92,"y":-104,"width":972,"height":719},
		{"id":"0f96237946786ba0","type":"text","text":" JVM의 힙(heap) 영역은 동적으로 레퍼런스 데이터가 저장되는 공간으로서, 가비지 컬렉션에 대상이 되는 공간이다.\n\nHeap 영역은 처음 설계될 때 다음 2가지를 전제(Weak Generational Hypothesis)로 설계되었다.\n- 대부분의 객체는 금방 접근 불가능한 상태(Unreachable)가 된다.\n- 오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다.\n\n즉, **객체는 대부분 일회성되며, 메모리에 오랫동안 남아있는 경우는 드물다**는 것이다.\n\n이러한 특성을 이용해 JVM 개발자들은 보다 효율적인 메모리 관리를 위해, 객체의 생존 기간에 따라 물리적인 Heap 영역을 나누게 되었고 **Young과 Old 총 2가지 영역**으로 설계하였다. (초기에는 Perm 영역도 존재하였지만 Java 8부터 제거되었다)\n\n![[JVM 힙 영역.png]]\n\n![[힙 영역 상세 2.png]]\n이렇게 하나의 힙 영역을 세부적으로 쪼갬으로서 객체의 생존 기간을 면밀하게 제어하여 GC를 보다 정확하게 불필요한 객체를 제거하는 프로세스를 실행하도록 한다.","x":-97,"y":858,"width":934,"height":1018},
		{"id":"d9c683ba6bbf53b2","type":"file","file":"Java/JVM/Young 영역(Young Generation).md","x":1203,"y":1011,"width":765,"height":205},
		{"id":"4ba13ee733bc919c","type":"file","file":"Java/JVM/Old 영역(Old Generation).md","x":1203,"y":1540,"width":665,"height":171},
		{"id":"c335cc0f2dd93c55","type":"file","file":"Java/JVM/Eden.md","x":2265,"y":773,"width":534,"height":121},
		{"id":"91393fa34fe0896b","type":"file","file":"Java/JVM/Survivor 0, Survivor 1.md","x":2265,"y":1033,"width":423,"height":151},
		{"id":"85a09b6f7a90f43d","type":"file","file":"Java/JVM/Minor GC.md","x":2265,"y":1262,"width":649,"height":556},
		{"id":"f441caa1dc637730","type":"file","file":"Java/JVM/Major GC.md","x":1215,"y":1940,"width":641,"height":510},
		{"id":"c5eb38208cce15b2","type":"text","text":"Major GC는 Old 영역의 데이터가 가득 차면 GC를 실행하는 단순한 방식이다.\n\nOld 영역에 할당된 메모리가 허용치를 넘게 되면, Old 영역에 있는 모든 객체들을 검사하여 참조되지 않는 객체들을 한꺼번에 삭제하는 Major GC가 실행되게 된다.\n하지만 **Old Generation은 Young Generation에 비해 상대적으로 큰 공간을 가지고 있어, 이 공간에서 메모리 상의 객체 제거에 많은 시간이 걸리게 된다**.\n\n예를 들어, Young 영역은 일반적으로 Old 영역보다 크기가 작기 때문에 GC가 보통 0.5초에서 1초 사이에 끝난다.\n그렇기 때문에 Minor GC는 애플리케이션에 크게 영향을 주지 않는다.\n하지만 Old 영역의 **Major GC는 일반적으로 Minor GC보다 시간이 오래걸리며, 10배 이상의 시간을 사용**한다.\n\n바로 여기서 **Stop-The-World** 문제가 발생하게 된다.\n**Major GC가 일어나면 Thread가 멈추고 Mark and Sweep 작업을 해야 해서 CPU에 부하를 주기 때문에 멈추거나 버벅이는 현상이 일어나기 때문**이다.\n따라서 자바 개발진들은 끊임 없이 가비지 컬렉션 알고리즘을 발전 시켜왔다.","x":1156,"y":2640,"width":759,"height":388},
		{"id":"d9fdc6c7e5e864cd","type":"file","file":"Java/JVM/Minor GC 과정.md","x":3200,"y":24,"width":580,"height":2477},
		{"id":"629ec080149af24a","type":"file","file":"Java/JVM/age 값.md","x":4040,"y":927,"width":905,"height":335,"color":"5"},
		{"id":"73e8cd2dc87531e2","type":"file","file":"Java/JVM/Permanent.md","x":-1400,"y":615,"width":933,"height":593,"color":"5"},
		{"id":"4d831604295edca7","type":"text","text":"> [!INFO]\n> Old 영역이 Young 영역보다 크게 할당되는 이유는 Young 영역의 수명이 짧은 객체들은 큰 공간을 필요로 하지 않으며 큰 객체들은 Young 영역이 아니라 바로 Old 영역에 할당되기 때문이다.","x":-1120,"y":343,"width":693,"height":154,"color":"5"},
		{"id":"2babe5149a409fef","type":"file","file":"Java/JVM/CMS GC.md","x":-1840,"y":3143,"width":720,"height":637},
		{"id":"36c555f8c06b5ad5","type":"text","text":"```bash\njava -XX:+UseConcMarkSweepGC -jar Application.java\n```","x":-2591,"y":3535,"width":420,"height":50},
		{"id":"c6dcf1c2923caecf","type":"text","text":"자바가 발전됨에 따라 Heap의 사이즈가 커지면서 애플리케이션의 지연(Suspend) 현상이 두드러지게 되었고, 이를 최적화 위해 다양한 Garbage Collection(가비지 컬렉션) 알고리즘이 개발되었다.\n\n![[가비지 컬렉션 알고리즘 종류.png]]\n- Serial GC\n- Parallel GC\n- CMS GC\n- G1 GC\n- Shenandoah GC\n- ZGC","x":-240,"y":2460,"width":680,"height":693},
		{"id":"943f775efc3be0da","type":"file","file":"Java/JVM/Serial GC.md","x":-1400,"y":1367,"width":720,"height":955},
		{"id":"b97b8f73ba95e15d","type":"text","text":"- 자바 프로그램을 실행할 때 `-XX:+UseSerialGC` GC 옵션을 지정하여 해당 가비지 컬렉션 알고리즘으로 힙 메모리를 관리하도록 실행할 수 있다.\n```bash\njava -XX:+UseSerialGC -jar Application.java\n```","x":-2348,"y":1781,"width":538,"height":128},
		{"id":"b746fed2b9fe60f4","type":"file","file":"Java/JVM/Parallel GC.md","x":-1400,"y":2400,"width":720,"height":574},
		{"id":"3d62e7f4fcc3f8ad","type":"text","text":"- GC 스레드는 기본적으로 cpu 개수만큼 할당된다.\n- 옵션을 통해 GC를 수행할 쓰레드의 개수 등을 설정해줄 수 있다.\n```bash\njava -XX:+UseParallelGC - jar Application.java\n```\n- `-XX:ParallelGCThreads=N`: 사용할 스레드의 개수","x":-2323,"y":2138,"width":489,"height":184},
		{"id":"95beea70802f32f7","type":"text","text":"- Parallel GC를 개선한 버전\n- Young 영역 뿐만 아니라, Old 영역에서도 멀티스레드로 GC 수행\n- 새로운 가비지 컬렉션 청소 방식인 Mark-Summary-Compact 방식을 이용 (Old 영역도 멀티스레드로 처리)\n![[Parallel Compacting Collector.png]]","x":-2689,"y":2460,"width":733,"height":637},
		{"id":"8381dc318175fabe","type":"text","text":"```bash\njava -XX:+UseParallelOldGC -jar Application.java\n```\n- `-XX:ParallelGCThreads=N`: 사용할 스레드의 개수","x":-2520,"y":3364,"width":395,"height":98},
		{"id":"691a6bdfddd8f8c6","type":"file","file":"Java/JVM/G1 GC의 효율성.md","x":-2171,"y":3994,"width":904,"height":359,"color":"5"},
		{"id":"67bc1c16843b636d","type":"file","file":"Java/JVM/ZGC.md","x":1332,"y":3462,"width":933,"height":807},
		{"id":"44c9aa4333ac0f9b","type":"text","text":"```bash\njava -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -jar Application.java\n```","x":1519,"y":4477,"width":560,"height":45},
		{"id":"84a73595c4c4c115","type":"text","text":"최근 Java 8에서 JVM 메모리 구조적인 개선 사항으로 Perm 영역이 Metaspace 영역으로 전환되고 기존 Perm 영역을 사라지게 되었다.\nMetaspace 영역은 Heap이 아닌 **Native 메모리 영역으로 취급**하게 된다.\n(Heap 영역은 JVM에 의해 관리된 영역이며, **Native 메모리는 OS 레벨에서 관리하는 영역**으로 구분된다)\nMetaspace가 Native 메모리를 이용함으로서 개발자는 영역 확보의 상한을 크게 의식할 필요가 없어지게 되었다.","x":-2400,"y":838,"width":760,"height":148},
		{"id":"c363ba9d5a80ae53","type":"file","file":"Java/JVM/Shenandoah GC.md","x":-145,"y":3680,"width":1360,"height":540},
		{"id":"19c7eeaa383ba015","type":"text","text":"```bash\njava -XX:+UseShenandoahGC -jar Application.java\n```","x":340,"y":4360,"width":390,"height":45}
	],
	"edges":[
		{"id":"5c1b1ca3881906d8","fromNode":"6ceb7188b6505ed9","fromSide":"right","toNode":"118349ead357f16c","toSide":"left","label":"가비지 컬렉션?"},
		{"id":"d3864b27bd2d6b23","fromNode":"118349ead357f16c","fromSide":"top","toNode":"531468359f520a87","toSide":"bottom","label":"장점"},
		{"id":"79eab14df4680378","fromNode":"118349ead357f16c","fromSide":"top","toNode":"69cdcbccc610b342","toSide":"bottom","label":"단점"},
		{"id":"e60606ddb28f6ab7","fromNode":"69cdcbccc610b342","fromSide":"right","toNode":"8881f9c1ea063717","toSide":"left","label":"Stop The World?"},
		{"id":"e58a4b2e55f2b9fe","fromNode":"8881f9c1ea063717","fromSide":"top","toNode":"70970824d92d8855","toSide":"bottom"},
		{"id":"bdc8587f5c243fdb","fromNode":"118349ead357f16c","fromSide":"right","toNode":"1b5caf9a31100229","toSide":"left","label":"가비지 컬렉션 대상은 어떻게?"},
		{"id":"9e1667d8d4bae125","fromNode":"118349ead357f16c","fromSide":"bottom","toNode":"0a057899f7e06bde","toSide":"top","label":"가비지 컬렉션 방식은?"},
		{"id":"7c49d5f67e09972e","fromNode":"0a057899f7e06bde","fromSide":"right","toNode":"82c370f33ddb3268","toSide":"left"},
		{"id":"c8a375b2e38bea18","fromNode":"1b5caf9a31100229","fromSide":"right","toNode":"45e3b0d99d0b9709","toSide":"left"},
		{"id":"061a7a369a299768","fromNode":"118349ead357f16c","fromSide":"bottom","toNode":"952469617b567d2a","toSide":"top"},
		{"id":"a6fe89f441fa607b","fromNode":"952469617b567d2a","fromSide":"bottom","toNode":"0f96237946786ba0","toSide":"top","label":"힙 영역"},
		{"id":"060ad270327dba8c","fromNode":"0f96237946786ba0","fromSide":"right","toNode":"d9c683ba6bbf53b2","toSide":"left","label":"Young 영역?"},
		{"id":"140dbaf3982df51e","fromNode":"0f96237946786ba0","fromSide":"right","toNode":"4ba13ee733bc919c","toSide":"left","label":"Old 영역?"},
		{"id":"4df5b745b316d537","fromNode":"0f96237946786ba0","fromSide":"left","toNode":"4d831604295edca7","toSide":"right"},
		{"id":"80f543514ec3dbfe","fromNode":"0f96237946786ba0","fromSide":"left","toNode":"73e8cd2dc87531e2","toSide":"right"},
		{"id":"9e12a6d16db79d2b","fromNode":"d9c683ba6bbf53b2","fromSide":"right","toNode":"c335cc0f2dd93c55","toSide":"left","label":"Eden?"},
		{"id":"0444b17b487f2f77","fromNode":"d9c683ba6bbf53b2","fromSide":"right","toNode":"91393fa34fe0896b","toSide":"left","label":"survivor 0, 1?"},
		{"id":"fc48c685f52b68af","fromNode":"d9c683ba6bbf53b2","fromSide":"right","toNode":"85a09b6f7a90f43d","toSide":"left","label":"Minor GC?"},
		{"id":"e1cbfdf4efb46e63","fromNode":"85a09b6f7a90f43d","fromSide":"right","toNode":"d9fdc6c7e5e864cd","toSide":"left","label":"Minor GC 과정"},
		{"id":"55ef82ab932dce87","fromNode":"d9fdc6c7e5e864cd","fromSide":"right","toNode":"629ec080149af24a","toSide":"left","label":"age 값?"},
		{"id":"2789b7146464dda2","fromNode":"4ba13ee733bc919c","fromSide":"bottom","toNode":"f441caa1dc637730","toSide":"top","label":"Major GC?"},
		{"id":"6bc08ce22c532cab","fromNode":"f441caa1dc637730","fromSide":"right","toNode":"f6aa0f44654132ed","toSide":"left","label":"Major GC 과정"},
		{"id":"ff813f88cd867a53","fromNode":"f441caa1dc637730","fromSide":"bottom","toNode":"c5eb38208cce15b2","toSide":"top","label":"Major GC의 성능 문제"},
		{"id":"61dec93d0969b044","fromNode":"c5eb38208cce15b2","fromSide":"left","toNode":"c6dcf1c2923caecf","toSide":"right","label":"가비지 컬렉션 알고리즘 종류"},
		{"id":"6b80e61879c81d10","fromNode":"c6dcf1c2923caecf","fromSide":"top","toNode":"943f775efc3be0da","toSide":"right","label":"Serial GC?"},
		{"id":"f94864ab7e6a8ddb","fromNode":"c6dcf1c2923caecf","fromSide":"left","toNode":"b746fed2b9fe60f4","toSide":"right","label":"Parallel GC?"},
		{"id":"cff32c96f7313c82","fromNode":"943f775efc3be0da","fromSide":"left","toNode":"b97b8f73ba95e15d","toSide":"right","label":"Serial GC 실행 명령어"},
		{"id":"15d088ccbca7e136","fromNode":"b746fed2b9fe60f4","fromSide":"left","toNode":"3d62e7f4fcc3f8ad","toSide":"right","label":"Parallel GC 실행 명령어"},
		{"id":"21f01d786e900d0f","fromNode":"b746fed2b9fe60f4","fromSide":"left","toNode":"95beea70802f32f7","toSide":"right","label":"Parallel Old GC\n(Parallel Compacting Collector)"},
		{"id":"fc8f5b0ec5764088","fromNode":"95beea70802f32f7","fromSide":"bottom","toNode":"8381dc318175fabe","toSide":"top","label":"Parallel Old GC 실행 명령어"},
		{"id":"a55fc6826f842837","fromNode":"c6dcf1c2923caecf","fromSide":"left","toNode":"2babe5149a409fef","toSide":"right","label":"CMS GC?\n(Concurrent Mark Sweep)"},
		{"id":"0a29dc7e7076eedc","fromNode":"2babe5149a409fef","fromSide":"left","toNode":"36c555f8c06b5ad5","toSide":"right","label":"CMS GC 실행 명령어"},
		{"id":"8e45aef69dd3d912","fromNode":"c6dcf1c2923caecf","fromSide":"bottom","toNode":"1e0368a6ba106e7e","toSide":"top","label":"G1 GC?"},
		{"id":"ad62e73eea4867a3","fromNode":"1e0368a6ba106e7e","fromSide":"left","toNode":"691a6bdfddd8f8c6","toSide":"right","label":"G1 GC의 효율성"},
		{"id":"3f415916eb18f224","fromNode":"1e0368a6ba106e7e","fromSide":"bottom","toNode":"288ad78baa324a23","toSide":"top","label":"G1 GC 실행 명령어"},
		{"id":"96fae91c2986b33c","fromNode":"c6dcf1c2923caecf","fromSide":"bottom","toNode":"c363ba9d5a80ae53","toSide":"top","label":"Shenandoah GC?"},
		{"id":"154efe99d82636a9","fromNode":"c363ba9d5a80ae53","fromSide":"bottom","toNode":"19c7eeaa383ba015","toSide":"top","label":"Shenandoah GC 실행 명령어"},
		{"id":"e766dd58dbb1273a","fromNode":"c6dcf1c2923caecf","fromSide":"bottom","toNode":"67bc1c16843b636d","toSide":"top","label":"ZGC?"},
		{"id":"57cdd0ba3b56c7a5","fromNode":"67bc1c16843b636d","fromSide":"bottom","toNode":"44c9aa4333ac0f9b","toSide":"top","label":"ZGC 실행 명령어"},
		{"id":"d654fcb8b79c59e1","fromNode":"73e8cd2dc87531e2","fromSide":"left","toNode":"84a73595c4c4c115","toSide":"right","label":"왜 제거되었는가?"}
	]
}
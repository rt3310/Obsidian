{
	"nodes":[
		{"id":"38d1d9b9473c6055","x":-174,"y":-113,"width":637,"height":118,"type":"text","text":"기존의 전통적인 Java 스레드에 더하여 새롭게 추가되는 경량 스레드이다. `Project Loom`의 결과물로 추가된 기능으로 OS 스레드를 그대로 사용하지 않고 JVM 자체적으로 내부 스케줄링을 통해서 사용할 수 있는 경량의 스레드를 제공한다.\n하나의 Java 프로세스가 수십만 ~ 수백만개의 스레드를 동시에 실행할 수 있게끔 설계되었다."},
		{"id":"64f9b9ea9c4f8bd2","x":-168,"y":180,"width":626,"height":147,"type":"text","text":"Project Loom이란 경량의 스레드를 Java의 추가하기 위해서 가상 스레드를 비롯한 여러가지 기능들을 개발하는 프로젝트로 Loom이란 단어는 Thread의 사전적 정의가 **실**이라는데 착안하여 실을 엮어 **직물을 만든다는 뜻**이다.\nLoom 프로젝트의 결과로 탄생한 Virtual Thread도 처음에는 Fiber-섬유 라고하는 별도의 기능으로 개발되었으나, 최종적으로는 기존 스레드 문법과 호환될 수 있는 형태로 발전했다."},
		{"id":"fcdada5a85d39101","x":780,"y":-784,"width":800,"height":1111,"type":"text","text":"#### 자바의 스레드는 OS의 스레드를 기반으로 한다.\n- 자바의 전통적인 스레드는 OS 스레드를 wrapping 한 것으로 이를 **플랫폼 스레드**라고 정의한다.\n- 따라서 Java Application에서 스레드를 사용하는 코드는 실제적으로는 OS 스레드를 이용하는 방식으로 동작했다. \n- OS 커널에서 사용할 수 있는 스레드는 개수가 제한적이고 생성과 유지 비용이 비싸다.\n- 이 때문에 기존에 애플리케이션들은 비싼 자원인 플랫폼 스레드를 효율적으로 사용하기 위해서 **스레드 풀(Thread Pool)**을 만들어서 사용해왔다.\n#### 처리량(throughput)의 한계\n- Spring Boot와 같은 애플리케이션의 기본적인 사용자 요청 처리 방식은 **Thread Per Request**이다. 이는 하나의 request(요청)을 처리하기 위해서 하나의 스레드를 사용한다.\n- 애플리케이션에서 처리량을 늘리려면 스레드를 늘려야 하지만 스레드를 무한정 늘릴 수 없다. (OS 스레드를 무한정 늘릴 수 없기 때문\n- 따라서 애플리케이션의 처리량(throughput)은 **스레드 풀**에서 감당할 수 있는 범위를 넘어서 늘어날 수 없다.\n#### Blocking으로 인한 리소스 낭비\n- **Thread Per Request** 모델에서는 요청을 처리하는 스레드에서 I/O 작업을 처리할 때 **Blocking**이 일어난다.\n- 이 때문에 스레드는 I/O 작업이 마칠 때까지 다른 요청을 처리하지 못하고 기다려야 한다. (Blocking 동안 대기)\n- 애플리케이션이 유입되는 요청이 많지 않거나 또는 스케일 아웃으로 충분히 커버할 수 있는 정도라면 문제가 없지만, 아주 많은 요청을 처리해야하는 상황이라면 **Blocking 방식으로 인해 발생하는 낭비를 줄여야 할 필요가 있다**.\n- 이 때문에 Blocking이 아니라 **Non-Blocking** 방식의 **Reactive Programming**이 발전하였다.\n#### Reactive Programming의 단점\n- 처리량을 높이기 위한 방법으로 비동기 방식의 Reactive 프로그래밍이 발전해왔다.\n- 한정된 자원인 플랫폼 스레드가 Blocking 되면서 대기하는 데 소요된 스레드 자원을 Non-Blocking 방식으로 변경하면서 다른 요청을 처리하는 데 사용할 수 있게 되었다.\n- 대표적으로 Webflux가 이렇게 Non-Blocking으로 동작한다.\n- 다만 이런 Reactive 코드는 작성하고 이해하는 비용을 높게 만들었다. (Mono, Flux)\n- 또한 기존의 자바 프로그래밍의 패러다임은 스레드를 기반으로 하기 때문에 라이브러리들 모두 Reactive 방식에 맞게 새롭게 작성해야 하는 문제가 있다.\n#### 자바 플랫폼의 디자인\n- 자바 플랫폼은 전통적으로 **스레드를 중심**으로 구성되어 있었다.\n- 스레드 호출 스택은 Thread Local을 사용하여 데이터와 컨텍스트를 연결하도록 설계되어 있다.\n- 이 외에도 Exception, Debugger, Profile(JFR)이 모둔 스레드를 기반으로 하고 있다.\n- Reactive 스타일로 코드를 작성하면 사용자의 요청이 스레드를 넘나들면서 처리되는데, 이 때문에 컨텍스트 확인이 어려워져 결국 디버깅이 힘들어졌다."},
		{"id":"13582db3306434c4","x":-580,"y":-72,"width":187,"height":39,"type":"text","text":"# 가상 스레드"},
		{"id":"1ae24fd0cf409247","x":-205,"y":-940,"width":700,"height":694,"type":"text","text":"Project Loom의 결과로 탄생한 가상 스레드는 다음과 같은 목적으로 가지고 있는데, 기존의 Reactive Programming과 비교해서 생각해보자.\n\n#### 해결하고자 하는 문제\n1. Java 개발자가 하드웨어의 성능을 잘 활용하는 높은 처리량(throughput)의 서버를 작성하는 것\n\t1. 가상 스레드는 Blocking이 발생하면 내부적으로 스케줄링을 활용하여 플랫폼 스레드가 그냥 대기하게 두지 않고 다른 가상 스레드가 작업할 수 있도록 한다.\n\t2. 따라서 Reactive Programming의 Non-blocking과 동일하게 플랫폼 스레드의 리소스를 낭비하지 않는다.\n2. 동시에 Java 플랫폼의 디자인과 조화를 이루는 코드를 생성할 수 있도록 하는 것\n\t1. 기존 Reactive Programming의 장점에도 불구하고 전통적인 Java 언어의 구조는 스레드를 기반으로 하였기 때문에 Webflux 등을 사용할 때 디버깅, 성능 테스트가 어려웠다.\n\t2. 하지만 가상 스레드는 기존 스레드 구조를 그대로 사용하기 때문에 디버깅, 프로파일링 등 기존의 도구도 그대로 사용할 수 있다.\n#### Reactive Programming 과의 비교\n- Reactive Programming이 달성하고자 하는, 리소스를 효율적으로 사용하여 높은 처리량을 감당하려는 목적은 동일하다.\n- 가상 스레드를 사용하면 Non-blocking에 대한 처리를 JVM 레벨에서 담당해준다.\n- 따라서 Spring Web MVC 스타일로 코드를 작성하더라고 내부에서 가상 스레드가 기존의 플랫폼 스레드를 직접 사용하는 방식보다 효율적으로 스케줄링하여 처리량을 높일 수 있다.\n- 결론적으로 가상 스레드는 기존 스레드 방식의 이점을 누리면서도 Reactive Programming의 장점을 취할 수 잇다."}
	],
	"edges":[
		{"id":"4ca44f4b7aa79f2c","fromNode":"13582db3306434c4","fromSide":"right","toNode":"38d1d9b9473c6055","toSide":"left","label":"가상 스레드?"},
		{"id":"7830d41e7ce55a05","fromNode":"38d1d9b9473c6055","fromSide":"bottom","toNode":"64f9b9ea9c4f8bd2","toSide":"top","label":"Loom Project?"},
		{"id":"fc291d0b1b110c32","fromNode":"38d1d9b9473c6055","fromSide":"right","toNode":"fcdada5a85d39101","toSide":"left","label":"나오게 된 배경"},
		{"id":"a9180f986e940cbf","fromNode":"38d1d9b9473c6055","fromSide":"top","toNode":"1ae24fd0cf409247","toSide":"bottom"}
	]
}
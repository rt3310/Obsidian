## 캐시 종류

- 로컬캐시 (EHcache)
- DB 내부 캐시
- CDN
- 웹캐시
- in-memory 캐시 (redis, memcached)

## 캐시 비교

### 로컬 캐시
##### 장점
- 타 서버간 통신 비용이 발생하지 않는다.
- 서버 인스턴스 메모리 저장하기 때문에 가져오는데 속도가 빠르다.
##### 단점
- 서버가 여러 대로 클러스터링 되어 있는 경우, 동기화가 되지 않는다.
- 캐시 데이터가 커질수록 서버 메모리가 부족해지며 이에 따라 애플리케이션 성능이 저하될 수 있다.

### Redis
데이터 영속성을 지원하는 In-memory 저장소 (스냅샷 기능을 통해 Disk에 캐시데이터를 저장할 수 있기 때문)
##### 장점
- 서버 복제 지원, Master-slave 구조로 여러 대의 복제본을 만들 수 있다.
- 트랜잭션 지원
- 여러 데이터 자료형 지원(문자열, 숫자, boolean 등)
##### 단점
- 싱글스레드로 동작하기 때문에 병목현상이 발생할 수 있다.
- 로컬 캐시에 비해 서버 ↔︎ redis 간 통신 비용이 발생한다.

### 웹 캐시
웹 사용자에 의해 빈번히 요청되는 데이터를 우베캐시 서버(Nginx 등)에 보관함으로써 응답한다.
- Client - Nginx proxy server - Server 구조 일 때, 요청이 nginx 서버에 캐시되어 있다면 실제 요청은 Server에 전달되지 않고 Client에게 반환된다.
##### 장점
- 요청이 실제 서버로 넘어가지 않기 때문에 부하 자체를 줄여줄 수 있다.
##### 단점
- 별도의 웹캐시용의 서버 구성 필요
- Client에서 Server로 요청하는 과정에 Proxy 서버가 중간에 끼게 되는 형태인데, 통신 과정이 늘어나니까 당연히 소요시간이 길어질 수 있다.

## 로컬 캐시 비교

[[Ehcache vs Caffeine]]

## 캐시를 사용하기 적절한 데이터인지 판단하는 기준

- 데이터가 변경에 민감한지?
- 데이터의 연산에 드는 비용이 비싼지?
- 데이터의 변경이 전파가 되는지?

요약하자면, “**잘 바뀌지 않으면서 접근할 일이 많은 데이터**, 변경되더라도 다른 서비스에 큰 영향을 미치지 않는 데이터” 가 캐시에 저장하여 활용하기 적절하다.

## 어느정도 레벨의 동기화가 필요할까?

캐시 구현에 따라 다르다. DB는  acid를 지켜야 되지만 보통 오픈소스 인메모리 캐시는 dirty read를 무시하고 요청 시점에 데이터의 상태만 반환한다. 만약 transaction이 필요하다면 다른 솔루션을 도입해야 하고 데이터 정합성에 민감한 금융권은 레디스 사용을 권장하지 않는다.

## 캐시가 유실되면?

캐시서버가 날라가면 트래픽이 DB로 몰린다. 보통 캐시가 죽었을 때 DB에 부하가 몰려 죽는 경우도 많이 발생한다. 캐시가 죽더라도 DB가 버틸 수 있도록 구축이 필요하다.
thundering herd issue라고 자주 참조되는 캐시 키 하나가 없어지더라도 DB에 부하가 몰려 줄을 수도 있다.
그래서 계층형 구조로 구성하는 곳도 있다. 예를 들면 트위터는 1차, 2차, 3차 디스크 형태로 구성한다. 이는 돈이 많이 필요함으로 파레토의 법칙을 적용해서 구성해야 한다.
- 파레토의 법칙: 80%의 서비스는 20%의 데이터로 운영된다.

## 캐시 사용으로 인한 다양한 이슈

- Look-Aside cachine으로 인한 race condition 발생 가능.
	- 값이 없을 때 원본 데이터를 DB에서 읽어와 채우는 것
- thundering herd 이슈
	- expire time보다 조금 더 빨리 재계산해줘서 해당 값을 남아있게 한다.
	- 캐시 locking 방법 사용 가능
- 캐시 서버들 간에 데이터가 고루 분배되지 않아 특정 서버에만 캐시가 많이 쌓이는 이슈
	- adaptive consistency 개념 적용 가능
- 메모리 가격
	- SSD와 같은 좋은 장비에 cold 데이터를 보관하고 hot한 데이터만 메모리에 두는 방법 적용 가능
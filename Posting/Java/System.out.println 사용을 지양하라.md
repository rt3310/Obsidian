
## 1. 성능의 문제
`System.out.println()`

![[Pasted image 20240620190654.png]]
synchronized block을 감싸 thread-safe하게 처리하기 때문에 성능 저하가 올 수 있다.

> [!QUESTION]
> 그럼 logging 라이브러리들은 thread safe 하지 않은건가?
> 
> 스프링에서 기본적으로 추가되는 logging 라이브러리들(log4j2, logback)은 thread safe하게 구현되어 있다.
> 다만 synchroinzed block을 사용하는 경우는 매우 드물며, 내부적으로 thread safe한 자료구조를 사용하여 더 효율적으로 처리한다. 또한 비동기 로깅 방식도 지원한다.


## 2. 로그 레벨 관리 문제


## 3. 유지보수성 저하


개인적으로 저런형태의 접근방법을 좋아하지는 않습니다만 꼭 나쁜방법만은 아닙니다. 지금부터 하는 얘기는 제가 위의 방법을 옹호하기 때문만은 아니니 오해 없으시길 바랍니다.

클래스 하나에 대한 테스트는 위의 방법으로 접근하고 여러 클래스를 조합하여 좀 큰덩어리의 테스트는 유닛테스트를 돌리는 것도 프로젝트의 성격에 따라 생각해볼만한 방법이기도 합니다. 게다가 개발자가 변경중인 테스트를 바로바로 확인하면서 코딩하기에는 위의 방식이 편리한것은 사실이죠. 물론 진짜 저렇게 하고자 한다면 Test코드는 이너 클래스로 분리할것 같긴 합니다만.

PermGen 크기에 영향을 미친다는 것은 테스크 코드를 어떻게 작성 하느냐에 따라 다른 문제 입니다. 다음과 같은 코드의 경우 main이 호출되지 않는 경우 Test는 PermGen에 로딩되지 않습니다.

public static class SomeClass { public static void main(String[] args) { // Run Test }

```
public static class Test {
    ...
}
```

}

물론 다음과 같은 경우도 마찬가지 입니다. public static class SomeClass { .... }

class Test { .... }

후자의 경우 클래스 본체에 테스트코드가 들어가지는 않으니 (물론 본체에 main은 넣어 주어야 합니다만) 가독성에 있어서도 딱히 나쁘지 않습니다. 같은 파일에 테스트 코드가 포함되어 있으니 테스트 코드 수정 및 실행이 딱히 불편한것은 아니구요.

그리고 System.out.println에 대해 이런저런 코멘트들이 있는데요. 우선 synchornized 성능 얘기가 나왔는데 이게 옛날 처럼 무식하게 매번 Lock잡고 동작하는게 아닙니다. 동일한 쓰레드에서 실행하는 경우에는 속도차가 거의 의미가 없습니다. 자세한 것은 찾아보시구요. (백만번쯤은 호출되야 겨우 의미있는 값이 나올겁니다.) 어차피 synchronized 블럭이 없다한들 멀티쓰레드에서 Console로 찍어내는거라면 어차피 각 메시지 간 동기처리해줘야 하는것이 사실이구요. logback에 있는 async 기능을 사용하거나 동일한 방식으로 executor등을 통해 별도로 뽑아내 처리할 것이 아니라면 이나저나 도찐개찐입니다.

게다가 간단한 테스트 코드짜는데 logger까지 동원 한다는게 좀 오버라고도 생각되구요. 디버그 출력용으로 쓰기에도 System.out.format이 훨씬 편리합니다. 물론 현실은 전체 테스트 수행시의 결과를 일괄 수집하기위해 logger를 쓰는게 맞는 방법입니다만. 꼭 logback과 slf4j 따위를 일일히 깔고 설정파일에 file설정과 async따위의 설정을 해 주고 해야하나요? 어차피 서비스용 코드도 아니고 테스트 로그 수집할 거라면 Executor를 통해 로그 bulk writing 하는식으로 직접짜도 몇줄이면 됩니다.

뭐 여하튼... 일반적인게 무조건 상식적이고 그렇지 않은것은 무조건 비상식적인것은 아닙니다.
`#pragma`는 **컴파일러에게 말하는 전처리기 명령**이다. 즉, `#include`나 `#define`처럼 전처리기에 의해 컴파일 이전에 처리되지만, 그 명령은 컴파일러에게 전달된다.
사실 `pragma`는 C언어의 기본 키워드라고 하기 보다는, 컴파일러에 종속적인 키워드라고 하는 것이 맞다. `pragma`를 사용하는 문법은 컴파일러마다 다르고 딱히 통일된 것이 없기 때문이다.

```c
#include <stdio.h>
struct Weird {
	char arr[2];
	int i;
};
int main() {
	struct Weird a;
	printf("size of a : %d \n", sizeof(a));
	return 0;
}
```
성공적으로 컴파일 했다면
```
size of a : 8
```
와 같이 나온다.

상당히 이상하다. 분명히 `Weird` 구조체 내의 원소들의 총 바이트 수를 계산해보면 `arr`은 `char`형 변수 2개로 2바이트이고, `i`는 `int`형 변수 1개로 4바이트이므로 6이 나와야 정상이다. 그런데 컴퓨터는 왜 8로 출력했을까?

왜냐하면 실제로 메모리 상에서 위 구조체의 크기를 8바이트로 컴파일러가 지정했기 때문이다. 현재 우리가 사용하는 컴퓨터에서는 언제나 4바이트 단위로 모든 것을 처리하는 것이 빠르다. 따라서 언제나 컴퓨터에서 데이터를 보관할 때는 4의 배수로 데이터를 보관하는 것이 처리 시 용이하게 된다.
이렇게 데이터가 4의 배수 경계에 놓은 것을 **더블 워드 경계에 놓여있다** 라고 한다.

이러한 이유 때문에 위 `Weird` 구조체 역시 4의 배수를 맞추기 위해 크기를 8바이트로 '필요없는 2바이트를 추가하면서 까지' 맞춘 것이다. 이 문제가 중요하게 여겨지는 부분은 역시 하드웨어 간의 통신 때문에 그렇다.

예를 들어서 `SCSI` 인터페이스는 `PC`에서 하드디스크와 같은 주변 기기에 연결하기 위한 통신 방식으로 `SCSI` 장치들에게 읽기 명령을 내리기 위해서는 6바이트의 명령어를 전송하면 된다. 이 6바이트 명령어의 구조는 꽤 복잡해서 흔히 구조체로 많이 이용하는데, 만일 위와 같이 사용했다가는 구조체의 크기가 8바이트로 설정되어서 무슨 문제가 생길지 알 수 없다.
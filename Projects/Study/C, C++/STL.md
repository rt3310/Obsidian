
## vector

### 맨 뒤에 원소를 추가하는 작업
맨 뒤에 원소를 추가하는 작업은 엄밀히 말하자면 amortized $O(1)$이라고 한다. (amortized: 분할상환)

왜냐면 보통은 `vector`의 경우 현재 가지고 있는 원소의 개수보다 더 많은 공간을 할당해 놓고 있는다. 예를 들어 현재 `vector`에 있는 원소의 개수가 10개라면 이미 20개를 저장할 수 있는 공간을 미리 할당해 놓게 된다. 따라서 만약에 뒤에 새로운 원소를 추가하게 된다면 새롭게 메모리를 할당할 필요 없이, 그냥 이미 할당된 공간에 그 원소를 쓰기만 하면 된다. 따라서 대부분의 경우 $O(1)$로 `vector` 맨 뒤에 새로운 원소를 추가하거나 지울 수 있다.

문제가 되는 상황은 할당된 공간을 다 채웠을 때이다. 이 때는 어쩔 수 없이, 새로운 큰 공간을 다시 할당하고 기존의 원소들을 복사하는 수 밖에 없다. 따라서 이 경우 $n$개의 원소를 모두 복사해야 하기 때문에 $O(n)$으로 수행된다. 하지만 이 $O(n)$으로 수행되는 경우가 매우 드물기 때문에, 전체적으로 평균을 내보았을 때 $O(1)$로 수행됨을 알 수 있다. 이렇기에 amortized $O(1)$이라고 부르게 된다.

### 임의의 위치에 원소를 추가하는 작업
물론 `vector`라고 만능은 아니다. 맨 뒤에 원소를 추가하거나 제거하는 것은 빠르지만, 임의의 위치에 원소를 추가하거나 제거하는 것은 $O(n)$으로 느리다. 왜냐하면 어떤 자리에 새로운 원소를 추가하거나 뺄 경우 그 뒤에 오는 원소들을 한 칸씩 이동시켜 주어야 하기 때문이다. 따라서 이는 n번의 복사가 필요하게 된다.

- 임의의 위치 원소 접근(`[]`, `at`): $O(1)$
- 맨 뒤에 원소 추가 및 제거(`push_back`, `pop_back`): amortized $O(1)$, 평균적으로 $O(1)$이지만 최악의 경우 $O(n)$
- 임의의 위치 원소 추가 및 제거(`insert`, `erase`): $O(n)$

위처럼 어떠한 작업을 하냐에 따라서 속도 차가 매우 크기 때문에, C++ 표준 라이브러리를 잘 사욯아기 위해서는 내가 이 컨테이너를 어떠한 작업을 위해 사용하는지 정확히 인지하고, 적절한 컨테이너를 골라야 한다.


## vector

### 맨 뒤에 원소를 추가하는 작업
맨 뒤에 원소를 추가하는 작업은 엄밀히 말하자면 amortized $O(1)$이라고 한다. (amortized: 분할상환)

왜냐면 보통은 `vector`의 경우 현재 가지고 있는 원소의 개수보다 더 많은 공간을 할당해 놓고 있는다. 예를 들어 현재 `vector`에 있는 원소의 개수가 10개라면 이미 20개를 저장할 수 있는 공간을 미리 할당해 놓게 된다. 따라서 만약에 뒤에 새로운 원소를 추가하게 된다면 새롭게 메모리를 할당할 필요 없이, 그냥 이미 할당된 공간에 그 원소를 쓰기만 하면 된다. 따라서 대부분의 경우 $O(1)$로 `vector` 맨 뒤에 새로운 원소를 추가하거나 지울 수 있다.

문제가 되는 상황은 할당된 공간을 다 채웠을 때이다. 이 때는 어쩔 수 없이, 새로운 큰 공간을 다시 할당하고 기존의 원소들을 복사하는 수 밖에 없다. 따라서 이 경우 $n$개의 원소를 모두 복사해야 하기 때문에 $O(n)$으로 수행된다. 하지만 이 $O(n)$으로 수행되는 경우가 매우 드물기 때문에, 전체적으로 평균을 내보았을 때 $O(1)$로 수행됨을 알 수 있다. 이렇기에 amortized $O(1)$이라고 부르게 된다.

### 임의의 위치에 원소를 추가하는 작업
물론 `vector`라고 만능은 아니다. 맨 뒤에 원소를 추가하거나 제거하는 것은 빠르지만, 임의의 위치에 원소를 추가하거나 제거하는 것은 $O(n)$으로 느리다. 왜냐하면 어떤 자리에 새로운 원소를 추가하거나 뺄 경우 그 뒤에 오는 원소들을 한 칸씩 이동시켜 주어야 하기 때문이다. 따라서 이는 n번의 복사가 필요하게 된다.

- 임의의 위치 원소 접근(`[]`, `at`): $O(1)$
- 맨 뒤에 원소 추가 및 제거(`push_back`, `pop_back`): amortized $O(1)$, 평균적으로 $O(1)$이지만 최악의 경우 $O(n)$
- 임의의 위치 원소 추가 및 제거(`insert`, `erase`): $O(n)$

위처럼 어떠한 작업을 하냐에 따라서 속도 차가 매우 크기 때문에, C++ 표준 라이브러리를 잘 사욯아기 위해서는 내가 이 컨테이너를 어떠한 작업을 위해 사용하는지 정확히 인지하고, 적절한 컨테이너를 골라야 한다.

## iterator

반복자는 포인터처럼 사용할 수 있다. 실제로 현재 반복자가 가리키는 원소의 값을 보고 싶다면
```cpp
std::cout << *itr << std::endl;
```
포인터로 `*` 를 해서 가리키는 주소 값의 값을 보았던 것처럼, `*` 연산자를 이용해서 `itr` 이 가리키는 원소를 볼 수 있다. **물론 `itr` 은 실제 포인터가 아니고 `*` 연산자를 오버로딩해서 마치 포인터처럼 동작하게 만든 것**이다. `*` 연산자는 `itr` 이 가리키는 원소의 레퍼런스를 리턴한다.

```cpp
std::vector<int>::iterator itr = vec.begin() + 2;
std::cout << "3 번째 원소 :: " << *itr << std::endl;
```
또한 반복자 역시 `+` 연산자를 통해서 그 만큼 떨어져 있는 원소를 가리키게 할 수도 있다. (그냥 배열을 가리키는 포인터와 정확히 똑같이 동작한다고 생각하면 된다)

참고로 템플릿 버전의 경우,
```cpp
for (typename std::vector<T>::iterator itr = vec.begin(); itr != vec.end(); ++itr) {
```
와 같이 앞에 `typename` 을 추가해줘야만 한다. 그 이유는, `iterator` 가 `std::vector<T>` 의 의존 타입이기 때문이다. [의존 타입](https://modoocode.com/222?category=361027)
## 복사 생략

아래 코드를 실행해보면 결과가 어떻게 나올까?
```cpp
#include <iostream>

class A {
	int data_;

public:
	A(int data) : data_(data) { std::cout << "일반 생성자 호출!" << std::endl; }
	
	A(const A& a) : data_(a.data_) {
		std::cout << "복사 생성자 호출!" << std::endl;
	}
};

int main() {
	A a(1);  // 일반 생성자 호출
	A b(a);  // 복사 생성자 호출
	
	// 그렇다면 이것은?
	A c(A(2));
}
```
성공적으로 컴파일했다면
```
일반 생성자 호출!
복사 생성자 호출!
일반 생성자 호출!
```

뭔가 예상했던 것과 조금 다르다.
```cpp
// 그렇다면 이것은?
A c(A(2));
```
이 부분에서 "일반 생성자 호출!" 한번 만 출력되었다. 아마 정석대로 였다면,
```cpp
A(2)
```
를 만들면서 "일반 생성자 호출!" 이 한 번 출력되어야 하고, 생성된 임시 객체로 `c`가 복사 생성되면서 "복사 생성자 호출!" 이 될 것이기 때문이다. 그런데 왜 "일반 생성자 호출!" 하나 밖에 출력되지 않았을까? 복사 생성자가 왜 불리지 않았을까?

사실 생각해보면 굳이 임시 객체를 한 번 만들고, 이를 복사 생성할 필요가 없다. 어차피 `A(2)`로 똑같이 `c`를 만들거면, 차라리 `c`자체를 `A(2)`로 만들어진 객체로 해버리는 것과 똑같기 때문이다.

따라서 똑똑한 컴파일러는 복사 생성을 굳이 수행하지 않고, 만들어진 임시로 만들어진 `A(2)`자체를 `c`로 만들어버린다. 이렇게, 컴파일러 자체에서 복사를 생략해 버리는 작업을 **복사 생략(copy elision)** 이라고 한다.

컴파일러가 복사 생략을 하는 경우는(함수의 인자가 아닌) 함수 내부에서 생성된 객체를 그대로 리턴할 때, 수행할 수 있다. 물론 C++ 표준을 읽어보면 '반드시 복사 생략을 해라'라는 식이 아니라, '복사 생략을 할 수도 있다'라는 뜻으로 써 있다.
> [!note]
> C++ 17 부터 일부 경우에 대해서 (예를 들어서 함수 내부에서 객체를 만들어서 return 할 경우) 반드시 복사 생략을 해야되는 것으로 바뀌었다. 자세한 내용은 https://en.cppreference.com/w/cpp/language/copy_elision 참조

즉, 경우에 따라서는 복사 생략을 해도 되는 경우에, 복사 생략을 하지 않을 수도 있다는 뜻이다.
이전에 만들어 놓았던 `MyString` 클래스를 다시 살펴보자.
```cpp
#include <iostream>
#include <cstring>

class MyString {
	char *string_content;  // 문자열 데이터를 가리키는 포인터
	int string_length;     // 문자열 길이
	
	int memory_capacity;  // 현재 할당된 용량

public:
	MyString();
	
	// 문자열로 부터 생성
	MyString(const char *str);
	
	// 복사 생성자
	MyString(const MyString &str);
	
	void reserve(int size);
	MyString operator+(const MyString &s);
	~MyString();
	
	int length() const;
	
	void print();
	void println();
};

MyString::MyString() {
	std::cout << "생성자 호출 ! " << std::endl;
	string_length = 0;
	memory_capacity = 0;
	string_content = nullptr;
}

MyString::MyString(const char *str) {
	std::cout << "생성자 호출 ! " << std::endl;
	string_length = strlen(str);
	memory_capacity = string_length;
	string_content = new char[string_length];

	for (int i = 0; i != string_length; i++) string_content[i] = str[i];
}
MyString::MyString(const MyString &str) {
	std::cout << "복사 생성자 호출 ! " << std::endl;
	string_length = str.string_length;
	memory_capacity = str.string_length;
	string_content = new char[string_length];
	
	for (int i = 0; i != string_length; i++)
		string_content[i] = str.string_content[i];
}
MyString::~MyString() { delete[] string_content; }
void MyString::reserve(int size) {
	if (size > memory_capacity) {
		char *prev_string_content = string_content;
		
		string_content = new char[size];
		memory_capacity = size;
		
		for (int i = 0; i != string_length; i++)
			string_content[i] = prev_string_content[i];
		
		if (prev_string_content != nullptr) delete[] prev_string_content;
	}
}
MyString MyString::operator+(const MyString &s) {
	MyString str;
	str.reserve(string_length + s.string_length);
	for (int i = 0; i < string_length; i++)
		str.string_content[i] = string_content[i];
	for (int i = 0; i < s.string_length; i++)
		str.string_content[string_length + i] = s.string_content[i];
	str.string_length = string_length + s.string_length;
	return str;
}
int MyString::length() const { return string_length; }
void MyString::print() {
	for (int i = 0; i != string_length; i++) std::cout << string_content[i];
}
void MyString::println() {
	for (int i = 0; i != string_length; i++) std::cout << string_content[i];
	
	std::cout << std::endl;
}

int main() {
	MyString str1("abc");
	MyString str2("def");
	std::cout << "-------------" << std::endl;
	MyString str3 = str1 + str2;
	str3.println();
}
```
성공적으로 컴파일했다면
![[99E2F6505AB50C7A30ED98.webp]]
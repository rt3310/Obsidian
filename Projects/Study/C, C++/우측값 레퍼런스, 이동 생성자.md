## 복사 생략

아래 코드를 실행해보면 결과가 어떻게 나올까?
```cpp
#include <iostream>

class A {
	int data_;

public:
	A(int data) : data_(data) { std::cout << "일반 생성자 호출!" << std::endl; }
	
	A(const A& a) : data_(a.data_) {
		std::cout << "복사 생성자 호출!" << std::endl;
	}
};

int main() {
	A a(1);  // 일반 생성자 호출
	A b(a);  // 복사 생성자 호출
	
	// 그렇다면 이것은?
	A c(A(2));
}
```
성공적으로 컴파일했다면
```
일반 생성자 호출!
복사 생성자 호출!
일반 생성자 호출!
```

뭔가 예상했던 것과 조금 다르다.
```cpp
// 그렇다면 이것은?
A c(A(2));
```
이 부분에서 "일반 생성자 호출!" 한번 만 출력되었다. 아마 정석대로 였다면,
```cpp
A(2)
```
를 만들면서 "일반 생성자 호출!" 이 한 번 출력되어야 하고, 생성된 임시 객체로 `c`가 복사 생성되면서 "복사 생성자 호출!" 이 될 것이기 때문이다. 그런데 왜 "일반 생성자 호출!" 하나 밖에 출력되지 않았을까? 복사 생성자가 왜 불리지 않았을까?

사실 생각해보면 굳이 임시 객체를 한 번 만들고, 이를 복사 생성할 필요가 없다. 어차피 `A(2)`로 똑같이 `c`를 만들거면, 차라리 `c`자체를 `A(2)`로 만들어진 객체로 해버리는 것과 똑같기 때문이다.

따라서 똑똑한 컴파일러는 복사 생성을 굳이 수행하지 않고, 만들어진 임시로 만들어진 `A(2)`자체를 `c`로 만들어버린다. 이렇게, 컴파일러 자체에서 복사를 생략해 버리는 작업을 **복사 생략(copy elision)** 이라고 한다.

컴파일러가 복사 생략을 하는 경우는(함수의 인자가 아닌) 함수 내부에서 생성된 객체를 그대로 리턴할 때, 수행할 수 있다. 물론 C++ 표준을 읽어보면 '반드시 복사 생략을 해라'라는 식이 아니라, '복사 생략을 할 수도 있다'라는 뜻으로 써 있다.
> [!note]
> C++ 17 부터 일부 경우에 대해서 (예를 들어서 함수 내부에서 객체를 만들어서 return 할 경우) 반드시 복사 생략을 해야되는 것으로 바뀌었다. 자세한 내용은 https://en.cppreference.com/w/cpp/language/copy_elision 참조

즉, 경우에 따라서는 복사 생략을 해도 되는 경우에, 복사 생략을 하지 않을 수도 있다는 뜻이다.
이전에 만들어 놓았던 `MyString` 클래스를 다시 살펴보자.
```cpp
#include <iostream>
#include <cstring>

class MyString {
	char *string_content;  // 문자열 데이터를 가리키는 포인터
	int string_length;     // 문자열 길이
	
	int memory_capacity;  // 현재 할당된 용량

public:
	MyString();
	
	// 문자열로 부터 생성
	MyString(const char *str);
	
	// 복사 생성자
	MyString(const MyString &str);
	
	void reserve(int size);
	MyString operator+(const MyString &s);
	~MyString();
	
	int length() const;
	
	void print();
	void println();
};

MyString::MyString() {
	std::cout << "생성자 호출 ! " << std::endl;
	string_length = 0;
	memory_capacity = 0;
	string_content = nullptr;
}

MyString::MyString(const char *str) {
	std::cout << "생성자 호출 ! " << std::endl;
	string_length = strlen(str);
	memory_capacity = string_length;
	string_content = new char[string_length];

	for (int i = 0; i != string_length; i++) string_content[i] = str[i];
}
MyString::MyString(const MyString &str) {
	std::cout << "복사 생성자 호출 ! " << std::endl;
	string_length = str.string_length;
	memory_capacity = str.string_length;
	string_content = new char[string_length];
	
	for (int i = 0; i != string_length; i++)
		string_content[i] = str.string_content[i];
}
MyString::~MyString() { delete[] string_content; }
void MyString::reserve(int size) {
	if (size > memory_capacity) {
		char *prev_string_content = string_content;
		
		string_content = new char[size];
		memory_capacity = size;
		
		for (int i = 0; i != string_length; i++)
			string_content[i] = prev_string_content[i];
		
		if (prev_string_content != nullptr) delete[] prev_string_content;
	}
}
MyString MyString::operator+(const MyString &s) {
	MyString str;
	str.reserve(string_length + s.string_length);
	for (int i = 0; i < string_length; i++)
		str.string_content[i] = string_content[i];
	for (int i = 0; i < s.string_length; i++)
		str.string_content[string_length + i] = s.string_content[i];
	str.string_length = string_length + s.string_length;
	return str;
}
int MyString::length() const { return string_length; }
void MyString::print() {
	for (int i = 0; i != string_length; i++) std::cout << string_content[i];
}
void MyString::println() {
	for (int i = 0; i != string_length; i++) std::cout << string_content[i];
	
	std::cout << std::endl;
}

int main() {
	MyString str1("abc");
	MyString str2("def");
	std::cout << "-------------" << std::endl;
	MyString str3 = str1 + str2;
	str3.println();
}
```
성공적으로 컴파일했다면
![[99E2F6505AB50C7A30ED98.webp]]

```cpp
string_content = nullptr;
```
`nullptr` 는 C++ 11 에 새로 추가된 키워드로, 기존의 `NULL` 대체한다.

C 언어에서의 `NULL` 은 단순히 `#define` 으로 정의되어 있는 상수값 0인데, 이 때문에 `NULL` 이 값 0을 의미하는 것인지, 아니면 포인터 주소값 0을 의미하는 것인지 구분할 수 가 없었다.

하지만 `nullptr` 로 '포인터 주소값 0' 을 정확히 명시해 준다면 미연에 발생할 실수를 줄여 줄 수 있게 된다.

```cpp
MyString str3 = str1 + str2;
```
이 부분에서 두 개의 문자열을 더한 새로운 문자열로 `str3` 를 생성하고 있다.
```cpp
MyString MyString::operator+(const MyString &s) {
	MyString str;
	str.reserve(string_length + s.string_length);
	for (int i = 0; i < string_length; i++)
		str.string_content[i] = string_content[i];
	for (int i = 0; i < s.string_length; i++)
		str.string_content[string_length + i] = s.string_content[i];
	str.string_length = string_length + s.string_length;
	return str;
}
```
위 함수가 `str1 + str2` 를 실행 시에 호출되는데, 먼저 빈 `MyString` 객체인 [str](https://modoocode.com/str) 을 생성한다. (생성자 호출! 출력됨) 그 후에, `reserve` 함수를 이용해서 공간을 할당하고, `str1` 과 `str2` 를 더한 문자열을 복사하게 된다.

이렇게 리턴된 [str](https://modoocode.com/str) 은 `str3` 을 생성하는데 전달되어서, `str3` 의 복사 생성자가 호출된다.

하지만, 이미 예상했겠지만 굳이 `str3` 의 복사 생성자를 또 호출할 필요가 없다. 왜냐하면, 어차피 똑같이 복사해서 생성할 것이면, 이미 생성된 `(str1 + str2)` 가 리턴한 객체를 `str3`셈 치고 사용하면 되기 때문이다. 이전의 예제에서는 컴파일러가 복사 생략을 통해 불필요한 복사 생성자 호출을 하지 않았지만, 이 예제의 경우, 컴파일러가 복사 생략 최적화를 수행하지 않았다.

위 과정을 그림으로 간단히 살펴보면 아래와 같다.
![[996BBA465AB638B019DAE7.webp]]
만약에 `str1` 과 `str2` 의 크기가 엄청 컸다면 어땠을까? 쓸데없는 복사를 두 번 하는데 상당한 자원이 소모될 것이다.

그렇다면 이러한 문제를 C++ 에서는 어떠한 방식으로 해결하고 있을까?

## 좌측값(lvalue)과 우측값(rvalue)

모든 C++ 표현식 (expression) 의 경우 두 가지 카테고리로 구분할 수 있다. 하나는 이 구문이 어떤 '타입'을 가지냐 이고, 다른 하나는 어떠한 종류의 '값' 을 가지냐 이다. 값에 종류가 있어?라고 생각할 수 있는데, 아래 예시를 살펴보도록 하자.
```cpp
int a = 3;
```
위 표현식에서 먼저 'a' 를 살펴보도록 하자. 우리는 `a` 가 메모리 상에서 존재하는 변수임을 알고 있다. 즉 'a' 의 주소값을 `&` 연산자를 통해 알아 낼 수 있다는 것이다. 우리는 보통 이렇게 **주소 값을 취할 수 있는 값**을 **좌측값(lvalue)** 이라고 부른다. 그리고 좌측값은 어떠한 표현식의 왼쪽 오른쪽 모두에 올 수 있다 (왼쪽에만 와야 하는게 아니다).

반면에 오른쪽에 있는 '3' 을 살펴보도록 하자. 우리가 '3' 의 주소값을 취할 수 있는가? 아니다. '3' 은 왼쪽의 'a' 와는 다르게, 위 표현식을 연산할 때만 잠깐 존재할 뿐, 위 식이 연산되고 나면 사라지는 값이다. 즉, '3' 은 실체가 없는 값이다.

이렇게, **주소값을 취할 수 없는 값**을 **우측값(rvalue)** 이라고 부른다. 이름에도 알 수 있듯이, **우측값은 식의 오른쪽에만 항상 와야 한다**. 좌측값이 식의 왼쪽 오른쪽 모두 올 수 있는 반면, 우측값은 식의 오른쪽에만 존재해야 한다.
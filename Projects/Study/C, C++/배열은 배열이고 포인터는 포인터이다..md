예를 들어 다음과 같이 `sizeof`를 사용하는 코드를 살펴보자.
```c
#include <stdio.h>
int main() {
	int arr[6] = {1, 2, 3, 4, 5, 6};
	int* parr = arr;

	printf("Sizeof(arr) : %d \n", sizeof(arr));
	printf("Sizeof(parr) : %d \n", sizeof(parr));
}
```
성공적으로 컴파일 했다면
```
Sizeof(arr) : 24
Sizeof(parr) : 8
```
과 같이 나온다. 즉, `sizeof`를 `arr` 자체에 그대로 썼을 경우 배열의 실제 크기가 나온다. 반면에 `parr`에 `sizeof` 연산자를 사용하였을 경우 배열 자체의 크기가 아니라 그냥 포인터의 크기를 알려준다.
(64비트 컴퓨터의 경우 8바이트)

따라서 배열의 이름과, 첫 번째 원소의 주소값은 엄밀히 다른 것인 것이다. 그렇다면 왜 두 값을 출력했을 때 같은 값이 나왔을까?

그 이유는 C 언어 상에서 배열의 이름이 `sizeof` 연산자나 주소값 연산자(`&`)와 사용될 때 경우를 빼면, 배열의 이름 사용 시 암묵적으로 첫 번째 원소를 가리키는 포인터로 타입 변환되기 때문이다.

## [] 연산자 역할

우리는 앞서 포인터 연산이 어떻게 돌아가는지 배웠기 때문에 `[]`연산자의 역할을 대충 짐작할 수 있다.
```c
#include <stdio.h>
int main() {
	int arr[5] = {1, 2, 3, 4, 5};

	printf("a[3] : %d \n", arr[3]);
	printf("*(a+3) : %d \n", *(arr + 3));
	return 0;
}
```
성공적으로 컴파일 했다면
```
a[3] : 4
*(a+3) : 4
```
C에서 `[]`라는 연산자가 쓰이면 자동적으로 위처럼 형태로 바꾸어서 처리하게 된다. 즉, 우리가 `arr[3]`이라 사용한 것은 사실 `*(arr + 3)`으로 바뀌어서 처리가 된다는 뜻이다.

그리고 `arr`은 `+`연산자와 사용되기 때문에 앞서 말했듯이 첫 번째 원소를 가리키는 포인터로 변환되어서 `arr + 3`이 포인터 덧셈을 수행하게 된다. 그리고 이는 배열의 4번째 원소를 가리키게 된다.

따라서 다음 연산도 가능하다
```c
#include <stdio.h>
int main() {
	int arr[5] = {1, 2, 3, 4, 5};

	printf("a[3] : %d \n", 3[arr]);
	printf("*(a+3) : %d \n", *(arr + 3));
	return 0;
}
```
`3[arr]`은 무언가 조금 이상한 표현이다. 사실 이렇게 사용한다면 가독성도 떨어지고 한 번에 이해도 되지 않기에 대부분의 프로그래머들은 `arr[3]` 으로 사용할 것이다. 하지만, 앞에서도 `[]`는 연산자로 `3[arr]`을 `*(3+arr)`로 바꿔주기 때문에 `arr[3]`과 동일한 결과를 출력할 수 있게 된다.

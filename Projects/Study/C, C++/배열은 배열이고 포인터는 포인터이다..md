예를 들어 다음과 같이 `sizeof`를 사용하는 코드를 살펴보자.
```c
#include <stdio.h>
int main() {
	int arr[6] = {1, 2, 3, 4, 5, 6};
	int* parr = arr;

	printf("Sizeof(arr) : %d \n", sizeof(arr));
	printf("Sizeof(parr) : %d \n", sizeof(parr));
}
```
성공적으로 컴파일 했다면
```
Sizeof(arr) : 24
Sizeof(parr) : 8
```
과 같이 나온다. 즉, `sizeof`를 `arr` 자체에 그대로 썼을 경우 배열의 실제 크기가 나온다. 반면에 `parr`에 `sizeof` 연산자를 사용하였을 경우 배열 자체의 크기가 아니라 그냥 포인터의 크기를 알려준다.
(64비트 컴퓨터의 경우 8바이트)

따라서 배열의 이름과, 첫 번째 원소의 주소값은 엄밀히 다른 것인 것이다. 그렇다면 왜 두 값을 출력했을 때 같은 값이 나왔을까?

그 이유는 C 언어 상에서 배열의 이름이 `sizeof` 연산자나 주소값 연산자(`&`)와 사용될 때 경우를 빼면, 배열의 이름 사용 시 암묵적으로 첫 번째 원소를 가리키는 포인터로 타입 변환되기 때문이다.

## [] 연산자 역할

우리는 앞서 포인터 연산이 어떻게 돌아가는지 배웠기 때문에 `[]`연산자의 역할을 대충 짐작할 수 있다.
```c
#include <stdio.h>
int main() {
	int arr[5] = {1, 2, 3, 4, 5};

	printf("a[3] : %d \n", arr[3]);
	printf("*(a+3) : %d \n", *(arr + 3));
	return 0;
}
```
성공적으로 컴파일 했다면
```
a[3] : 4
*(a+3) : 4
```
C에서 `[]`라는 연산자가 쓰이면 자동적으로 위처럼 형태로 바꾸어서 처리하게 된다. 즉, 우리가 `arr[3]`이라 사용한 것은 사실 `*(arr + 3)`으로 바뀌어서 처리가 된다는 뜻이다.

그리고 `arr`은 `+`연산자와 사용되기 때문에 앞서 말했듯이 첫 번째 원소를 가리키는 포인터로 변환되어서 `arr + 3`이 포인터 덧셈을 수행하게 된다. 그리고 이는 배열의 4번째 원소를 가리키게 된다.

따라서 다음 연산도 가능하다
```c
#include <stdio.h>
int main() {
	int arr[5] = {1, 2, 3, 4, 5};

	printf("a[3] : %d \n", 3[arr]);
	printf("*(a+3) : %d \n", *(arr + 3));
	return 0;
}
```
`3[arr]`은 무언가 조금 이상한 표현이다. 사실 이렇게 사용한다면 가독성도 떨어지고 한 번에 이해도 되지 않기에 대부분의 프로그래머들은 `arr[3]` 으로 사용할 것이다. 하지만, 앞에서도 `[]`는 연산자로 `3[arr]`을 `*(3+arr)`로 바꿔주기 때문에 `arr[3]`과 동일한 결과를 출력할 수 있게 된다.

## 1차원 배열 가리키기

```c
#include <stdio.h>
int main() {
	int arr[3] = {1, 2, 3};
	int *parr;

	parr = arr;
	/* parr = &arr[0]; 도 동일하다 */

	printf("arr[1] : %d \n", arr[1]);
	printf("parr[1] : %d \n", parr[1]);
	return 0;
}
```
성공적으로 컴파일한다면
```
arr[1] : 2
parr[1] : 2
```

일단, 중점적으로 볼 부분은 아래와 같다.
```c
parr = arr;
```
바로 `arr`을 `parr`에 대입하는 부분이다. 앞에서 말했듯 `arr`은 배열의 첫 번째 원소를 가리키는 포인터로 변환되고, 그 원소의 타입이 `int` 이므로, 포인터의 타입은 `int*`가 될 것이다.
위 문장은 아래와 정확히 동일한 문장이 된다.
```c
parr = &arr[0];
```
따라서, `parr`을 통해서 `arr`을 이용했을 때와 동일하게 배열의 원소에 마음껏 접근할 수 있게 되는 것이 된다. 

```c
/* 포인터 이용하기 */
#include <stdio.h>
int main() {
	int arr[10] = {100, 98, 97, 95, 89, 76, 92, 96, 100, 99};

	int* parr = arr;
	int sum = 0;

	while (parr - arr <= 9) {
		sum += (*parr);
		parr++;
	}

	printf("내 시험 점수 평균 : %d \n", sum / 10);
	return 0;
}
```
성공적으로 컴파일하면
```
내 시험 점수 평균 : 94
```

일단, 포인터를 이용한 간단한 예제를 다루어보자.
```c
int* parr = arr;
```
먼저, `int`형 1차원 배열을 가리킬 수 있는 `int*` 포인터를 정의하였다. 그리고, 이 `parr`은 배열 `arr`을 가리키게 된다.
```c
while (parr - arr <= 9) {
	sum += (*parr);
	parr++;
}
```
그 다음 `while` 문을 살펴보자.
이 `while` 문은 `parr - arr`이 9이하일 동안 돌아가게 된다. `sum`에 `parr`이 가리키는 원소의 값을 더했다.
```c
parr++;
```
`parr`을 1증가시켰다. 포인터 연산에서 1증가시킨다면, `parr`에 저장된 주소값에 1이 더해지는 것이 아니라 `1 * (포인터가 가리키는 타입의 크기)`가 더해진다.
즉, `int` 형 포인터이므로 4가 더해지게돼서, 배열의 그 다음 원소를 가리킬 수 있게 된다.

그런데, 왜 굳이 `parr`을 따로 선언했을까?
`arr`이 `arr[0]`을 가리킨다는 사실을 알고있으므로 `arr`을 증가시켜서 `*(arr)`으로 접근해도 되지 않을까? 한 번, `arr`의 값을 변경할 수 있는지 살펴보자.
```c
#include <stdio.h>
int main() {
	int arr[10] = {100, 98, 97, 95, 89, 76, 92, 96, 100, 99};

	arr++; // 오류
	return 0;
}
```
컴파일 해보면
```
error C2105: '++'에 l-value가 필요합니다.
```
와 같은 오류를 만나게 된다.

배열의 이름이 첫 번째 원소를 가리키는 포인터로 타입 변경 된다고 했을 때, 이는 **단순히 배열의 첫 번째 원소를 가리키는 주소값 자체가 될 뿐**이다. 따라서 `arr++` 문장은 C 컴파일러 입장에서 다음을 수행한 것과 같다.
```c
(0x07fff1234)++;
```
이는 애초에 말이 안되는 문장이다.

## 배열 이름의 주소값?

위에서 배열 이름에 `sizeof` 연산자와 주소값 연산자를 사용할 때 빼고는 전부다 포인터로 암묵적 변환이 이루어진다고 했다. 그렇다면 주소값 연산자를 사용하면 어떻게 되길래 그러는 것일까? 한번 코드로 살펴보자.
```c
#include <stdio.h>

int main() {
	int arr[3] = {1, 2, 3};
	int (*parr)[3] = &arr;

	printf("arr[1] : %d \n", arr[1]);
	printf("parr[1] : %d \n", (*parr)[1]);
}
```
성공적으로 컴파일 하였다면
```
arr[1] : 2
parr[1] : 2
```
와 같이 잘 나온다.

```c
int (*parr)[3] = &arr;
```
`&arr`은 도대체 무슨 의미를 가질까? 이전에 `arr`은 `int*`로 암묵적 변환된다고 하였으니까 `&arr`은 `int**`가 되는 것일까? 아니다!! **암묵적 변화는 주소값 연산자가 왔을 때는 이루어지지 않는다**.

`arr`이 크기가 3인 배열이기 때문에, `&arr`을 보관할 포인터는 **크기가 3인 배열을 가리키는 포인터**가 되어야 할 것이다. 그리고 C 언어 문법상 이를 정의하는 방식은 위와 같다.

참고로 `parr`을 정의할 때 **`*parr`을 꼭 `()`로 감싸야만 하는데**, 만일 괄호로 빼버린다면
```c
int *parr[3];
```
와 같이 되어서 C 컴파일러가 `int *` 원소 3개를 가지는 배열을 정의한 것으로 오해하게 된다.

```c
printf("parr[1]: %d \n", (*parr)[1]);
```
`parr`은 크기가 3인 배열을 가리키는 포인터이기 때문에 배열을 직접 나타내기 위해서는 `*` 연산자를 통해 원래의 `arr`을 참조해야 한다. 따라서 `(*parr)[1]`과 `arr[1]`은 같은 문장이 된다.

한가지 재밌는 점은 `parr`과 `arr`은 같은 값을 가진다는 점이다.
```c
#include <stdio.h>
int main() {
	int arr[3] = {1, 2, 3};
	int (*parr)[3] = &arr;

	printf("arr : %p \n", arr);
	printf("parr : %p \n", parr);
}
```
성공적으로 컴파일 했다면
```
arr : 0x7ffda08cd25c
parr : 0x7ffda08cd25c
```
와 같이 나온다. `arr`과 `parr`모두 배열의 첫 번째 원소의 주소값을 출력한다. 물론 두 개의 타입은 다르다. 이는 당연한데, `arr` 자체가 어떤 메모리 공간에 존재하는 것이 아니기 때문이다.
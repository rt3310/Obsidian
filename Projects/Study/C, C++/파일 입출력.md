## 파일 읽기

```cpp
#include <fstream>
#include <iostream>
#include <string>

int main() {
  // 파일 읽기 준비
	std::ifstream in("test.txt", std::ios::binary);
	std::string s;

	int x;
	if (in.is_open()) {
		in.read((char*)(&x), 4);
		std::cout << std::hex << x << std::endl;
	} else {
		std::cout << "파일을 찾을 수 없습니다!" << std::endl;
	}

	return 0;
}
```
`ifstream`객체를 생성할 때 생성자에 옵션으로 `binary` 형태로 받겠다고 명시할 수 있다.
이 말은 문자열 데이터를 받는게 아니라 그냥 이진 그대로의 값을 받아내겠다는 의미이다. 만일 아무 것도 명시하지 않는다면 문자열 형태로 데이터를 받는다.

### 파일 전체 읽기
```cpp
#include <fstream>
#include <iostream>
#include <string>

int main() {
  // 파일 읽기 준비
	std::ifstream in("test.txt");
	std::string s;

	if (in.is_open()) {
	    // 위치 지정자를 파일 끝으로 옮긴다.
		in.seekg(0, std::ios::end);

	    // 그리고 그 위치를 읽는다. (파일의 크기)
		int size = in.tellg();

	    // 그 크기의 문자열을 할당한다.
		s.resize(size);

	    // 위치 지정자를 다시 파일 맨 앞으로 옮긴다.
		in.seekg(0, std::ios::beg);

	    // 파일 전체 내용을 읽어서 문자열에 저장한다.
		in.read(&s[0], size);
		std::cout << s << std::endl;
	} else {
		std::cout << "파일을 찾을 수 없습니다!" << std::endl;
	}

	return 0;
}
```

### 한 줄씩 읽기
```cpp
#include <fstream>
#include <iostream>
#include <string>

int main() {
	// 파일 읽기 준비
	std::ifstream in("test.txt");
	char buf[100];

	if (!in.is_open()) {
		std::cout << "파일을 찾을 수 없습니다!" << std::endl;
		return 0;
	}

	while (in) {
		in.getline(buf, 100);
		std::cout << buf << std::endl;
	}

	return 0;
}
```

[ifstream](https://modoocode.com/151) 에는 자기 자신을 `bool` 로 캐스팅 할 수 있는 캐스팅 연산자(`operator bool()`)가 오버로딩 되어 있다. 따라서 위와 같이 `while` 문 조건에 [in](https://modoocode.com/in) 을 전달한다면 `bool` 로 캐스팅 하는 연산자 함수가 호출된다. 이 때 [in](https://modoocode.com/in) 이 `true` 이기 위해서는 다음 입력 작업이 성공적이어야만 하고 현재 스트림에 오류 플래그가 켜져 있지 않아야 한다.

하지만 [getline](https://modoocode.com/236) 함수는 개행 문자 (혹은 지정한 문자) 가 나오기 전에 지정한 버퍼의 크기가 다 차게 된다면 `failbit` 를 키게 되므로, 버퍼의 크기를 너무 작게 만든다면 정상적으로 데이터를 받을 수 없다. 따라서 [getline](https://modoocode.com/236) 을 사용하기 전에 이와 같은 조건을 꼭 확인해야 한다.

이와 같은 한계점을 극복하기 위해서 `std::string` 에서 [getline](https://modoocode.com/236) 함수를 제공하고 있습니다.

```cpp
// std::string 에 정의된 getline 사용
#include <fstream>
#include <iostream>
#include <string>

int main() {
	// 파일 읽기 준비
	std::ifstream in("test.txt");

	if (!in.is_open()) {
		std::cout << "파일을 찾을 수 없습니다!" << std::endl;
		return 0;
	}

	std::string s;
	while (in) {
		getline(in, s);
		std::cout << s << std::endl;
	}

	return 0;
}
```

> [!WARNING] 주의 사항
> 한 가지 주의할 사항으로 `while` 문 조건으로 **절대 `in.eof()` 를 사용하면 안된다**. 이러한 코드를 사용했다면 99 퍼센트의 확률로 잘못된 코드이다. 왜냐하면 [eof](https://modoocode.com/167) 함수는 파일 위치 지시자가 파일에 끝에 도달한 **이후**에 `true` 를 리턴하기 때문이다.
> 
> 예를 들어서 `while` 문 안에서 파일을 읽다가 파일 끝(EOF) 바로 직전까지 읽었다고 해보자. 그렇다면 아직 EOF 를 읽지 않았으므로 `in.eof()` 는 참인 상태일 것이다. 그 상태에서 예컨대 `in >> data` 를 하게 된다면 `data` 에는 아무것도 들어가지 않게 된다. 즉 초기화가 되지 않은 상태로 남아있는 것이다
> 
> 다시 말해 `in.eof()` 는 `while` 문 안에서 **파일 읽기가 안전하다 라는것을 보장하지 않는다**. 정확한 사용법은 그냥 `while(in)` 처럼 스트림 객체 자체를 전달하는 것이다. 앞에서도 말했듯이 [istream](https://modoocode.com/146) 객체는 다음 읽기가 안전할 때만 `true` 로 캐스팅된다.


## 파일에 쓰기

```cpp
#include <iostream>
#include <fstream>
#include <string>

int main() {
	// 파일 쓰기 준비
	std::ofstream out("test.txt", std::ios::app);

	std::string s;
	if (out.is_open()) {
		out << "이걸 쓰자~~";
	}

	return 0;
}
```

out 객체를 생성할 때 옵션으로 `app`을 주게 되면, 파일에 스트림을 연결할 때 기존 파일의 내용을 지우고 새로 쓰는 것이 아니라 그 뒤에 새로운 내용을 붙여쓰게 된다.

앞서 나왔던 `ios::binary`와 `ios::app`말고도 4개가 더 있다.

- `ios::ate` : 자동으로 파일 끝에서부터 읽기와 쓰기를 실시한다. (즉 파일을 열 때 위치 지정자가 파일 끝을 가리키고 있게 된다)
- `ios::trunc` : 파일 스트림을 열면 기존에 있던 내용들이 모두 지워진다. 기본적으로 `ofstream`객체를 생성할 때 이와 같은 설정으로 만들어진다.
- `ios::in`, `std::ios::out` : 파일에 입력을 할지 출력을 할지 지정하며, `ifstream`과 `ofstream`객체를 생성할 때 각각은 이미 설정되어 있다.
참고로 `ios::ate`와 `ios::app`은 비슷해 보이지만 차이가 있다면 `ios::app`의 경우 원본 파일의 내용을 무조건 적으로 보장하지만, `ate`는 위치 지정자를 그 이전으로 옮길 수 있다. 즉, `app`의 경우 파일 위치 지정자가 기존 파일의 끝이 시작점이라 생각하여 움직이며 `ate`의 경우 기존 파일을 포함해서 움직인다.

그렇다고 해서 `ate`를 이용해서 기존에 있는 파일 데이터 한 가운데에 무언가를 끼워 넣을 수 있는 것은 아니다.
```cpp
#include <fstream>
#include <iostream>
#include <string>

int main() {
	// 두 파일에는 모두 abc라고 써 있다.
	std::ofstream out("test.txt", std::ios::app);
	std::ofstream out2("test2.txt", std::ios::ate);

	out.seekp(3, std::ios::beg);
	out2.seekp(3, std::ios::beg);

	out << "추가";
	out2 << "추가";

	return 0;
}
```
성공적으로 컴파일 했다면
![[2206553D578624CF30D956.webp]]
`app`을 사용한 경우 위와 같이 abc 바로 뒤에 '추가' 문자열에 붙어 있는 것으로 나타난다. 비록 파일 위치 지정자를 앞에서 3칸 떨어진 곳으로 이동하였음에도, `app`모드로 읽었을 때 현재 파일은 빈 파일이라 생각되어 위치 지정자가 움직일 공간이 없기에, 실제로 위치 지정자는 움직이지 않고 출력되었다.
![[262BC340578624EC26E38B.webp]]
반면에 `ate`를 사용한 경우 앞에서 3칸 띄어진 곳에 '추가'라고 문자열이 출력되었지만 기존의 `abc`라는 데이터는 지워졌다. 즉, `ate`모드로 파일을 열게 되면 비록 스트림 위치 지정자는 움직여서 3칸 뒤에 출력되기는 하였지만 기존에 써져 있던 내용은 모두 지워진다.

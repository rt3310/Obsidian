사실 `bool` 데이터 형은 1개 비트 만으로도 충분히 저장할 수 있지만, 8 비트를 사용해서 1개 `bool` 값을 저장해야 된다는 뜻이디. 이는 엄청난 메모리 낭비가 아닐 수 없다. 따라서 우리는 `Vector<bool>` 에 대해서는 특별히 따로 처리해줘야만 한다.

이와 같이 일부 경우에 대해서 따로 처리하는 것을 템플릿 특수화라고 한다. 템플릿 특수화는 다음과 같이 수행할 수 있다. 예를 들어,
```cpp
template<typename A, typename B, typename C>
class test {};
```
위와 같은 클래스 템플릿이 정의되어 있을 때, "아 나는 `A` 가 `int` 고 `C` 가 `double` 일 때 따로 처리하고 싶어!" 면,
```cpp
template <typename B>
class test<int, B, double> {};
```
와 같이 특수화 하고 싶은 부분에 원하는 타입을 전달하고 위에는 일반적인 템플릿을 쓰면 될 것이다. 만약에 `B` 조차도 특수화 하고 싶다면,
```cpp
template <>
class test<int, int, double> {};
```
와 같이 써주면 된다. 한 가지 중요한 점은, 전달하는 템플릿 인자가 없더라도 특수화하고 싶다면 `template<>`라도 남겨줘야 된다는 점이다. 그렇다면 우리의 `bool` 벡터의 경우
```cpp
template <>
class Vector<bool> {
	... // 원하는 코드
}
```
와 같이 따로 처리해주면 된다.

`Vector<bool>` 을 구현하기 위해서는 나는 평범한 `int` 배열을 이용할 것이다. 1 개의 `int` 는 4 바이트 이므로, 32 개의 `bool` 데이터들을 한데 묶어서 저장할 수 있을 것이다. 이를 통해서 원래 방식대로라면 `bool` 이 1 바이트로 저장되지만, 이렇게 하면 `bool` 을 1 비트로 정확히 표현할 수 있게 된다.

![[26389B3958E4E2BB16AC95.webp]]

이렇게 한데 묶어서 저장하면 메모리 관리 측면에서는 효율이 매우 높아지지만, 이를 구현하는데는 조금 더 복잡해진다.
왜냐하면 `int` 데이터에서 정확히 한 비트의 정보만 뽑아서 보여주어야 하기 때문이다. 예를 들어, `N`번 째 `bool` 데이터는 `N / 32`번째  `int`에 들어가 있고, 그 안에서 정확히 `N % 32`번째 비트가 된다.

이와 같은 내용으로 구현을 하면 다음과 같다.
```cpp
#include <iostream>
#include <string>

template<typename T>
class Vector {
	T* data;
	int capacity;
	int length;

public:
	// 어떤 타입을 보관하는지
	typedef T value_type;

	// 생성자
	Vector(int n - 1) : data(new T[n]), capacity(n), length(0) {}

	// 맨 뒤에 새로운 원소를 추가한다.
	void push_back(T s) {
		if (capacity <= length) {
			T* temp = new T[capacity * 2];
			for (int i = 0; i < length; i++) {
				temp[i] = data[i];
			}
			delete[] data;
			data = temp;
			capacity *= 2;
		}

		data[length] = s;
		length++;
	}

	T operator[](int i) { return data[i]; }

	// x 번째 위치한 원소를 제거한다.
	void remove(int x) {
		for (int i = x + 1; i < length; i++) {
			data[i - 1] = data[i];
		}
		length--;
	}

	int size() { return length; }

	~Vector() {
		if (data) {
			delete[] data;
		}
	}
};

template <>
class Vector<bool> {
	unsigned int* data;
	int capacity;
	int length;

public:
	typedef bool value_type;

	Vector(int n = 1) :
		data(new unsigned int[n / 32 + 1]),
		capacity(n / 32 + 1),
		length(0) {
		for (int i = 0; i < capacity; i++) {
			data[i] = 0;
		}
	}

	void push_back(bool s) {
		if (capacity * 32 <= length) {
			unsigned int* temp = new unsigned int[capacity * 2];
			for (int i = 0; i < capacity; i++) {
				temp[i] = data[i];
			}
			for (int i = capacity; i < 2 * capacity; i++) {
				temp[i] = 0;
			}

			delete[] data;
			data = temp;
			capacity *= 2;
		}

		if (s) {
			data[length / 32] |= (1 << (length % 32));
		}

		length++;
	}

	bool operator[](int i ) { return (data[i / 32] & (1 << (i % 32))) != 0; }
}
```
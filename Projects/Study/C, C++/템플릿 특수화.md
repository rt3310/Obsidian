사실 `bool` 데이터 형은 1개 비트 만으로도 충분히 저장할 수 있지만, 8 비트를 사용해서 1개 `bool` 값을 저장해야 된다는 뜻이디. 이는 엄청난 메모리 낭비가 아닐 수 없다. 따라서 우리는 `Vector<bool>` 에 대해서는 특별히 따로 처리해줘야만 한다.

이와 같이 일부 경우에 대해서 따로 처리하는 것을 템플릿 특수화라고 한다. 템플릿 특수화는 다음과 같이 수행할 수 있다. 예를 들어,
```cpp
template<typename A, typename B, typename C>
class test {};
```
위와 같은 클래스 템플릿이 정의되어 있을 때, "아 나는 `A` 가 `int` 고 `C` 가 `double` 일 때 따로 처리하고 싶어!" 면,
```cpp
template <typename B>
class test<int, B, double> {};
```
와 같이 특수화 하고 싶은 부분에 원하는 타입을 전달하고 위에는 일반적인 템플릿을 쓰면 될 것이다. 만약에 `B` 조차도 특수화 하고 싶다면,
```cpp
template <>
class test<int, int, double> {};
```
와 같이 써주면 된다. 한 가지 중요한 점은, 전달하는 템플릿 인자가 없더라도 특수화하고 싶다면 `template<>`라도 남겨줘야 된다는 점이다. 그렇다면 우리의 `bool` 벡터의 경우
```cpp
template <>
class Vector<bool> {
	... // 원하는 코드
}
```
와 같이 따로 처리해주면 된다.

`Vector<bool>` 을 구현하기 위해서는 나는 평범한 `int` 배열을 이용할 것이다. 1 개의 `int` 는 4 바이트 이므로, 32 개의 `bool` 데이터들을 한데 묶어서 저장할 수 있을 것이다. 이를 통해서 원래 방식대로라면 `bool` 이 1 바이트로 저장되지만, 이렇게 하면 `bool` 을 1 비트로 정확히 표현할 수 있게 된다.

![[26389B3958E4E2BB16AC95.webp]]

이렇게 한데 묶어서 저장하면 메모리 관리 측면에서는 효율이 매우 높아지지만, 이를 구현하는데는 조금 더 복잡해진다.
왜냐하면 `int` 데이터에서 정확히 한 비트의 정보만 뽑아서 보여주어야 하기 때문이다. 예를 들어, `N`번 째 `bool` 데이터는 `N / 32`번째  `int`에 들어가 있고, 그 안에서 정확히 `N % 32`번째 비트가 된다.

이와 같은 내용으로 구현을 하면 다음과 같다.
```cpp
#include <iostream>
#include <string>

template<typename T>
class Vector {
	T* data;
	int capacity;
	int length;

public:
	// 어떤 타입을 보관하는지
	typedef T value_type;

	// 생성자
	Vector(int n - 1) : data(new T[n]), capacity(n), length(0) {}

	// 맨 뒤에 새로운 원소를 추가한다.
	void push_back(T s) {
		if (capacity <= length) {
			T* temp = new T[capacity * 2];
			for (int i = 0; i < length; i++) {
				temp[i] = data[i];
			}
			delete[] data;
			data = temp;
			capacity *= 2;
		}

		data[length] = s;
		length++;
	}

	T operator[](int i) { return data[i]; }

	// x 번째 위치한 원소를 제거한다.
	void remove(int x) {
		for (int i = x + 1; i < length; i++) {
			data[i - 1] = data[i];
		}
		length--;
	}

	int size() { return length; }

	~Vector() {
		if (data) {
			delete[] data;
		}
	}
};

template <>
class Vector<bool> {
	unsigned int* data;
	int capacity;
	int length;

public:
	typedef bool value_type;

	Vector(int n = 1) :
		data(new unsigned int[n / 32 + 1]),
		capacity(n / 32 + 1),
		length(0) {
		for (int i = 0; i < capacity; i++) {
			data[i] = 0;
		}
	}

	void push_back(bool s) {
		if (capacity * 32 <= length) {
			unsigned int* temp = new unsigned int[capacity * 2];
			for (int i = 0; i < capacity; i++) {
				temp[i] = data[i];
			}
			for (int i = capacity; i < 2 * capacity; i++) {
				temp[i] = 0;
			}

			delete[] data;
			data = temp;
			capacity *= 2;
		}

		if (s) {
			data[length / 32] |= (1 << (length % 32));
		}

		length++;
	}

	bool operator[](int i ) { return (data[i / 32] & (1 << (i % 32))) != 0; }
}
```

## 함수 객체 (Function Object, Functor)

함수 객체는 함수는 아니지만 함수인 척을 하는 객체를 말한다.

```cpp
template <typename Cont, typename Comp>
void bubble_sort(Cont& cont, Comp& comp) {
	for (int i = 0; i < cont.size(); i++) {
		for (int j = i + 1; j < cont.size(); j++) {
			if (!comp(cont[i], cont[j])) {
		        cont.swap(i, j);
		    }
	    }
	}
}

struct Comp1 {
	bool operator()(int a, int b) { return a > b; }
};

struct Comp2 {
	bool operator()(int a, int b) { return a < b; }
};

int main() {
	Vector<int> int_vec;
	int_vec.push_back(3);
	int_vec.push_back(1);
	int_vec.push_back(2);
	int_vec.push_back(8);
	int_vec.push_back(5);
	int_vec.push_back(3);
	
	std::cout << "정렬 이전 ---- " << std::endl;
	for (int i = 0; i < int_vec.size(); i++) {
	std::cout << int_vec[i] << " ";
	}
	
	Comp1 comp1;
	bubble_sort(int_vec, comp1);
	
	std::cout << std::endl << std::endl << "내림차순 정렬 이후 ---- " << std::endl;
	for (int i = 0; i < int_vec.size(); i++) {
		std::cout << int_vec[i] << " ";
	}
	std::cout << std::endl;
	
	Comp2 comp2;
	bubble_sort(int_vec, comp2);
	
	std::cout << std::endl << "오름차순 정렬 이후 ---- " << std::endl;
	for (int i = 0; i < int_vec.size(); i++) {
		std::cout << int_vec[i] << " ";
	}
	std::cout << std::endl;
```

그렇다면 뭐가 더 나은 방법일까? `Functor?` 아니면 구닥다리 함수 포인터?

`Functor` 를 사용하는것이 여러 모로 훨씬 편리한 점이 많다. 일단, 클래스 자체에 여러가지 내부 `state` 를 저장해서 비교 자체가 복잡한 경우에도 손쉽게 사용자가 원하는 방식으로 만들어낼 수 있다. 뿐만 아니라, 함수포인터로 함수를 받아서 처리한다면 컴파일러가 최적화를 할 수 없지만, `Functor` 를 넘기게 된다면 컴파일러가 `operator()` 자체를 인라인화 시켜서 매우 빠르게 작업을 수행할 수 있다.

> [!NOTE]
> 실제로 C 의 qsort 와 C++ 의 표준 sort 함수를 비교한다면 C++ 버전이 훨씬 빠르다. 왜냐하면 C 의 qsort 는 비교를 수행하기 위해 매번 함수를 호출시켜야 하지만, C++ 버전의 경우 그 함수를 인라인화 시켜버리면 되기 때문이다. (함수 호출 필요 없음)

## 타입이 아닌 템플릿 인자 (non-type template arguments)

```cpp
#include <iostream>

template <typename T, int num>
T add_num(T t) {
	return t + num;
}

int main() {
	int x = 3;
	std::cout << "x : " << add_num<int, 5>(x) << std::endl;
}
```
위와 같이 `T` 에 `int` 를, `num` 에 5 를 전달하였으므로 생성되는 `add_num` 함수는 아래와 같다.
```cpp
int add_num(int t) { return t + 5; }
```
참고로 만약에 `add_num` 에 템플릿 인자 `<>` 를 지정하지 않았더라면 아래와 같은 컴파일 타임 오류가 발생하게 된다.
![[Pasted image 20241003013415.png]]
왜냐하면 상식적으로 컴파일러가 `num` 에 뭐가 들어가는지 알길이 없이 때문이다. 따라서 위 처럼 `num` 의 값을 결정할 수 없다고 불만을 제시하는 오류가 발생하게 된다.

한 가지 중요한 점은 템플릿 인자로 전달할 수 있는 타입들이 아래와 같이 제한적이다. (자세한 내용은 [여기](https://en.cppreference.com/w/cpp/language/template_parameters) 참조) -> C++20부터 이 제한이 좀 더 완화되었다.
- 정수 타입들 (`bool`, `char`, `int`, `long` 등등). 당연히 `float` 과 `double` 은 제외
- 포인터 타입
- `enum` 타입
- `std::nullptr_t` (널 포인터)

타입이 아닌 템플릿 인자를 가장 많이 활용하는 예시는 컴파일 타임에 값들이 정해져야 하는 것들이 되겠다. 대표적인 예시로 배열을 들 수 있다. C 에서의 배열의 가장 큰 문제점은 함수에 배열을 전달할 때 배열의 크기에 대한 정보를 잃어버린다는 점이다.

하지만 템플릿 인자로 배열의 크기를 명시한다면 (어차피 배열의 크기는 컴파일 타임에 정해지는 것이니까), 이 문제를 완벽하게 해결 할 수 있다. 이와 같은 기능을 가진 배열을 C++ 11 부터 제공되는 `std::array` 를 통해 사용할 수 있습니다.

```cpp
#include <iostream>
#include <array>

int main() {
	// 마치 C 에서의 배열 처럼 {} 을 통해 배열을 정의할 수 있다.
	std::array<int, 5> arr = {1, 2, 3, 4, 5};
	// int arr[5] = {1, 2, 3, 4, 5}; 와 동일
	
	for (int i = 0; i < arr.size(); i++) {
		std::cout << arr[i] << " ";
	}
	std::cout << std::endl;
}
```
위 처럼 배열의 원소들의 타입과 (`int`) 크기 (5) 를 템플릿 인자로 명시한 뒤에, 초기화만 해주면 된다. 그리고 마치 C 에서 배열을 정의할 때처럼 `{}` 를 이용해서 생성하면 된다. 참고로 `{}` 는 유니폼 초기화(uniform initialization) 이라 불리는 C++ 11 에서 추가된 개념이다.

한 가지 재미있는 점은 이 `arr` 은 런타임에서 동적으로 크기가 할당되는 것이 아니라는 점이다. 마치 배열처럼 컴파일 시에 `int` 5개를 가지는 메모리를 가지고 스택에 할당된다.

또한 중요한 점으로 이 배열을 함수에 전달하기 위해서는 그냥 `std::array` 를 받는 함수를 만들면 안된다. `std::array<int, 5>` 자체가 하나의 타입이기 때문에
```cpp
#include <iostream>
#include <array>

void print_array(const std::array<int, 5>& arr) {
	for (int i = 0; i < arr.size(); i++) {
		std::cout << arr[i] << " ";
	}
	std::cout << std::endl;
}

int main() {
	std::array<int, 5> arr = {1, 2, 3, 4, 5};
	print_array(arr);
}
```

문제는 각 [array](https://modoocode.com/314) 크기 별로 함수를 만들어줘야 한다. 하지만 여기서도 역시 템플릿을 쓸 수 있다.
```cpp
#include <iostream>
#include <array>

template <typename T>
void print_array(const T& arr) {
	for (int i = 0; i < arr.size(); i++) {
		std::cout << arr[i] << " ";
	}
	std::cout << std::endl;
}

int main() {
	std::array<int, 5> arr = {1, 2, 3, 4, 5};
	std::array<int, 7> arr2 = {1, 2, 3, 4, 5, 6, 7};
	std::array<int, 3> arr3 = {1, 2, 3};
	
	print_array(arr);
	print_array(arr2);
	print_array(arr3);
}
```

## 디폴트 템플릿 인자

```cpp
#include <iostream>

template <typename T, int num = 5>
T add_num(T t) {
	return t + num;
}

int main() {
	int x = 3;
	std::cout << "x : " << add_num(x) << std::endl;
}
```
템플릿 디폴트 인자는 함수 디폴트 인자랑 똑같이 인자 뒤에 default 값을 넣어주면 된다.

타입 역시 디폴트로 지정이 가능하다. 예를 들어, 아래와 같은 `min` 함수를 생각해보자.
```cpp
template <typename T, typename Comp>
T Min(T a, T b) {
	Comp comp;
	if (comp(a, b)) {
		return a;
	}
	return b;
}
```
`Min` 함수는 임의의 두 원소를 받아서 작은 원소를 리턴한다. 이 때 이 원소들을 어떻게 비교할지는 `Comp` 라는 객체가 이를 수행한다.

물론 우리는 `int` 와 같이 간단한 애들은 그냥 `<` 를 사용해서 대소 비교를 하면 되지만 일반적인 객체들에 대해서도 모두 동작하게 하려면 따로 두 원소를 비교하는 `Comp` 라는 클래스가 필요하다.

예를 들어, `int` 간의 대소 비교를 위해서는
```cpp
template <typename T>
struct Compare {
	bool operator()(const T& a, const T& b) const { return a < b; }
};

int a = 3, b = 4;
std::cout << "min : " << Min<int, Compare<int>>(a, b);
```
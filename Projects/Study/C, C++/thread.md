## 멀티스레드 프로그램

프로세스란, 운영체제에서 실행되는 프로그램의 최소 단위라고 보면 된다. 즉, 우리가 1개의 프로그램을 가리킬 때 보통 1개의 프로세스를 의미하는 경우가 많다.

> 물론 구글 크롬처럼 한 개의 탭이 한 개의 프로세스를 차지해서, 프로그램 자체가 여러개의 프로세스로 이루어진 경우도 있다.

그렇다면 이 프로세스들은 어디에서 실행될까? 바로 컴퓨터의 두뇌라 하는 CPU 의 코어 (연산하는 부분)에서 실행되고 있다. 옛날 (2005년 이전)에는 서버용이 아닌 일반 소비자용 CPU 의 경우 1개의 코어를 가지는 것이 대부분이었다(대표적으로 펜티엄 4가 있다). 이 말은 즉, CPU가 한 번에 한 개의 연산을 수행한다는 것이다.

근데 CPU가 한 번에 한 가지 연산 밖에 못한다면, 도대체 그 시절에는 인터넷을 하면서 음악을 듣고, 아니면 게임을 하는 등 여러가지 일들을 어떻게 한꺼번에 했을까? 그 비밀은 **컨텍스트 스위칭(Context switching)** 이라는 기술에 숨어 있다.

컴퓨터에서 프로그램이 실행될 때 겉으로 보기에는 프로그램이 연속적으로 쭈르륵 작동하는 것처럼 보이지만 실제로는 그렇지 않다. 아래 그림을 보면 CPU 코어 하나에서 프로그램들이 어떻게 실행되는지 알 수 있다.
![[14.1.4.webp]]
보다시피, 프로그램 하나가 쭈르륵 작동하는 것이 아니라, 프로그램 하나가 잠시 실행되었다가, 다른 프로그램으로 스위칭 되는 것을 볼 수 있다. 즉, CPU는 한 프로그램을 통째로 쭉 실행시키는 것이 아니라, 이 프로그램 조금, 저 프로그램 조금씩 골라서 차례를 돌며 실행시킨다는 것을 알 수 있다.

정확히 말하자면, CPU는 그냥 운영체제가 처리하라고 시키는 명령어들을 실행할 뿐, 어떤 프로그램을 실행시키고, 얼마 동안 실행시키고, 또 다음에 무슨 프로그램으로 스위치 할지는 운영체제의 **스케쥴러(scheduler)** 가 알아서 결정하게 됩니다.

### 쓰레드

이 CPU 코어에서 돌아가는 프로그램 단위를 **쓰레드 (thread)** 라고 부른다. 즉, **CPU 의 코어 하나에서는 한 번에 한 개의 쓰레드의 명령을 실행시키게 된다**.

한 개의 프로세스는 최소 한 개 쓰레드로 이루어져 있으며, 여러 개의 쓰레드로 구성될 수 있게 된다. 이렇게 여러 개의 쓰레드로 구성된 프로그램을 멀티 쓰레드(multithread) 프로그램이라 한다.

쓰레드와 프로세스의 가장 큰 차이점은 메모리 공유이다. 프로세스들은 서로 메모리를 공유하지 않는다. 다시 말해, 프로세스 1과 프로세스 2가 있을 때, 프로세스 1은 프로세스 2의 메모리에 접근할 수 없고, 마찬가지로 프로세스 2도 프로세스 1의 메모리에 접근할 수 없다.
![[14.1.6.webp]]
하지만 쓰레드의 경우는 다르다. 만일 한 프로세스 안에 쓰레드 1과 쓰레드 2가 있다면, 서로 같은 메모리를 공유하게 된다. 예컨대, 쓰레드 1과 쓰레드 2가 같은 변수의 값에 접근할 수 있다.

여태까지 작성했던 프로그램들은 모두 한 개의 쓰레드로 구성된 싱글 쓰레드 프로그램이다. 하지만, 많은 프로그램들이 멀티쓰레드 프로그램으로 구성되어 있는데, 맥에서 나오는 작업관리자 사진의 우측 하단에, 현재 시스템의 쓰레드 개수와 프로세스에서도 알 수 있듯이, 프로세스 개수는 348개 인데, 총 쓰레드 수는 1711개로 써있다. 대량 프로세스 하나 당 5개의 쓰레드들로 구성되어 있다고 생각하면 될 것이다.
![[14.1.1.webp]]

## CPU 의 코어는 한 개가 아니다.

요 근래 들어서는 CPU 의 발전 방향이 코어 하나의 동작 속도를 높이기 보다는, CPU 에 장착된 코어 개수를 늘려가는 식으로 발전해왔다.

예를 들어서 인텔의 i5 모델의 경우 4개의 코어가 장착되어 있다. AMD 의 라이젠 모델의 경우 아래 그림과 같이 8개의 코어를 가지고 있다. 참고로 SMT 라는 기술을 통해서 마치 16개의 코어인 것처럼 보이지만 하단에 Cores를 보면 실제로는 8개의 코어만 있다는 점을 확인할 수 있다.
![[14.1.3.webp]]
그렇다면 실제 이 8개의 코어에서 프로그램이 실행되는 모습은 아래와 같을 것이다.
![[14.1.5.webp]]
따라서 이전에 싱글 코어 CPU에서 아무리 멀티 쓰레드 프로그램이라 하더라도 결국에는 한 번에 한 쓰레드만 실행할 수 있었겠지만, 멀티코어 CPU 에서는 여러 개의 코어에 각기 다른 쓰레드들이 들어가 동시에 여러 개의 쓰레드들을 효율적으로 실행할 수 있다.

## 그래서 왜 멀티 쓰레드 인데?

앞서 현대의 CPU 가 여러 개의 코어를 지원함으로써 여러 개의 쓰레드를 동시에 실행시킬 수 있다고 했다. 그렇다면 어떨 때 프로그램을 멀티쓰레드로 만드는 것이 유리할까? 이에 대해 크게 두 가지 이유를 생각할 수 있다.

### 병렬 가능한 (Parallelizable) 작업들

예를 들어서 1부터 10000까지 더하는 작업을 생각해보자. 만약에 단일 쓰레드 프로그램으로 짠다면 단순히 `for`문으로 1부터 10000까지 더하는 코드를 쓰면 된다.

반면에 이를 쓰레드 10개로 만든다면 어떨까. 예를 들어, 쓰레드 1에서 1부터 1000까지 더하고, 쓰레드 2에서 1001부터, 2000까지 더하고, ... 쓰레드 10에서 9001부터 10000까지 더하게 한다면 어떨까? 모든 쓰레드의 작업이 완료된 후에, 각각의 결과를 합치는 식으로 말이다.
![[Pasted image 20241011135033.png]]
CPU 코어에서 덧셈 한 번에 1초가 걸린다고 가정해보자. 그렇다면 단일 쓰레드의 경우 10000초가 걸리게 된다.

하지만, 멀티쓰레드를 사용하였을 경우 CPU 에 코어가 10개가 있어서 각 쓰레드들이 동시에 실행될 수만 있다면, 각 쓰레드에서 덧셈은 1000초가 걸리고, 마지막으로 다 합칠 때 10초가 걸려서 총 1010초가 걸리게 된다.

싱글쓰레드의 경우보다 속도가 무려 10배가 향상된 수치이다!

이렇게, 어떠한 작업을 여러 개의 다른 쓰레드를 이용해서 좀 더 빠르게 수행하는 것을 **병렬화(parallelize)** 라고 한다. 하지만 모든 작업들이 이렇게 병렬화가 가능한 것이 아니다. 예를 들어서 피보나치 수열을 계산하는 프로그램을 생각해보자. 아마 아래와 같이 작성할 것이다.
```cpp
int main() {
	int bef = 1, cur = 1;
	
	// 물론 100 번째 피보나치 항을 구한다면, int 오버플로우가 나겠지만 일단 그 점은 여기서 무시하도록 하자.
	for (int i = 0; i < 98; i++) {
		int temp = cur;
		cur = cur + bef;
		bef = temp;
	}
	std::cout << "F100 : " << cur << std::endl;
}
```
위와 같은 프로그램을 여러 쓰레드를 사용하는 방식으로 실행 속도를 높일 수 있을까?

피보나치의 $n$ 번째 항인 $F_n$ 을 계산하기 위해서는 $F_{n−1}$과 $F_{n−2}$을 알아야 한다. 다시 말해 $F_3$을 구하기 위해서는 $F_1$​과 $F_2$를 알아야 하고, $F_4$를 구하기 위해서는 $F_3$과 $F_2$를 알아야 한다.

예를 들어서 $F_3$을 쓰레드 1, $F_4$를 쓰레드 2에서 계산한다고 생각해보자. 쓰레드 2가 값을 계산하기 위해서는 $F_3$의 값이 필요하다. 그런데, $F_3$은 쓰레드 1에서 계산되고 있으므로, 쓰레드 1의 연산이 끝날 때 까지 쓰레드 2가 기다려야 한다. 따라서 최종 실행 속도는 그냥 쓰레드 1에서 $F_3$과 $F_4$모두를 계산하는 것과 차이가 없게 된다.

결과적으로 이와 같은 방법으로 피보나치 수열을 계산하는 프로그램은 병렬화 하는 것이 매우 까다롭다. 이러한 문제가 발생하는 근본적인 이유는 **어떠한 연산 (연산 A) 을 수행하기 위해 다른 연산 (연산 B)의 결과가 필요하기 때문**이라 볼 수 있다. 이와 같은 상황을 **A 가 B 에 의존(dependent)한다** 라고 한다.

프로그램 논리 구조 상에서 연산들 간의 의존 관계가 많을 수록 병렬화가 어려워지고, 반대로, 다른 연산의 결과와 관계없이 독립적으로 수행할 수 있는 구조가 많을 수록 병렬화가 매우 쉬워진다.

### 대기시간이 긴 작업들

인터넷에서 웹사이트들을 긁어 모으는 프로그램을 생각해보자. 아마 아래와 같이 구성할 수 있을 것이다.
```cpp
int main() {
	// 다운 받으려는 웹사이트와 내용을 저장하는 맵
	map<string, string> url_and_content;
	for (auto itr = url_and_content.begin(); itr != url_and_content.end();
	   ++itr) {
		const string& url = itr->first;
		
		// download 함수는 인자로 전달받은 url 에 있는 사이트를 다운받아 리턴한다.
		itr->second = download(url);
	}
}
```
이 임의로 만든 `download` 함수는 인자로 전달한 `url` 에 위치한 웹사이트를 다운 받아서 리턴한다.

문제는 우리의 CPU 의 처리 속도에 비해 인터넷은 매우 느리다는 점이다.

우리가 흔히 `ping`이라고 부르는 것은, 내가 보낸 요청이 상대 서버에 도착해서 다시 나에게 돌아오는데 걸리는 시간을 의미한다. 보통 우리나라 안에서 웹사이트에 요청을 보낼 시에 `ping`이 `30`밀리초 정도 나오고, 해외의 경우 (예컨대 미국), `150`밀리초에서 멀면 `300`밀리초 까지 걸리게 된다.

> 이 시간은 웹사이트 전체를 다운 받는데 걸리는 시간을 말하는 것이 아니다. 내가 다운로드 요청을 보내서, 첫 번째 응답이 돌아올 때 까지 걸리는 시간을 말한다.

`150`밀리초라 한다면 사람 기준에서 얼마 안되는 시간처럼 보인다. `0.15`초 이기 때문이다. 하지만, 실제로 컴퓨터는 `0.15`초 동안 정말 많은 일들을 할 수 있다. 보통의 CPU는 1초에 109109번 연산을 할 수 있기 때문에 `0.15`초 동안 응답을 단순히 기다리기만 한다면, 1.5×1081.5×108번 연산을 수행할 수 있는 시간을 버리게 되는 것이다. 즉 CPU코어를 비효율적으로 사용하게 되는 셈이다. 한창 일해야될 CPU 를 놀게 놔둔다니!
![[14.1.8.webp]]

하지만 만일 `download` 함수를 호출하는 것을 여러 쓰레드에서 부르면 어떨까요?
![[14.1.9.webp]]
위 그림은 같은 코어 안에서 쓰레드들이 컨텍스트 스위칭을 통해 기다리는 시간 없이 CPU를 최대한으로 사용하는 것을 볼 수 있다. 초록색 쓰레드에서 웹사이트 1에 요청을 보낸 후, 이전에는 웹사이트 1에서 데이터를 다운로드를 시작하기까지 기다려야 했지만, 이 경우 빨간색 쓰레드로 컨텍스트 스위칭 되어서, 기다리는 시간을 낭비하지 않고 바로 웹사이트 2에 요청을 보내는 것을 볼 수 있다.

위와 같이 처리하게 된다면 CPU 시간을 낭비하지 않고 효율적으로 작업을 처리할 수 있게 된다.

## C++ 에서 쓰레드 생성하기

이전에는 C++ 표준에 쓰레드가 없어서, 각 플랫폼 마다 다른 구현을 사용해야만 했다. (예를 들어서 윈도우즈에서는 `CreateThread` 로 쓰레드를 만들지만 리눅스에서는 `pthread_create` 로 만든다)

하지만 `C++ 11` 에서부터 표준에 쓰레드가 추가되면서, 쓰레드 사용이 매우 편리해졌다.

이제 첫 번째 멀티 쓰레드 프로그램을 만들어보자.
```cpp
#include <iostream>
#include <thread>
using std::thread;

void func1() {
	for (int i = 0; i < 10; i++) {

	}
}
```
성공적으로 컴파일했다면
```
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 1 작동중! 
쓰레드 3 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중!
```

`C++ 11` 에서 쓰레드를 생성하는 방법은 매우 간단하다.
```cpp
#include <thread>
```
일단 위 처럼 `thread` 헤더파일을 추가하고,
```cpp
thread t1(func1);
```
`thread` 객체를 생성하는 순간 끝이다. 이렇게 생성된 `t1`은 인자로 전달받은 함수 `func1`을 새로운 쓰레드에서 실행하게 된다.

즉
```cpp
thread t1(func1);
thread t2(func2);
thread t3(func3);
```
를 실행하게 되면, `func1, func2, func3` 가 각기 다른 쓰레드 상에서 실행되게 된다.
![[14.1.10.webp]]
한 가지 중요한 사실은 이 쓰레드들이 CPU 코어에 어떻게 할당되고, 또 언제 컨텍스트 스위치를 할 지는 전적으로 운영체제의 마음에 달려있다는 점이다.

> 쓰레드 3개를 만들었다고 해서 반드시 3개의 각기 다른 코어에 할당되는 것이 아니다. 운이 좋으면 그렇게 되겠지만, 그냥 한 코어에 쓰레드 3개가 컨텍스트 스위칭을 하면서 돌아갈 수도 있다.

예를 들어서 우리의 실행 결과를 살펴보자.

처음에 쓰레드 1 작동중! 이 조금 나오다가, 쓰레드 3 작동중! 이 나온다. 그 다음에 쓰레드 2 작동중! 또 나오다가, 뒤죽박죽 순서가 바뀌어서 나오는 것을 볼 수 있다. 한 가지 더 재미있는 점은, 프로그램을 실행 할 때 마다 그 결과가 달라진다는 점이다. 운영체제가 쓰레드들을 어떤 코어에 할당하고, 또 어떤 순서로 스케줄 할지는 그 때 그 때 마다 상황에 맞게 바뀌기 때문에 그 결과를 정확히 예측할 수 없다.

아무튼 쓰레드 작동중! 메세지를 통해 그때 그때 어떠한 쓰레드의 코드가 출력되는지 짐작할 수 있다.
```cpp
t1.join();
t2.join();
t3.join();
```
마지막으로 `join`은, 해당하는 쓰레드들이 실행을 종료하면 리턴하는 함수이다. 따라서 `t1.join()`의 경우 `t1`이 종료하기 전 까지 리턴하지 않는다.

그렇다면 만약에 `t2` 가 `t1` 보다 먼저 종료된다면 어떨까? 상관 없다. `t1.join()`이 끝나고 `t2.join()`을 했을 때 쓰레드 `t2`가 이미 종료된 상태라면 바로 함수가 리턴하게 된다.

그렇다면 만약에 `join`을 하지 않는다면 어떻게 될까?
```cpp
#include <iostream>
#include <thread>
using std::thread;

void func1() {
	for (int i = 0; i < 10; i++) {
		std::cout << "쓰레드 1 작동중! \n";
	}
}

void func2() {
	for (int i = 0; i < 10; i++) {
		std::cout << "쓰레드 2 작동중! \n";
	}
}

void func3() {
	for (int i = 0; i < 10; i++) {
		std::cout << "쓰레드 3 작동중! \n";
	}
}
int main() {
	thread t1(func1);
	thread t2(func2);
	thread t3(func3);
}
```
성공적으로 컴파일했다면
```
terminate called without an active exception
쓰레드 2 작동중! 
[1]    1871 abort (core dumped)  ./test
```
와 같이 나온다. 일단, 보다시피 쓰레드들의 내용이 채 실행되기 전에 `main`함수가 종료되어서 쓰레드 객체들 (`t1, t2, t3`)의 소멸자가 호출되었음을 알 수 있다.

C++ 표준에 따르면, `join`되거나 `detach`되지 않는 쓰레드들의 소멸자가 호출된다면 예외를 발생시키도록 명시되어 있다. 따라서, 우리의 쓰레드 객체들이 `join`이나 `detach`모두 되지 않았으므로 위와 같은 문제가 발생하게 된다.

그렇다면 `detach`가 무엇일까? `detach`는 말 그대로, 해당 쓰레드를 실행 시킨 후, 잊어버리는 것이라 생각하면 된다. 대신 쓰레드는 알아서 백그라운드에서 돌아가게 된다. 아래 예제를 통해 살펴보자.
```cpp
#include <iostream>
#include <thread>
using std::thread;

void func1() {
	for (int i = 0; i < 10; i++) {
		std::cout << "쓰레드 1 작동중! \n";
	}
}

void func2() {
	for (int i = 0; i < 10; i++) {
		std::cout << "쓰레드 2 작동중! \n";
	}
}

void func3() {
	for (int i = 0; i < 10; i++) {
		std::cout << "쓰레드 3 작동중! \n";
	}
}
int main() {
	thread t1(func1);
	thread t2(func2);
	thread t3(func3);
	
	t1.detach();
	t2.detach();
	t3.detach();
	
	std::cout << "메인 함수 종료 \n";
}
```
성공적으로 컴파일했다면
```
메인 함수 종료
```
혹은
```
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
메인 함수 종료 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중!
```
등등 여러가지 결과가 나온다.

**기본적으로 프로세스가 종료될 때, 해당 프로세스 안에 있는 모든 쓰레드들은 종료 여부와 상관없이 자동으로 종료된다**. 즉 `main`함수에서 메인 함수 종료! 를 출력하고, 프로세스가 종료하게 되면, `func1, func2, func3`모두 더 이상 쓰레드 작동중! 을 출력할 수 없게 된다.

먼저 첫번째 출력 결과가 왜 저런 식으로 나왔는지 생각해보자. 쓰레드를 `detach`하게 된다면 `main`함수에서는 더 이상 쓰레드들이 종료될 때까지 기다리지 않는다.

따라서
```cpp
t1.detach();
t2.detach();
t3.detach();

std::cout << "메인 함수 종료 \n";
```
위 부분이 그냥 쭈르륵 실행되어서 쓰레드들이 채 문자열을 표시하기도 전에 프로세스가 종료된 것이지요.

반면에 후자의 경우에는 프로세스가 종료되기 전에 운이 좋게도 생성된 쓰레드들에서 적당히 메세지를 출력하고 프로세스가 종료되었다. 그래도 쓰레드 1의 경우 메세지를 3개 밖에 작성하지 못하고 종료된 것을 볼 수 있다.

## 쓰레드에 인자 전달하기
이번에는는 이전에 이야기한 1부터 10000까지의 합을 여러 쓰레드들을 소환해서 빠르게 계산하는 방법을 살펴보도록 하자.
```cpp
#include <cstdio>
#include <iostream>
#include <thread>
#include <vector>
using std::thread;
using std::vector;

void worker(vector<int>::iterator start, vector<int>::iterator end, int* result) {
	int sum = 0;
	for (auto itr = start; itr < end; ++itr) {
		sum += *itr;
	}
	*result = sum;
	
	// 쓰레드의 id 를 구한다.
	thread::id this_id = std::this_thread::get_id();
	printf("쓰레드 %x 에서 %d 부터 %d 까지 계산한 결과 : %d \n", this_id, *start,
		 *(end - 1), sum);
}

int main() {
	vector<int> data(10000);
	for (int i = 0; i < 10000; i++) {
		data[i] = i;
	}
	
	// 각 쓰레드에서 계산된 부분 합들을 저장하는 벡터
	vector<int> partial_sums(4);
	
	vector<thread> workers;
	for (int i = 0; i < 4; i++) {
		workers.push_back(thread(worker, data.begin() + i * 2500,
							 data.begin() + (i + 1) * 2500, &partial_sums[i]));
	}
	
	for (int i = 0; i < 4; i++) {
		workers[i].join();
	}
	
	int total = 0;
	for (int i = 0; i < 4; i++) {
		total += partial_sums[i];
	}
	std::cout << "전체 합 : " << total << std::endl;
}
```
성공적으로 컴파일했다면
```
쓰레드 a754700 에서 0 부터 2499 까지 계산한 결과 : 3123750 
쓰레드 9752700 에서 5000 부터 7499 까지 계산한 결과 : 15623750 
쓰레드 9f53700 에서 2500 부터 4999 까지 계산한 결과 : 9373750 
쓰레드 8f51700 에서 7500 부터 9999 까지 계산한 결과 : 21873750
전체 합 : 49995000
```

```cpp
void worker(vector<int>::iterator start, vector<int>::iterator end, int* result);
```
먼저 `worker`함수는 덧셈을 수행할 데이터의 시작점과 끝점을 받아서 해당 범위 내의 원소들을 모두 더한 후, 그 결과를 `result`에 저장하게 된다.

참고로 쓰레드는 리턴값이란 것이 없기 때문에 만일 어떠한 결과를 반환하고 싶다면 포인터의 형태로 전달하면 된다.

```cpp
vector<thread> workers;
for (int i = 0; i < 4; i++) {
	workers.push_back(thread(worker, data.begin() + i * 2500,
						   data.begin() + (i + 1) * 2500, &partial_sums[i]));
}
```
다음에 `main`함수 안에서 각 쓰레드에게 임무를 할당하고 있는 모습이다. 보다시피, 각 `worker`들이 덧셈을 수행해야 할 범위는 `data.begin() + i * 2500, data.begin() + (i + 1) * 2500`임을 알 수 있다. 즉, 첫 번째 쓰레드는 0부터 2499까지, 두 번째 쓰레드는 2500부터 4999까지 쭈르륵 할당하게 된다.

쓰레드를 생성할 때 함수에 인자들을 전달하는 방법은 매우 간단하다. 우리가 이전에 `std::bind`를 사용했던 방법을 떠올리면 된다.
```cpp
thread(worker, data.begin() + i * 2500, data.begin() + (i + 1) * 2500, &partial_sums[i])
```
`thread`생성자의 첫번째 인자로 함수(정확히는 `Callable` 은 다 된다)를 전달하고, 이어서 해당 함수에 전달할 인자들을 쭈르륵 써주면 된다.

자 이제 그렇다면
```cpp
int sum = 0;
for (auto itr = start; itr < end; ++itr) {
	sum += *itr;
}
*result = sum;
```
실제로 `worker`함수의 내부를 보면 정확히 해당 범위의 원소들의 덧셈을 수행하고 있음을 알 수 있다.

```cpp
thread::id this_id = std::this_thread::get_id();
```
각 쓰레드에는 고유 아이디 번호가 할당된다. 만약에 우리가 지금 어떤 쓰레드에서 작업 중인지 보고 싶다면 `this_thread::get_id`함수를 통해서 현재 내가 돌아가고 있는 쓰레드의 아이디를 알 수 있다.

```cpp
printf("쓰레드 %x 에서 %d 부터 %d 까지 계산한 결과 : %d \n", this_id, *start, *(end - 1), sum);
```
그리고 마지막으로 [printf](https://modoocode.com/35) 함수를 통해 부분합 결과를 출력해주고 있다.

여기서 한 가지 궁금한 점이 있습니다. 왜 난데없이 [printf](https://modoocode.com/35) 함수를 사용했을까?
한 번 위 출력 부분을 그대로 `std::cout`으로 바꿔서 실행해보도록 하자.
```cpp
std::cout << "쓰레드 " << hex << this_id << " 에서 " << dec << *start << " 부터 "
     << *(end - 1) << " 까지 계산한 결과 : " << sum << std::endl;
```
로 치환해서 실행한다면 아래와 같이 나온다.
```
쓰레드 쓰레드 쓰레드 쓰레드 7f2d6ea5c700 에서 7f2d6f25d700 에서 7f2d6fa5e70075005000 에서  부터  부터 2500 부터 4999 까지 계산한 결과 : 93737509999 까지 계산한 결과 : 218737507499 까지 계산한 결과 : 156237507f2d7025f700 에서 
0 부터 2499 까지 계산한 결과 : 3123750


전체 합 : 49995000
```
왜 이런일이 발생했을까? 한 번 컴퓨터라고 생각하고 위 `std::cout`명령을 실행한다고 생각해보자. 만약에 `std::cout << "쓰레드 "`까지 딱 실행했는데 운영체제가 갑자기 다른 쓰레드를 실행시키면 어떨까? 그렇다면 화면에는 쓰레드만 딱 나오고 그 뒤로 다른 쓰레드의 메세지가 표시될 것이다.

따라서 위와 같이 `std::cout`의 `<<` 실행하는 과정 중간 중간에 계속 실행되는 쓰레드들이 바뀌면서 결과적으로 메세지가 뒤섞여서 나타나게 된다.

`std::cout`의 경우 `std::cout << A;`를 하게 된다면 **A의 내용이 출력되는 동안 중간에 다른 쓰레드가 내용을 출력할 수 없게 보장해준다**(그 사이에 컨텍스트 스위치가 되더라도). 하지만 `std::cout << A << B;`를 하게 되면 `A`를 출력한 이후에 `B`를 출력하기 전에 다른 쓰레드가 내용을 출력할 수 있다.

반면에 [printf](https://modoocode.com/35)는 조금 다르다. [printf](https://modoocode.com/35)는 `"..."` 안에 있는 문자열을 출력할 때, 컨텍스트 스위치가 되더라도 다른 쓰레드들이 그 사이에 메세지를 집어넣지 못하게 막는다(자세한 내용은 여기 [참고](https://stackoverflow.com/questions/23586682/how-to-use-printf-in-multiple-threads))

따라서, 방해 받지 않고 전체 메세지를 제대로 출력할 수 있게 해준다.

```cpp
for (int i = 0; i < 4; i++) {
	workers[i].join();
}

int total = 0;
for (int i = 0; i < 4; i++) {
	total += partial_sums[i];
}
```
마지막으로 `main`함수에서 위와 같이 모든 쓰레드들이 종료될 때 까지 기다린다. 각 쓰레드에서 계산한 결과는 `partial_sums`의 각 원소들에 저장되어 있다.

모든 쓰레드에서 연산이 끝난 후에, 최종적으로 `main` 함수에서 부분합들을 모두 더해서 최종 결과를 얻을 수 있다.

앞에서도 이야기 했지만 쓰레드들은 서로 메모리를 공유한다고 했다. 실제로 각 쓰레드들에서 `data`와 `partial_sums`에 (다른 부분이긴 했지만) 서로 접근할 수 있었다.

그렇다면 여기서 궁금한게 생긴다. 만약에, 서로 다른 쓰레드들이, 같은 메모리에 서로 접근하고 데이터를 쓴다면 어떠한 일이 발생할까?

## 메모리를 같이 접근한다면?

아래 예제는 서로 다른 쓰레드들에서 `counter`라는 변수의 값을 1씩 계속 증가시키는 연산을 수행한다.
```cpp
#include <iostream>
#include <thread>
#include <vector>
using std::thread;
using std::vector;

void worker(int& counter) {
  for (int i = 0; i < 10000; i++) {
    counter += 1;
  }
}

int main() {
  int counter = 0;

  vector<thread> workers;
  for (int i = 0; i < 4; i++) {
    // 레퍼런스로 전달하려면 ref 함수로 감싸야 한다 (지난 강좌 bind 함수 참조)
    workers.push_back(thread(worker, std::ref(counter)));
  }

  for (int i = 0; i < 4; i++) {
    workers[i].join();
  }

  std::cout << "Counter 최종 값 : " << counter << std::endl;
}
```
성공적으로 컴파일했다면
```
Counter 최종 값 : 26459
```

> 참고로 컴파일러 최적화를 키면, 위 for 문을 그냥 counter += 10000; 으로 대체해버리는 경우도 있으니, 정확한 효과를 보기 위해서는 컴파일러 최적화 옵션을 꺼야한다.

흠 결과가 조금 이상하다. 분명히 각 쓰레드에서 10000씩 더했기 때문에 정상적인 상황이였다면 40000이 출력되어야 했을 것이다. 그런데, 모든 쓰레드들이 종료되고 최종적으로 `Counter`에 써진 값은 26459가 되었다.
```cpp
for (int i = 0; i < 10000; i++) {
	counter += 1;
}
```
이 부분을 살펴보자. 틀림없이 `counter`에 1을 10000번 더하는 코드이다. 그렇다면 `counter += 1`이 문제였을까?

## Race Condition

위에서 서로 다른 쓰레드에서 같은 메모리를 공유할 때 발생할 수 있는 문제를 보았다. 이와 같이 서로 다른 쓰레드들이 동일한 자원을 사용할 때 발생하는 문제를 **경쟁 상태(race condtion)** 라 부른다. 이 경우 `counter`라는 변수에 race condtion이 있었다.

왜 그런 문제가 발생했을까?
```cpp
counter += 1;
```
문제는 위 명령에 있다. 컴퓨터에 입장에서 생각해보자. `counter += 1;`을 하기 위해서는 어떠한 과정이 필요할까?

이를 이해하기 위해서는 CPU에서 연산을 어떻게 처리하는지 알아야한다.

### CPU 간단 소개

CPU는 말했듯이 컴퓨터의 모든 연산이 발생하는 두뇌 라고 볼 수 있다. CPU에서 연산을 수행하기 위해서는, **CPU의 레지스터(register)라는 곳에 데이터를 기록한 다음에 연산을 수행해야 한다**.

레지스터의 크기는 매우 작다. 64비트 컴퓨터의 경우, 레지스터의 크기들이 **8바이트**에 비해 불과하다. 뿐만 아니라 레지스터의 개수는 그리 많지 않다. **일반적인 연산에서 사용되는 범용 레지스터의 경우 불과 16개 밖에 없다**.

> 32비트 시절에는 8개 밖에 없었지만, x86-64로 넘어오면서 8개가 추가되어 총 16개가 되었다.

![[14.2.1.webp]]
> 메인보드를 보면 CPU바로 옆에 메모리가 있다

즉, 모든 데이터들은 메모리에 저장되어 있고, 연산을 할 때 마다 메모리에서 레지스터로 값을 가져온 뒤에, 빠르게 연산을 하고, 다시 메모리에 가져다 놓는 식으로 작동을 한다고 보면 된다.

쉽게 말하자면, 메모리는 냉장고이고 CPU의 레지스터는 도마라고 보면 된다. 냉장고(RAM)에서 재료를 도마(레지스터) 위에 하나 꺼내서 후다닥 썰고(연산) 다시 냉장고로 가져다 놓는 거라 생각하면 된다.

그렇다면 `counter += 1`이 실제로 어떠한 코드로 컴파일되는지 살펴보자.
```asm
mov rax, qword ptr [rbp - 8]
mov ecx, dword ptr [rax]
add ecx, 1
mov dword ptr [rax], ecx
```
흠, 조금 무섭게 생겼다. 위와 같은 코드를 **어셈블리(Assembly)** 코드라고 부른다. 어셈블리 코드는 CPU가 실제로 실행하는 기계어와 1 대 1 대응이 되어 있다. 따라서, 위 명령을 한줄 한줄 CPU가 처리한다고 생각해도 무방하다.

이해하기 매우 어렵게 생겼지만 사실 하나씩 뜯어보면 크게 어렵지 않다. 먼저 첫번째 줄 부터 살펴보자.
```asm
mov rax, qword ptr [rbp - 8]
```
`rax` 와 `rbp` 모두 CPU의 레지스터를 의미한다. [mov](https://modoocode.com/mov_1)는 이 문장이 어떤 명령을 하는지 나타내는데, 이름에서도 짐직할 수 있듯이 대입(move) 명령이다. 즉, `[rbp - 8]` 이 `rax` 에 대입된다.

이 때 `[]` 의 의미는 역참조, 즉 `rbp - 8` 을 주소값이라 생각했을 때 '해당 주소에 있는 값을 읽어라'라는 의미가 되겠다. C++ 에서 포인터에 `*` 연산을 하는 것과 동일하다. 그런데, 이 때 값을 읽기 위해 해당 주소부터 얼마나 읽어야 하는지 명시해야한다. 이는 `qword`라는 단어에서 알 수 있는데, `qword`는 8바이트를 의미한다(주소값의 크기가 8바이트).

즉, C++ 의 언어로 풀어 쓰자면
```cpp
rax = *(int**)(rbp - 8)
```
가 되겠다.

실제로 위 명령에서 무슨 짓을 하고 있는 것이냐면 현재 `rbp - 8`에는 `counter`의 주소값이 담겨 있어서 `rax`에 `counter`의 주소값을 복사하고 있는 과정이다. 그렇다면 그 아래 문장이 바로 이해가 될 것이다.
```asm
mov ecx, dword ptr [rax]
```
현재 `rax`에는 `result`의 주소값이 담겨 있다. 따라서 `ecx`에는 `result`의 현재 값이 들어가게 된다. 위 문장은
```cpp
ecx = *(int*)(rax);  // rax 에는 &result 가 들어가 있음
```
와 동일하다.

자 이제 그 다음 문장이다.
```asm
add ecx, 1
```
언뜻 봐도 알 수 있듯이 `ecx`에 1 을 더하는 명령이다. 즉, `result`에 1 이 더해진다.
```asm
mov dword ptr [rax], ecx
```
마지막으로 `result`에 이전의 `result`에 1 이 더해진 값이 저장된다.

참고로 `ecx` 없이
```asm
mov rax, qword ptr [rbp - 8]
mov dword ptr [rax], 1
```
이렇게 하면 안되냐고 생각할 수 있는데, 이는 CPU의 구조상 [add](https://modoocode.com/add)명령은 역참조한 메모리에서 직접 사용할 수 없고 반드시 레지스터에만 내릴 수 있다(냉장고 안에서 직접 요리를 할 수 없으니까!).

자 그러면, 왜 이제 `counter`의 값이 이상하게 나왔는지 짐작할 수 있을까?
![[Pasted image 20241012205209.png]]
위 그림과 같은 상황을 생각해보자. 처음에 `counter`가 0이었다고 가정하고, 쓰레드 1에서
```asm
mov rax, qword ptr [rbp - 8]
mov ecx, dword ptr [rax]
```
딱 여기까지 실행했다고 생각해보자. 그러면 이 시점에서 쓰레드 1의 `ecx`레지스터에는 `counter`의 초기값인 0 이 들어가게 된다.

다음에 쓰레드 2에서 전체 명령을 모두 실행한다. 현재 쓰레드 1이 `counter`의 값을 바꾸지 않은 상태이기 때문에 쓰레드 2에서 읽은 `counter`의 값도 역시 0이다. 따라서 쓰레드 2가 `counter += 1`을 마쳤을 때에는 `counter`에는 1 이 들어가 있을 것이다.

> 참고로 각 쓰레드는 메모리를 공유할 지언정, 레지스터는 공유하지 않는다. 따라서 각 쓰레드 별로 고유의 레지스터들을 가지고 있다고 생각해도 된다. 즉, 쓰레드 1의 ecx 와 쓰레드 2의 ecx 는 서로 다르다고 보면 된다.

다시 쓰레드 1의 차례이다. 쓰레드 1에서 나머지
```asm
add ecx, 1
mov dword ptr [rax], ecx
```
부분을 실행했다. 이 때 쓰레드 1의 `ecx` 는 0이었으므로, `add ecx, 1`후에 `ecx`역시 1이 된다. 결국 `counter`에는 2가 아닌 1이 기록된다.

물론 운이 좋다면 쓰레드 1에서 중간에 쓰레드 2가 실행되는 일 없이 쭉 실행해서 정상적으로 `counter`에 2가 들어갔을 수도 있다. 하지만, 쓰레드를 어떻게 스케쥴링 할지는 운영체제가 마음대로 결정하는 것이기 때문에 우리는 그런 행운을 항상 바랄 수 없습니다.

이게 멀티쓰레딩의 재밌는 점입니다. 여태까지 여러분이 실행한 모든 프로그램은 몇 번을 실행 하건 결과가 동일하게 나왔습니다. 하지만, 멀티 쓰레드 프로그램의 경우 프로그램 실행 마다 그 결과가 달라질 수 있습니다.

이게 무슨 말일까요? 제대로 프로그램을 만들지 않았을 경우 디버깅이 겁나 어렵다는 뜻입니다.
## 멀티스레드 프로그램

프로세스란, 운영체제에서 실행되는 프로그램의 최소 단위라고 보면 된다. 즉, 우리가 1개의 프로그램을 가리킬 때 보통 1개의 프로세스를 의미하는 경우가 많다.

> 물론 구글 크롬처럼 한 개의 탭이 한 개의 프로세스를 차지해서, 프로그램 자체가 여러개의 프로세스로 이루어진 경우도 있다.

그렇다면 이 프로세스들은 어디에서 실행될까? 바로 컴퓨터의 두뇌라 하는 CPU 의 코어 (연산하는 부분)에서 실행되고 있다. 옛날 (2005년 이전)에는 서버용이 아닌 일반 소비자용 CPU 의 경우 1개의 코어를 가지는 것이 대부분이었다(대표적으로 펜티엄 4가 있다). 이 말은 즉, CPU가 한 번에 한 개의 연산을 수행한다는 것이다.

근데 CPU가 한 번에 한 가지 연산 밖에 못한다면, 도대체 그 시절에는 인터넷을 하면서 음악을 듣고, 아니면 게임을 하는 등 여러가지 일들을 어떻게 한꺼번에 했을까? 그 비밀은 **컨텍스트 스위칭(Context switching)** 이라는 기술에 숨어 있다.

컴퓨터에서 프로그램이 실행될 때 겉으로 보기에는 프로그램이 연속적으로 쭈르륵 작동하는 것처럼 보이지만 실제로는 그렇지 않다. 아래 그림을 보면 CPU 코어 하나에서 프로그램들이 어떻게 실행되는지 알 수 있다.
![[14.1.4.webp]]
보다시피, 프로그램 하나가 쭈르륵 작동하는 것이 아니라, 프로그램 하나가 잠시 실행되었다가, 다른 프로그램으로 스위칭 되는 것을 볼 수 있다. 즉, CPU는 한 프로그램을 통째로 쭉 실행시키는 것이 아니라, 이 프로그램 조금, 저 프로그램 조금씩 골라서 차례를 돌며 실행시킨다는 것을 알 수 있다.

정확히 말하자면, CPU는 그냥 운영체제가 처리하라고 시키는 명령어들을 실행할 뿐, 어떤 프로그램을 실행시키고, 얼마 동안 실행시키고, 또 다음에 무슨 프로그램으로 스위치 할지는 운영체제의 **스케쥴러(scheduler)** 가 알아서 결정하게 됩니다.

### 쓰레드

이 CPU 코어에서 돌아가는 프로그램 단위를 **쓰레드 (thread)** 라고 부른다. 즉, **CPU 의 코어 하나에서는 한 번에 한 개의 쓰레드의 명령을 실행시키게 된다**.

한 개의 프로세스는 최소 한 개 쓰레드로 이루어져 있으며, 여러 개의 쓰레드로 구성될 수 있게 된다. 이렇게 여러 개의 쓰레드로 구성된 프로그램을 멀티 쓰레드(multithread) 프로그램이라 한다.

쓰레드와 프로세스의 가장 큰 차이점은 메모리 공유이다. 프로세스들은 서로 메모리를 공유하지 않는다. 다시 말해, 프로세스 1과 프로세스 2가 있을 때, 프로세스 1은 프로세스 2의 메모리에 접근할 수 없고, 마찬가지로 프로세스 2도 프로세스 1의 메모리에 접근할 수 없다.
![[14.1.6.webp]]
하지만 쓰레드의 경우는 다르다. 만일 한 프로세스 안에 쓰레드 1과 쓰레드 2가 있다면, 서로 같은 메모리를 공유하게 된다. 예컨대, 쓰레드 1과 쓰레드 2가 같은 변수의 값에 접근할 수 있다.

여태까지 작성했던 프로그램들은 모두 한 개의 쓰레드로 구성된 싱글 쓰레드 프로그램이다. 하지만, 많은 프로그램들이 멀티쓰레드 프로그램으로 구성되어 있는데, 맥에서 나오는 작업관리자 사진의 우측 하단에, 현재 시스템의 쓰레드 개수와 프로세스에서도 알 수 있듯이, 프로세스 개수는 348개 인데, 총 쓰레드 수는 1711개로 써있다. 대량 프로세스 하나 당 5개의 쓰레드들로 구성되어 있다고 생각하면 될 것이다.
![[14.1.1.webp]]

## CPU 의 코어는 한 개가 아니다.

요 근래 들어서는 CPU 의 발전 방향이 코어 하나의 동작 속도를 높이기 보다는, CPU 에 장착된 코어 개수를 늘려가는 식으로 발전해왔다.

예를 들어서 인텔의 i5 모델의 경우 4개의 코어가 장착되어 있다. AMD 의 라이젠 모델의 경우 아래 그림과 같이 8개의 코어를 가지고 있다. 참고로 SMT 라는 기술을 통해서 마치 16개의 코어인 것처럼 보이지만 하단에 Cores를 보면 실제로는 8개의 코어만 있다는 점을 확인할 수 있다.
![[14.1.3.webp]]
그렇다면 실제 이 8개의 코어에서 프로그램이 실행되는 모습은 아래와 같을 것이다.
![[14.1.5.webp]]
따라서 이전에 싱글 코어 CPU에서 아무리 멀티 쓰레드 프로그램이라 하더라도 결국에는 한 번에 한 쓰레드만 실행할 수 있었겠지만, 멀티코어 CPU 에서는 여러 개의 코어에 각기 다른 쓰레드들이 들어가 동시에 여러 개의 쓰레드들을 효율적으로 실행할 수 있다.

## 그래서 왜 멀티 쓰레드 인데?

앞서 현대의 CPU 가 여러 개의 코어를 지원함으로써 여러 개의 쓰레드를 동시에 실행시킬 수 있다고 했다. 그렇다면 어떨 때 프로그램을 멀티쓰레드로 만드는 것이 유리할까? 이에 대해 크게 두 가지 이유를 생각할 수 있다.

### 병렬 가능한 (Parallelizable) 작업들

예를 들어서 1부터 10000까지 더하는 작업을 생각해보자. 만약에 단일 쓰레드 프로그램으로 짠다면 단순히 `for`문으로 1부터 10000까지 더하는 코드를 쓰면 된다.

반면에 이를 쓰레드 10개로 만든다면 어떨까. 예를 들어, 쓰레드 1에서 1부터 1000까지 더하고, 쓰레드 2에서 1001부터, 2000까지 더하고, ... 쓰레드 10에서 9001부터 10000까지 더하게 한다면 어떨까? 모든 쓰레드의 작업이 완료된 후에, 각각의 결과를 합치는 식으로 말이다.
![[Pasted image 20241011135033.png]]
CPU 코어에서 덧셈 한 번에 1초가 걸린다고 가정해보자. 그렇다면 단일 쓰레드의 경우 10000초가 걸리게 된다.

하지만, 멀티쓰레드를 사용하였을 경우 CPU 에 코어가 10개가 있어서 각 쓰레드들이 동시에 실행될 수만 있다면, 각 쓰레드에서 덧셈은 1000초가 걸리고, 마지막으로 다 합칠 때 10초가 걸려서 총 1010초가 걸리게 된다.

싱글쓰레드의 경우보다 속도가 무려 10배가 향상된 수치이다!

이렇게, 어떠한 작업을 여러 개의 다른 쓰레드를 이용해서 좀 더 빠르게 수행하는 것을 **병렬화(parallelize)** 라고 한다. 하지만 모든 작업들이 이렇게 병렬화가 가능한 것이 아니다. 예를 들어서 피보나치 수열을 계산하는 프로그램을 생각해보자. 아마 아래와 같이 작성할 것이다.
```cpp
int main() {
	int bef = 1, cur = 1;
	
	// 물론 100 번째 피보나치 항을 구한다면, int 오버플로우가 나겠지만 일단 그 점은 여기서 무시하도록 하자.
	for (int i = 0; i < 98; i++) {
		int temp = cur;
		cur = cur + bef;
		bef = temp;
	}
	std::cout << "F100 : " << cur << std::endl;
}
```
위와 같은 프로그램을 여러 쓰레드를 사용하는 방식으로 실행 속도를 높일 수 있을까?

피보나치의 $n$ 번째 항인 $F_n$ 을 계산하기 위해서는 $F_{n−1}$과 $F_{n−2}$을 알아야 한다. 다시 말해 $F_3$을 구하기 위해서는 $F_1$​과 $F_2$를 알아야 하고, $F_4$를 구하기 위해서는 $F_3$과 $F_2$를 알아야 한다.

예를 들어서 $F_3$을 쓰레드 1, $F_4$를 쓰레드 2에서 계산한다고 생각해보자. 쓰레드 2가 값을 계산하기 위해서는 $F_3$의 값이 필요하다. 그런데, $F_3$은 쓰레드 1에서 계산되고 있으므로, 쓰레드 1의 연산이 끝날 때 까지 쓰레드 2가 기다려야 한다. 따라서 최종 실행 속도는 그냥 쓰레드 1에서 $F_3$과 $F_4$모두를 계산하는 것과 차이가 없게 된다.

결과적으로 이와 같은 방법으로 피보나치 수열을 계산하는 프로그램은 병렬화 하는 것이 매우 까다롭다. 이러한 문제가 발생하는 근본적인 이유는 **어떠한 연산 (연산 A) 을 수행하기 위해 다른 연산 (연산 B)의 결과가 필요하기 때문**이라 볼 수 있다. 이와 같은 상황을 **A 가 B 에 의존(dependent)한다** 라고 한다.

프로그램 논리 구조 상에서 연산들 간의 의존 관계가 많을 수록 병렬화가 어려워지고, 반대로, 다른 연산의 결과와 관계없이 독립적으로 수행할 수 있는 구조가 많을 수록 병렬화가 매우 쉬워진다.

### 대기시간이 긴 작업들

인터넷에서 웹사이트들을 긁어 모으는 프로그램을 생각해보자. 아마 아래와 같이 구성할 수 있을 것이다.
```cpp
int main() {
	// 다운 받으려는 웹사이트와 내용을 저장하는 맵
	map<string, string> url_and_content;
	for (auto itr = url_and_content.begin(); itr != url_and_content.end();
	   ++itr) {
		const string& url = itr->first;
		
		// download 함수는 인자로 전달받은 url 에 있는 사이트를 다운받아 리턴한다.
		itr->second = download(url);
	}
}
```
이 임의로 만든 `download` 함수는 인자로 전달한 `url` 에 위치한 웹사이트를 다운 받아서 리턴한다.

문제는 우리의 CPU 의 처리 속도에 비해 인터넷은 매우 느리다는 점이다.

우리가 흔히 `ping`이라고 부르는 것은, 내가 보낸 요청이 상대 서버에 도착해서 다시 나에게 돌아오는데 걸리는 시간을 의미한다. 보통 우리나라 안에서 웹사이트에 요청을 보낼 시에 `ping`이 `30`밀리초 정도 나오고, 해외의 경우 (예컨대 미국), `150`밀리초에서 멀면 `300`밀리초 까지 걸리게 된다.

> 이 시간은 웹사이트 전체를 다운 받는데 걸리는 시간을 말하는 것이 아니다. 내가 다운로드 요청을 보내서, 첫 번째 응답이 돌아올 때 까지 걸리는 시간을 말한다.

`150`밀리초라 한다면 사람 기준에서 얼마 안되는 시간처럼 보인다. `0.15`초 이기 때문이다. 하지만, 실제로 컴퓨터는 `0.15`초 동안 정말 많은 일들을 할 수 있다. 보통의 CPU는 1초에 109109번 연산을 할 수 있기 때문에 `0.15`초 동안 응답을 단순히 기다리기만 한다면, 1.5×1081.5×108번 연산을 수행할 수 있는 시간을 버리게 되는 것이다. 즉 CPU코어를 비효율적으로 사용하게 되는 셈이다. 한창 일해야될 CPU 를 놀게 놔둔다니!
![[14.1.8.webp]]

하지만 만일 `download` 함수를 호출하는 것을 여러 쓰레드에서 부르면 어떨까요?
![[14.1.9.webp]]
위 그림은 같은 코어 안에서 쓰레드들이 컨텍스트 스위칭을 통해 기다리는 시간 없이 CPU를 최대한으로 사용하는 것을 볼 수 있다. 초록색 쓰레드에서 웹사이트 1에 요청을 보낸 후, 이전에는 웹사이트 1에서 데이터를 다운로드를 시작하기까지 기다려야 했지만, 이 경우 빨간색 쓰레드로 컨텍스트 스위칭 되어서, 기다리는 시간을 낭비하지 않고 바로 웹사이트 2에 요청을 보내는 것을 볼 수 있다.

위와 같이 처리하게 된다면 CPU 시간을 낭비하지 않고 효율적으로 작업을 처리할 수 있게 된다.

## C++ 에서 쓰레드 생성하기

이전에는 C++ 표준에 쓰레드가 없어서, 각 플랫폼 마다 다른 구현을 사용해야만 했다. (예를 들어서 윈도우즈에서는 `CreateThread` 로 쓰레드를 만들지만 리눅스에서는 `pthread_create` 로 만든다)

하지만 `C++ 11` 에서부터 표준에 쓰레드가 추가되면서, 쓰레드 사용이 매우 편리해졌다.

이제 첫 번째 멀티 쓰레드 프로그램을 만들어보자.
```cpp
#include <iostream>
#include <thread>
using std::thread;

void func1() {
	for (int i = 0; i < 10; i++) {

	}
}
```
성공적으로 컴파일했다면
```
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 1 작동중! 
쓰레드 3 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중!
```

`C++ 11` 에서 쓰레드를 생성하는 방법은 매우 간단하다.
```cpp
#include <thread>
```
일단 위 처럼 `thread` 헤더파일을 추가하고,
```cpp
thread t1(func1);
```
`thread` 객체를 생성하는 순간 끝이다. 이렇게 생성된 `t1`은 인자로 전달받은 함수 `func1`을 새로운 쓰레드에서 실행하게 된다.

즉
```cpp
thread t1(func1);
thread t2(func2);
thread t3(func3);
```
를 실행하게 되면, `func1, func2, func3` 가 각기 다른 쓰레드 상에서 실행되게 된다.
![[14.1.10.webp]]
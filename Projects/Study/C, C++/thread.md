## 멀티스레드 프로그램

프로세스란, 운영체제에서 실행되는 프로그램의 최소 단위라고 보면 된다. 즉, 우리가 1개의 프로그램을 가리킬 때 보통 1개의 프로세스를 의미하는 경우가 많다.

> 물론 구글 크롬처럼 한 개의 탭이 한 개의 프로세스를 차지해서, 프로그램 자체가 여러개의 프로세스로 이루어진 경우도 있다.

그렇다면 이 프로세스들은 어디에서 실행될까? 바로 컴퓨터의 두뇌라 하는 CPU 의 코어 (연산하는 부분)에서 실행되고 있다. 옛날 (2005년 이전)에는 서버용이 아닌 일반 소비자용 CPU 의 경우 1개의 코어를 가지는 것이 대부분이었다(대표적으로 펜티엄 4가 있다). 이 말은 즉, CPU가 한 번에 한 개의 연산을 수행한다는 것이다.

근데 CPU가 한 번에 한 가지 연산 밖에 못한다면, 도대체 그 시절에는 인터넷을 하면서 음악을 듣고, 아니면 게임을 하는 등 여러가지 일들을 어떻게 한꺼번에 했을까? 그 비밀은 **컨텍스트 스위칭(Context switching)** 이라는 기술에 숨어 있다.

컴퓨터에서 프로그램이 실행될 때 겉으로 보기에는 프로그램이 연속적으로 쭈르륵 작동하는 것처럼 보이지만 실제로는 그렇지 않다. 아래 그림을 보면 CPU 코어 하나에서 프로그램들이 어떻게 실행되는지 알 수 있다.
![[14.1.4.webp]]
보다시피, 프로그램 하나가 쭈르륵 작동하는 것이 아니라, 프로그램 하나가 잠시 실행되었다가, 다른 프로그램으로 스위칭 되는 것을 볼 수 있다. 즉, CPU는 한 프로그램을 통째로 쭉 실행시키는 것이 아니라, 이 프로그램 조금, 저 프로그램 조금씩 골라서 차례를 돌며 실행시킨다는 것을 알 수 있다.

정확히 말하자면, CPU는 그냥 운영체제가 처리하라고 시키는 명령어들을 실행할 뿐, 어떤 프로그램을 실행시키고, 얼마 동안 실행시키고, 또 다음에 무슨 프로그램으로 스위치 할지는 운영체제의 **스케쥴러(scheduler)** 가 알아서 결정하게 됩니다.

### 쓰레드

이 CPU 코어에서 돌아가는 프로그램 단위를 **쓰레드 (thread)** 라고 부른다. 즉, **CPU 의 코어 하나에서는 한 번에 한 개의 쓰레드의 명령을 실행시키게 된다**.

한 개의 프로세스는 최소 한 개 쓰레드로 이루어져 있으며, 여러 개의 쓰레드로 구성될 수 있게 된다. 이렇게 여러 개의 쓰레드로 구성된 프로그램을 멀티 쓰레드(multithread) 프로그램이라 한다.

쓰레드와 프로세스의 가장 큰 차이점은 메모리 공유이다. 프로세스들은 서로 메모리를 공유하지 않는다. 다시 말해, 프로세스 1과 프로세스 2가 있을 때, 프로세스 1은 프로세스 2의 메모리에 접근할 수 없고, 마찬가지로 프로세스 2도 프로세스 1의 메모리에 접근할 수 없다.
![[14.1.6.webp]]
하지만 쓰레드의 경우는 다르다. 만일 한 프로세스 안에 쓰레드 1과 쓰레드 2가 있다면, 서로 같은 메모리를 공유하게 된다. 예컨대, 쓰레드 1과 쓰레드 2가 같은 변수의 값에 접근할 수 있다.

여태까지 작성했던 프로그램들은 모두 한 개의 쓰레드로 구성된 싱글 쓰레드 프로그램이다. 하지만, 많은 프로그램들이 멀티쓰레드 프로그램으로 구성되어 있는데, 맥에서 나오는 작업관리자 사진의 우측 하단에, 현재 시스템의 쓰레드 개수와 프로세스에서도 알 수 있듯이, 프로세스 개수는 348개 인데, 총 쓰레드 수는 1711개로 써있다. 대량 프로세스 하나 당 5개의 쓰레드들로 구성되어 있다고 생각하면 될 것이다.
![[14.1.1.webp]]

## CPU 의 코어는 한 개가 아니다.

요 근래 들어서는 CPU 의 발전 방향이 코어 하나의 동작 속도를 높이기 보다는, CPU 에 장착된 코어 개수를 늘려가는 식으로 발전해왔다.

예를 들어서 인텔의 i5 모델의 경우 4개의 코어가 장착되어 있다. AMD 의 라이젠 모델의 경우 아래 그림과 같이 8개의 코어를 가지고 있다. 참고로 SMT 라는 기술을 통해서 마치 16개의 코어인 것처럼 보이지만 하단에 Cores를 보면 실제로는 8개의 코어만 있다는 점을 확인할 수 있다.
![[14.1.3.webp]]
그렇다면 실제 이 8개의 코어에서 프로그램이 실행되는 모습은 아래와 같을 것이다.
![[14.1.5.webp]]
따라서 이전에 싱글 코어 CPU에서 아무리 멀티 쓰레드 프로그램이라 하더라도 결국에는 한 번에 한 쓰레드만 실행할 수 있었겠지만, 멀티코어 CPU 에서는 여러 개의 코어에 각기 다른 쓰레드들이 들어가 동시에 여러 개의 쓰레드들을 효율적으로 실행할 수 있다.

## 그래서 왜 멀티 쓰레드 인데?

앞서 현대의 CPU 가 여러 개의 코어를 지원함으로써 여러 개의 쓰레드를 동시에 실행시킬 수 있다고 했다. 그렇다면 어떨 때 프로그램을 멀티쓰레드로 만드는 것이 유리할까? 이에 대해 크게 두 가지 이유를 생각할 수 있다.

### 병렬 가능한 (Parallelizable) 작업들

예를 들어서 1부터 10000까지 더하는 작업을 생각해보자. 만약에 단일 쓰레드 프로그램으로 짠다면 단순히 `for`문으로 1부터 10000까지 더하는 코드를 쓰면 된다.

반면에 이를 쓰레드 10개로 만든다면 어떨까. 예를 들어, 쓰레드 1에서 1부터 1000까지 더하고, 쓰레드 2에서 1001부터, 2000까지 더하고, ... 쓰레드 10에서 9001부터 10000까지 더하게 한다면 어떨까? 모든 쓰레드의 작업이 완료된 후에, 각각의 결과를 합치는 식으로 말이다.
![[Pasted image 20241011135033.png]]
CPU 코어에서 덧셈 한 번에 1초가 걸린다고 가정해보자. 그렇다면 단일 쓰레드의 경우 10000초가 걸리게 된다.

하지만, 멀티쓰레드를 사용하였을 경우 CPU 에 코어가 10개가 있어서 각 쓰레드들이 동시에 실행될 수만 있다면, 각 쓰레드에서 덧셈은 1000초가 걸리고, 마지막으로 다 합칠 때 10초가 걸려서 총 1010초가 걸리게 된다.

싱글쓰레드의 경우보다 속도가 무려 10배가 향상된 수치이다!

이렇게, 어떠한 작업을 여러 개의 다른 쓰레드를 이용해서 좀 더 빠르게 수행하는 것을 **병렬화(parallelize)** 라고 한다. 하지만 모든 작업들이 이렇게 병렬화가 가능한 것이 아니다. 예를 들어서 피보나치 수열을 계산하는 프로그램을 생각해보자. 아마 아래와 같이 작성할 것이다.
```cpp
int main() {
	int bef = 1, cur = 1;
	
	// 물론 100 번째 피보나치 항을 구한다면, int 오버플로우가 나겠지만 일단 그 점은 여기서 무시하도록 하자.
	for (int i = 0; i < 98; i++) {
		int temp = cur;
		cur = cur + bef;
		bef = temp;
	}
	std::cout << "F100 : " << cur << std::endl;
}
```
위와 같은 프로그램을 여러 쓰레드를 사용하는 방식으로 실행 속도를 높일 수 있을까?

피보나치의 $n$ 번째 항인 $F_n$ 을 계산하기 위해서는 $F_{n−1}$과 $F_{n−2}$을 알아야 한다. 다시 말해 $F_3$을 구하기 위해서는 $F_1$​과 $F_2$를 알아야 하고, $F_4$를 구하기 위해서는 $F_3$과 $F_2$를 알아야 한다.

예를 들어서 $F_3$을 쓰레드 1, $F_4$를 쓰레드 2에서 계산한다고 생각해보자. 쓰레드 2가 값을 계산하기 위해서는 $F_3$의 값이 필요하다. 그런데, $F_3$은 쓰레드 1에서 계산되고 있으므로, 쓰레드 1의 연산이 끝날 때 까지 쓰레드 2가 기다려야 한다. 따라서 최종 실행 속도는 그냥 쓰레드 1에서 $F_3$과 $F_4$모두를 계산하는 것과 차이가 없게 된다.

결과적으로 이와 같은 방법으로 피보나치 수열을 계산하는 프로그램은 병렬화 하는 것이 매우 까다롭다. 이러한 문제가 발생하는 근본적인 이유는 **어떠한 연산 (연산 A) 을 수행하기 위해 다른 연산 (연산 B)의 결과가 필요하기 때문**이라 볼 수 있다. 이와 같은 상황을 **A 가 B 에 의존(dependent)한다** 라고 한다.

프로그램 논리 구조 상에서 연산들 간의 의존 관계가 많을 수록 병렬화가 어려워지고, 반대로, 다른 연산의 결과와 관계없이 독립적으로 수행할 수 있는 구조가 많을 수록 병렬화가 매우 쉬워진다.

### 대기시간이 긴 작업들

인터넷에서 웹사이트들을 긁어 모으는 프로그램을 생각해보자. 아마 아래와 같이 구성할 수 있을 것이다.
```cpp
int main() {
	// 다운 받으려는 웹사이트와 내용을 저장하는 맵
	map<string, string> url_and_content;
	for (auto itr = url_and_content.begin(); itr != url_and_content.end();
	   ++itr) {
		const string& url = itr->first;
		
		// download 함수는 인자로 전달받은 url 에 있는 사이트를 다운받아 리턴한다.
		itr->second = download(url);
	}
}
```
이 임의로 만든 `download` 함수는 인자로 전달한 `url` 에 위치한 웹사이트를 다운 받아서 리턴한다.

문제는 우리의 CPU 의 처리 속도에 비해 인터넷은 매우 느리다는 점이다.

우리가 흔히 `ping`이라고 부르는 것은, 내가 보낸 요청이 상대 서버에 도착해서 다시 나에게 돌아오는데 걸리는 시간을 의미한다. 보통 우리나라 안에서 웹사이트에 요청을 보낼 시에 `ping`이 `30`밀리초 정도 나오고, 해외의 경우 (예컨대 미국), `150`밀리초에서 멀면 `300`밀리초 까지 걸리게 된다.

> 이 시간은 웹사이트 전체를 다운 받는데 걸리는 시간을 말하는 것이 아니다. 내가 다운로드 요청을 보내서, 첫 번째 응답이 돌아올 때 까지 걸리는 시간을 말한다.

`150`밀리초라 한다면 사람 기준에서 얼마 안되는 시간처럼 보인다. `0.15`초 이기 때문이다. 하지만, 실제로 컴퓨터는 `0.15`초 동안 정말 많은 일들을 할 수 있다. 보통의 CPU는 1초에 109109번 연산을 할 수 있기 때문에 `0.15`초 동안 응답을 단순히 기다리기만 한다면, 1.5×1081.5×108번 연산을 수행할 수 있는 시간을 버리게 되는 것이다. 즉 CPU코어를 비효율적으로 사용하게 되는 셈이다. 한창 일해야될 CPU 를 놀게 놔둔다니!
![[14.1.8.webp]]

하지만 만일 `download` 함수를 호출하는 것을 여러 쓰레드에서 부르면 어떨까요?
![[14.1.9.webp]]
위 그림은 같은 코어 안에서 쓰레드들이 컨텍스트 스위칭을 통해 기다리는 시간 없이 CPU를 최대한으로 사용하는 것을 볼 수 있다. 초록색 쓰레드에서 웹사이트 1에 요청을 보낸 후, 이전에는 웹사이트 1에서 데이터를 다운로드를 시작하기까지 기다려야 했지만, 이 경우 빨간색 쓰레드로 컨텍스트 스위칭 되어서, 기다리는 시간을 낭비하지 않고 바로 웹사이트 2에 요청을 보내는 것을 볼 수 있다.

위와 같이 처리하게 된다면 CPU 시간을 낭비하지 않고 효율적으로 작업을 처리할 수 있게 된다.

## C++ 에서 쓰레드 생성하기

이전에는 C++ 표준에 쓰레드가 없어서, 각 플랫폼 마다 다른 구현을 사용해야만 했다. (예를 들어서 윈도우즈에서는 `CreateThread` 로 쓰레드를 만들지만 리눅스에서는 `pthread_create` 로 만든다)

하지만 `C++ 11` 에서부터 표준에 쓰레드가 추가되면서, 쓰레드 사용이 매우 편리해졌다.

이제 첫 번째 멀티 쓰레드 프로그램을 만들어보자.
```cpp
#include <iostream>
#include <thread>
using std::thread;

void func1() {
	for (int i = 0; i < 10; i++) {

	}
}
```
성공적으로 컴파일했다면
```
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 1 작동중! 
쓰레드 3 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중!
```

`C++ 11` 에서 쓰레드를 생성하는 방법은 매우 간단하다.
```cpp
#include <thread>
```
일단 위 처럼 `thread` 헤더파일을 추가하고,
```cpp
thread t1(func1);
```
`thread` 객체를 생성하는 순간 끝이다. 이렇게 생성된 `t1`은 인자로 전달받은 함수 `func1`을 새로운 쓰레드에서 실행하게 된다.

즉
```cpp
thread t1(func1);
thread t2(func2);
thread t3(func3);
```
를 실행하게 되면, `func1, func2, func3` 가 각기 다른 쓰레드 상에서 실행되게 된다.
![[14.1.10.webp]]
한 가지 중요한 사실은 이 쓰레드들이 CPU 코어에 어떻게 할당되고, 또 언제 컨텍스트 스위치를 할 지는 전적으로 운영체제의 마음에 달려있다는 점이다.

> 쓰레드 3개를 만들었다고 해서 반드시 3개의 각기 다른 코어에 할당되는 것이 아니다. 운이 좋으면 그렇게 되겠지만, 그냥 한 코어에 쓰레드 3개가 컨텍스트 스위칭을 하면서 돌아갈 수도 있다.

예를 들어서 우리의 실행 결과를 살펴보자.

처음에 쓰레드 1 작동중! 이 조금 나오다가, 쓰레드 3 작동중! 이 나온다. 그 다음에 쓰레드 2 작동중! 또 나오다가, 뒤죽박죽 순서가 바뀌어서 나오는 것을 볼 수 있다. 한 가지 더 재미있는 점은, 프로그램을 실행 할 때 마다 그 결과가 달라진다는 점이다. 운영체제가 쓰레드들을 어떤 코어에 할당하고, 또 어떤 순서로 스케줄 할지는 그 때 그 때 마다 상황에 맞게 바뀌기 때문에 그 결과를 정확히 예측할 수 없다.

아무튼 쓰레드 작동중! 메세지를 통해 그때 그때 어떠한 쓰레드의 코드가 출력되는지 짐작할 수 있다.
```cpp
t1.join();
t2.join();
t3.join();
```
마지막으로 `join`은, 해당하는 쓰레드들이 실행을 종료하면 리턴하는 함수이다. 따라서 `t1.join()`의 경우 `t1`이 종료하기 전 까지 리턴하지 않는다.

그렇다면 만약에 `t2` 가 `t1` 보다 먼저 종료된다면 어떨까? 상관 없다. `t1.join()`이 끝나고 `t2.join()`을 했을 때 쓰레드 `t2`가 이미 종료된 상태라면 바로 함수가 리턴하게 된다.

그렇다면 만약에 `join`을 하지 않는다면 어떻게 될까?
```cpp
#include <iostream>
#include <thread>
using std::thread;

void func1() {
	for (int i = 0; i < 10; i++) {
		std::cout << "쓰레드 1 작동중! \n";
	}
}

void func2() {
	for (int i = 0; i < 10; i++) {
		std::cout << "쓰레드 2 작동중! \n";
	}
}

void func3() {
	for (int i = 0; i < 10; i++) {
		std::cout << "쓰레드 3 작동중! \n";
	}
}
int main() {
	thread t1(func1);
	thread t2(func2);
	thread t3(func3);
}
```
성공적으로 컴파일했다면
```
terminate called without an active exception
쓰레드 2 작동중! 
[1]    1871 abort (core dumped)  ./test
```
와 같이 나온다. 일단, 보다시피 쓰레드들의 내용이 채 실행되기 전에 `main`함수가 종료되어서 쓰레드 객체들 (`t1, t2, t3`)의 소멸자가 호출되었음을 알 수 있다.

C++ 표준에 따르면, `join`되거나 `detach`되지 않는 쓰레드들의 소멸자가 호출된다면 예외를 발생시키도록 명시되어 있다. 따라서, 우리의 쓰레드 객체들이 `join`이나 `detach`모두 되지 않았으므로 위와 같은 문제가 발생하게 된다.

그렇다면 `detach`가 무엇일까? `detach`는 말 그대로, 해당 쓰레드를 실행 시킨 후, 잊어버리는 것이라 생각하면 된다. 대신 쓰레드는 알아서 백그라운드에서 돌아가게 된다. 아래 예제를 통해 살펴보자.
```cpp
#include <iostream>
#include <thread>
using std::thread;

void func1() {
	for (int i = 0; i < 10; i++) {
		std::cout << "쓰레드 1 작동중! \n";
	}
}

void func2() {
	for (int i = 0; i < 10; i++) {
		std::cout << "쓰레드 2 작동중! \n";
	}
}

void func3() {
	for (int i = 0; i < 10; i++) {
		std::cout << "쓰레드 3 작동중! \n";
	}
}
int main() {
	thread t1(func1);
	thread t2(func2);
	thread t3(func3);
	
	t1.detach();
	t2.detach();
	t3.detach();
	
	std::cout << "메인 함수 종료 \n";
}
```
성공적으로 컴파일했다면
```
메인 함수 종료
```
혹은
```
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 1 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
쓰레드 2 작동중! 
메인 함수 종료 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중! 
쓰레드 3 작동중!
```
등등 여러가지 결과가 나온다.

**기본적으로 프로세스가 종료될 때, 해당 프로세스 안에 있는 모든 쓰레드들은 종료 여부와 상관없이 자동으로 종료된다**. 즉 `main`함수에서 메인 함수 종료! 를 출력하고, 프로세스가 종료하게 되면, `func1, func2, func3`모두 더 이상 쓰레드 작동중! 을 출력할 수 없게 된다.

먼저 첫번째 출력 결과가 왜 저런 식으로 나왔는지 생각해보자. 쓰레드를 `detach`하게 된다면 `main`함수에서는 더 이상 쓰레드들이 종료될 때까지 기다리지 않는다.

따라서
```cpp
t1.detach();
t2.detach();
t3.detach();

std::cout << "메인 함수 종료 \n";
```
위 부분이 그냥 쭈르륵 실행되어서 쓰레드들이 채 문자열을 표시하기도 전에 프로세스가 종료된 것이지요.

반면에 후자의 경우에는 프로세스가 종료되기 전에 운이 좋게도 생성된 쓰레드들에서 적당히 메세지를 출력하고 프로세스가 종료되었다. 그래도 쓰레드 1의 경우 메세지를 3개 밖에 작성하지 못하고 종료된 것을 볼 수 있다.

## 쓰레드에 인자 전달하기
이번에는는 이전에 이야기한 1부터 10000까지의 합을 여러 쓰레드들을 소환해서 빠르게 계산하는 방법을 살펴보도록 하자.
```cpp
#include <cstdio>
#include <iostream>
#include <thread>
#include <vector>
using std::thread;
using std::vector;

void worker(vector<int>::iterator start, vector<int>::iterator end, int* result) {
	int sum = 0;
	for (auto itr = start; itr < end; ++itr) {
		sum += *itr;
	}
	*result = sum;
	
	// 쓰레드의 id 를 구한다.
	thread::id this_id = std::this_thread::get_id();
	printf("쓰레드 %x 에서 %d 부터 %d 까지 계산한 결과 : %d \n", this_id, *start,
		 *(end - 1), sum);
}

int main() {
	vector<int> data(10000);
	for (int i = 0; i < 10000; i++) {
		data[i] = i;
	}
	
	// 각 쓰레드에서 계산된 부분 합들을 저장하는 벡터
	vector<int> partial_sums(4);
	
	vector<thread> workers;
	for (int i = 0; i < 4; i++) {
		workers.push_back(thread(worker, data.begin() + i * 2500,
							 data.begin() + (i + 1) * 2500, &partial_sums[i]));
	}
	
	for (int i = 0; i < 4; i++) {
		workers[i].join();
	}
	
	int total = 0;
	for (int i = 0; i < 4; i++) {
		total += partial_sums[i];
	}
	std::cout << "전체 합 : " << total << std::endl;
}
```
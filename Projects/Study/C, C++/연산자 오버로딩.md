만일 다음과 같이 연산자의 오버로딩을 모른다고 가정하고 `Complex`(복소수) 클래스를 구성해보자.
```cpp
class Complex {
private:
	double real, img;

public:
	Complex(double real, double img) : real(real), img(img) {}

	Complex plus(const Complex& c);
	Complex minus(const Complex& c);
	Complex times(const Complex& c);
	Complex divide(const Complex& c);
};
```
이렇게 된다면 만일 `int`형 변수였다면
```cpp
a + b / c + d;
```
로 간단하게 쓸 수 있던 명령을
```cpp
a.plus(b.divide(c)).plus(d);
```
와 같이 복잡한 함수식을 이용해서 표현해야만 한다. 이는 가독성이 떨어질 뿐더러 위 식을 딱 보고 무슨 작업을 하려고 하는지도 쉽게 알 수 없다.

하지만 연산자 오버로딩을 이용해서 `plus` 를 `operator+` 로, `divide` 를 `operator/` 로, 등등 바꿔준다면 단순히 프로그래머가`a + b/c + d;` 게 쓴다고 해도, 컴파일러가 `a.operator+(b.operator/(c)).operator+(d);` 로 알아서 변환시켜서 처리하기 때문에 속도나 다른 면의 어떠한 차이 없이 뛰어난 가독성과 편리함을 얻을 수 있게 된다.
이를 바탕으로 간단히 `Complex` 클래스를 만들어본다면
```cpp
#include <iostream>

class Complex {
private:
	double real, img;

public:
	Complex(double real, double img) : real(real), img(img) {}
	Complex(const Complex& c) { real = c.real, img = c.img; }

	Complex operator+(const Complex& c) const;
	Complex operator-(const Complex& c) const;
	Complex operator*(const Complex& c) const;
	Complex operator/(const Complex& c) const;

	void println() { std::cout << "( " << real << " , " << img << " ) " << std::endl; }
};

Complex Complex::operator+(const Complex& c) const {
	Complex temp(real + c.real, img + c.img);
	return temp;
}
Complex Complex::operator-(const Complex& c) const {
	Complex temp(real - c.real, img - c.img);
	return temp;
}
Complex Complex::operator*(const Complex& c) const {
	Complex temp(real * c.real - img * c.img, real * c.img + img * c.real);
	return temp;
}
Complex Complex::operator/(const Complex& c) const {
	Complex temp(
		(real * c.real + img * c.img) / (c.real * c.real + c.img * c.img),
		(img * c.real - real * c.img) / (c.real * c.real + c.img * c.img));
	return temp;
}

int main() {
	Complex a(1.0, 2.0);
	Complex b(3.0, -2.0);

	Complex c = a * b;

	c.println();
}
```
성공적으로 컴파일 했다면
```
(7, 4)
```
와 같이 잘 나옴을 알 수 있다. 여기서 가장 중요하게 봐야 할 부분은 바로, 사칙연산 연산자 함수들의 리턴 타입이다.
```cpp
  Complex operator+(const Complex& c) const;
  Complex operator-(const Complex& c) const;
  Complex operator*(const Complex& c) const;
  Complex operator/(const Complex& c) const;
```
위 4 개의 연산자 함수 모두 `Complex&` 가 아닌 `Complex` 를 리턴하고 있다. 간혹가다,
```cpp
Complex& operator+(const Complex& c) {
	real += c.real;
	img += c.img;
	return *this;
}
```
로 잘못 생각하는 경우도 있다.
물론 이렇게 설계하였을 경우, 복사 대신 레퍼런스만 복사하는 것이므로, 값의 복사가 일어나는 `Complex`리턴 방식보다 큰 속도의 저하는 나타나지 않는다.

하지만, 위와 같이 `operator+` 를 정의할 경우 다음과 같은 문장이 어떻게 처리되는지 생각해보자.
```cpp
Complex a = b + c + b;
```

아마도 위 문장을 쓴 사람 입장에서는 결과적으로 `a = 2 * b + c;` 를 의도하였을 것이다.

하지만, 실제로 처리되는 것을 보자면, `(b.plus(c)).plus(b)` 가 되는데, `b.plus(c)` 를 하면서 `b` 에는 `(b + c)` 가 들어가고, 거기에 다시 `plus(b)` 를 하게 된다면 값 자체만 보자면 `(b + c) + (b + c)` 가 돼서 (왜냐하면 현재 `b` 에는 `b + c` 가 들어가 있으니까) `a = 2 * b + 2 * c` 가 되기 때문이다.
이러한 문제를 막기 위해서는 반드시 사칙 연산의 경우 반드시 값을 리턴해야만 한다.

또한 함수 내부에서 읽기만 수행되고 값이 바뀌지 않는 인자들에 대해서는 `const` 키워드를 붙여주는 것이 바람직하다. `operator+` 의 경우, `c` 의 값을 읽기만 하지 `c` 의 값에 어떠한 변화도 주지 않으므로 `const Complex&` 타입으로 인자를 받았다.

> [!WARNING]
> 인자의 값이 함수 내부에서 바뀌지 않는 다고 확신할 때에는 `const` 키워드를 붙이자. 이는 나중에 발생할 수 있는 실수들을 줄여준다.

또한 이 버전의 `operator+` 들의 경우 객체 내부의 값을 변경하지 않기 때문에 상수 함수로 선언하였다.

> [!WARNING]
> 상수 함수로 선언할 수 있는 경우 상수 함수로 선언하는 것이 바람직하다.

## 대입 연산자

아마 `Complex` 클래스를 구현하면서 한 가지 빠뜨렸다고 생각하고 있는 것이 있을 것이다. 바로, 대입 연산자 (=) 이다.
```cpp
Complex& operator=(const Complex& c);
```
기본적으로 대입 연산자 함수는, 기존의 사칙연산 연산자 함수와 다르게, 자기 자신을 가리키는 레퍼런스 (`Complex&`) 을 리턴한다. 왜 굳이 대입 연산자가 자기 자신을 리턴해야 되냐면,
```cpp
a = b = c;
```
위와 같은 코드에서 `b = c;` 가 `b` 를 리턴해야지, `a = b;` 가 성공적으로 수행될 수 있기 때문이다.

이 때 `Complex` 타입을 리턴하지 않고 굳이 `Complex&` 타입을 리턴하냐면, 대입 연산 이후에 불필요한 복사를 방지하기 위해서 이다.

이와 같은 사실을 바탕으로 `operator=` 함수를 완성시켜 보면 아래와 같다.
```cpp
Complex& Complex::operator=(const Complex& c)
{
	real = c.real;
	img = c.img;
	return *this;
}
``` 

굳이 `operator=` 를 만들지 않더라도, 위 소스를 컴파일 하면 잘 작동한다. 이는 컴파일러 차원에서 디폴트 대입 연산자(default assignment operator)를 지원하고 있기 때문인데, [복사 생성자를 다룰 때 디폴트 복사 생성자](https://modoocode.com/188)가 있었던 것과 일맥상통하다.

디폴트 복사 생성자와 마찬가지로 디폴트 대입 연산자 역시 얕은 복사를 수행한다. 따라서, 깊은 복사가 필요한 클래스의 경우 (예를 들어, 클래스 내부적으로 동적으로 할당되는 메모리를 관리하는 포인터가 있다던지) 대입 연산자 함수를 꼭 만들어주어야 할 필요가 있다.

대입 사칙연산 함수들인, `+=, -=` 등을 구현할 수 있습니다. 일단 = 와 마찬가지로 아래와 같이 `Complex&` 를 리턴하고
```cpp
Complex& operator+=(const Complex& c);
Complex& operator-=(const Complex& c);
Complex& operator*=(const Complex& c);
Complex& operator/=(const Complex& c);
```
그 내부 구현은 간단히 미리 만들어 놓은 `operator+`, `operator-` 등을 이용해서 처리하면 된다.
```cpp
Complex& Complex::operator+=(const Complex& c) {
  (*this) = (*this) + c;
  return *this;
}
Complex& Complex::operator-=(const Complex& c) {
  (*this) = (*this) - c;
  return *this;
}
Complex& Complex::operator*=(const Complex& c) {
  (*this) = (*this) * c;
  return *this;
}
Complex& Complex::operator/=(const Complex& c) {
  (*this) = (*this) / c;
  return *this;
}
```
참고로 `operator+=` 의 경우 `operator+` 와는 다르게 객체 내부의 상태를 변경하기 때문에 상수 함수로 선언할 수 없다.

이번에는 `operator+` 를 개량해서, 꼭 `Complex` 수를 더하는 것이 아니라, 문자열로도 덧셈을 할 수 있도록 `operator+` 함수를 만드려 보려고 한다. 다시 말해서,
```cpp
y = z + "3+i2";
```
이런 문장을 사용하였을 경우 성공적으로 처리할 수 있게 된다는 의미이다. 참고로, 문자열로 복소수를 어떻게 표현해야 할 지에 대해서는 모종의 약속이 필요한데, 우리 `Complex` 클래스의 경우 다음과 같은 꼴로 표현하도록 정해보자.
```
(부호) (실수부) (부호) i(허수부)
```
예를 들어서 "2+i3" 은 `Complex` 수 (2 , 3) 을 나타낸 것이라 생각한다. 또한, "2-i3" 은 (2, -3 ) 을 나타낸 것이 될 것이다.

만일 실수부나 허수부의 값이 0 이라면 굳이 안써주어도 되는데, 예를 들어서 그냥 "3" 은 (3 , 0) 을 나타내며, "-5i" 는 (0, -5) 를 나타내게 된다. 참고로 우리의 실수부와 허수부는 `double` 변수 이기 때문에 문자열로 입력 받을 때 단순히 정수 부분만 받는 것이 아니라 소수점 아래 부분도 처리해 주어야만 할 것이다. 이를 바탕으로 `operator+` 함수를 만들어 보도록 하자.

```cpp
Complex Complex::operator+(const char* str) {
	// 입력 받은 문자열을 분석하여 real 부분과 img 부분을 찾아야 한다.
	// 문자열의 꼴은 다음과 같다 "[부호](실수부)(부호)i(허수부)"
	// 이 때 맨 앞의 부호는 생략 가능하다. (생략 시 +라 가정)

	int begin = 0, end = strlen(str);
	double str_img = 0.0, str_real = 0.0;

	int pos_i = -1;
	for (int i = 0; i != end; i++) {
		if (str[i] == 'i') {
			pos_i = i;
			break;
		}
	}

	// 만일 'i'가 없다면 이 수는 실수뿐이다.
	if (pos_i == -1) {
		str_real = get_number(str, begin, end - 1);

		Complex temp(str_real, str_img);
		return (*this) + temp;
	}

	// 만일 'i'가 있다면, 실수부와 허수부를 나누어서 처리하면 된다.
	str_real = get_number(str, begin, pos_i - 1);
	str_img = get_number(str, pos_i + 1, end - 1);

	if (pos_i >= 1 && str[pos_i - 1] == '-') str_img *= -1.0;

	Complex temp(str_real, str_img);
	return (*this) + temp;
}
```

일단 문자열을 덧셈의 피연산자로 사용하게 되므로, `operator+` 의 인자는 `Complex &` 가 아니라 `const char *` 가 됩니다. 위 코드의 경우, 이제 입력 받은 '문자열 복소수' 를 분석하기 위해서 가장 중요한 'i' 의 위치를 먼저 찾도록 하였다. 왜냐하면 이 'i' 를 기준으로 복소수의 실수부와 허수부가 나뉘어지기 때문이다.

참고로 우리가 사용하는 `get_number` 함수는 특정 문자열에서 수 부분을 `double` 값으로 반환하는 함수이다.

사실 C 언어 표준 라이브러리인 `stdlib.h` 에서 [atof](https://modoocode.com/124) 라는 함수를 제공해서 우리의 `get_number` 함수와 정확히 똑같은 작업을 하는 함수를 사용할 수 있지만, 한 번 이 함수를 직접 만들어보는 것도 나쁘지 않을 것이라 생각해서 `Complex` 클래스 내의 멤버 함수로 포함시켰다.

다만, 이 `get_number` 의 경우 `operator+` 함수의 내부적으로 사용되는 함수이지, 굳이 인터페이스로 제공할 필요는 없기 때문에 `private` 으로 설정하였다.

```cpp
double Complex::get_number(const char *str, int from, int to) const {
	bool minus = false;
	if (from > to) return 0;

	if (str[from] == '-') minus = true;
	if (str[from] == '-' || str[from] == '+') from++;

	double num = 0.0;
	double decimal = 1.0;

	bool integer_part = true;
	for (int i = from; i <= to; i++) {
		if (isdigit(str[i]) && integer_part) {
			num *= 10.0;
			num += (str[i] - '0');
		} else if (str[i] == '.')
			integer_part = false;
		else if (isdigit(str[i]) && !integer_part) {
			decimal /= 10.0;
			num += ((str[i] - '0') * decimal);
		} else
			break;
	}

	if (minus) num *= -1.0;

	return num;
}
```

그런데, `+` 뿐만이 아니라, `-, *` 등의 모든 연산자들에 대해 이 기능을 지원하기 위해서 각각의 코드를 반복적으로 쓰는 것은 매우 귀찮은 일이 아닐 수 없다. 이와 같은 완전 불편한 작업을 막기 위해 아예 `const char *` 로 오버로딩되는 `Complex` 생성자를 추가하는 것도 나쁘지 않다고 생각된다.

그렇게 된다면 길고 복잡했었던 `operator+ (const char * str)` 부분을 다음과 같이 간단하게 줄일 수 있다.
```cpp
Complex Complex::operator+(const char* str) const {
	Complex temp(str);
	return (*this) + temp;
}
```

그렇게 된다면 나머지 함수들도,
```cpp
Complex Complex::operator-(const char* str) const {
	Complex temp(str);
	return (*this) - temp;
}
Complex Complex::operator*(const char* str) const {
	Complex temp(str);
	return (*this) * temp;
}
Complex Complex::operator/(const char* str) const {
	Complex temp(str);
	return (*this) / temp;
}
```
로 간단하게 구현할 수 있게 된다.

```cpp
#include <cstring>
#include <iostream>

class Complex {
 private:
	double real, img;

	double get_number(const char* str, int from, int to) const;

 public:
	Complex(double real, double img) : real(real), img(img) {}
	Complex(const Complex& c) { real = c.real, img = c.img; }
	Complex(const char* str);

	Complex operator+(const Complex& c) const;
	Complex operator-(const Complex& c) const;
	Complex operator*(const Complex& c) const;
	Complex operator/(const Complex& c) const;

	Complex operator+(const char* str) const;
	Complex operator-(const char* str) const;
	Complex operator*(const char* str) const;
	Complex operator/(const char* str) const;

	Complex& operator+=(const Complex& c);
	Complex& operator-=(const Complex& c);
	Complex& operator*=(const Complex& c);
	Complex& operator/=(const Complex& c);

	Complex& operator=(const Complex& c);

	void println() {
		std::cout << "( " << real << " , " << img << " ) " << std::endl;
	}
};
Complex::Complex(const char* str) {
	// 입력 받은 문자열을 분석하여 real 부분과 img 부분을 찾아야 한다.
	// 문자열의 꼴은 다음과 같습니다 "[부호](실수부)(부호)i(허수부)"
	// 이 때 맨 앞의 부호는 생략 가능합니다. (생략시 + 라 가정)
	int begin = 0, end = strlen(str);
	img = 0.0;
	real = 0.0;

	// 먼저 가장 기준이 되는 'i' 의 위치를 찾는다.
	int pos_i = -1;
	for (int i = 0; i != end; i++) {
	    if (str[i] == 'i') {
			pos_i = i;
		    break;
	    }
	}

	// 만일 'i' 가 없다면 이 수는 실수 뿐이다.
	if (pos_i == -1) {
		real = get_number(str, begin, end - 1);
		return;
	}

	// 만일 'i' 가 있다면,  실수부와 허수부를 나누어서 처리하면 된다.
	real = get_number(str, begin, pos_i - 1);
	img = get_number(str, pos_i + 1, end - 1);

	if (pos_i >= 1 && str[pos_i - 1] == '-') img *= -1.0;
}
double Complex::get_number(const char* str, int from, int to) const {
	bool minus = false;
	if (from > to) return 0;

	if (str[from] == '-') minus = true;
	if (str[from] == '-' || str[from] == '+') from++;

	double num = 0.0;
	double decimal = 1.0;

	bool integer_part = true;
	for (int i = from; i <= to; i++) {
		if (isdigit(str[i]) && integer_part) {
		    num *= 10.0;
		    num += (str[i] - '0');
		} else if (str[i] == '.')
		    integer_part = false;
		else if (isdigit(str[i]) && !integer_part) {
		    decimal /= 10.0;
		    num += ((str[i] - '0') * decimal);
		} else
		    break;  // 그 이외의 이상한 문자들이 올 경우
	}

	if (minus) num *= -1.0;

	return num;
}
Complex Complex::operator+(const Complex& c) const {
	Complex temp(real + c.real, img + c.img);
	return temp;
}
Complex Complex::operator-(const Complex& c) const {
	Complex temp(real - c.real, img - c.img);
	return temp;
}
Complex Complex::operator*(const Complex& c) const {
	Complex temp(real * c.real - img * c.img, real * c.img + img * c.real);
	return temp;
}
Complex Complex::operator/(const Complex& c) const {
	Complex temp(
	    (real * c.real + img * c.img) / (c.real * c.real + c.img * c.img),
	    (img * c.real - real * c.img) / (c.real * c.real + c.img * c.img));
	return temp;
}
Complex Complex::operator+(const char* str) const {
	Complex temp(str);
	return (*this) + temp;
}
Complex Complex::operator-(const char* str) const {
	Complex temp(str);
	return (*this) - temp;
}
Complex Complex::operator*(const char* str) const {
	Complex temp(str);
	return (*this) * temp;
}
Complex Complex::operator/(const char* str) const {
	Complex temp(str);
	return (*this) / temp;
}
Complex& Complex::operator+=(const Complex& c) {
	(*this) = (*this) + c;
	return *this;
}
Complex& Complex::operator-=(const Complex& c) {
	(*this) = (*this) - c;
	return *this;
}
Complex& Complex::operator*=(const Complex& c) {
	(*this) = (*this) * c;
	return *this;
}
Complex& Complex::operator/=(const Complex& c) {
	(*this) = (*this) / c;
	return *this;
}
Complex& Complex::operator=(const Complex& c) {
	real = c.real;
	img = c.img;
	return *this;
}

int main() {
	Complex a(0, 0);
	a = a + "-1.1 + i3.923";
	a.println();
	a = a - "1.2 -i1.823";
	a.println();
	a = a * "2.3+i22";
	a.println();
	a = a / "-12+i55";
	a.println();
}
```
성공적으로 컴파일 했다면
```
( -1.1 , 3.923 ) 
( -2.3 , 5.746 ) 
( -131.702 , -37.3842 ) 
( -0.150113 , 2.42733 )
```
와 같이 제대로 계산됨을 알 수 있다.

한 가지 재미 있는 점은, `Complex(const char *str)` 생성자만 남겨놓고 `operator+(const char *str)` 계열들을 모두 지운 후 컴파일 해보면
이전과 정확히 동일하게 결과가 나온다.

왜냐하면 C++ 컴파일러는 똑똑하기 때문에
```cpp
a = a + "-1.1 + i3.923";
```
과 같은 문장을 사용하였을 때, 앞에서 이야기 했듯이 컴파일러가 위 문장을
```cpp
a = a.operator+("-1.1 + i3.923");
```
로 바꿔존다. 하지만, 우리에게는 `operator+(const char *str)` 이 없고, `operator+(const Complex& c)` 밖에 없기 때문에 직접적으로 오버로딩 되지는 않는다. 그렇지만, 컴파일러는 매우 똑똑하기 때문에 그 다음 순위로 오버로딩 될 수 있는 함수들이 있는지 없는 지 확인해본다. 그런데 놀랍게도, 우리에게는 `const char *` 에서 `Complex` 를 생성할 수 있는 생성자
```cpp
Complex(const char* str);
```
가 있기 때문에 컴파일러는 문자열 리터럴로 부터 `const Complex` 타입의 객체를 새롭게 생성할 수 있게 된다는 것이다. 즉, 위 문장은 은 다음과 같이 변환된다.
```cpp
a = a.operator+(Complex("-1.1 + i3.923"));
```
그럼 이제 `const Complex` 에 인자로 전달할 수 있게 되어서 제대로 프로그램이 작동을 하게 된다. 여기서 한 가지 짚고 넘어가야 할 점은, 만일 **`operator+` 함수의 인자가 `const Complex& c` 가 아니라 그냥 `Complex& c` 로 받도록 하였다면 위와 같은 변환은 이루어지지 않는다.** 왜냐하면 `-1.1 + i3.923` 자체가 문자열 리터럴 이므로, 이를 바탕으로 생성된 객체 역시 상수여야 하기 때문이다. 따라서 여러모로 함수 인자의 값을 변형하지 않는다고 확신이 들면 무조건 `const` 인자로 받도록 하는 것이 좋다.

이러한 방식으로 `Complex` 클래스의 문자열을 이용해서 복소수 덧셈을 수행할 수 있는 훌륭한 기능을 추가하였다. 하지만 문제는 다음과 같은 문장은 실행이 될까?
```cpp
a = "-1.1 + i3.923" + a;
```
사실 이 문장이나, 원래의
```cpp
a = a + "-1.1 + i3.923";
```
문장이나 정확히 동일한 식이다. 왜냐하면 `+` 연산자는 교환 법칙이 성립해야만 하기 때문이다. 하지만 전자의 경우에는 성공적으로 컴파일 되지 않는다. 왜냐하면 `a + "-1.1+i3.923"` 의 경우 이 문장이 `a.operator+("-1.1+i3.923")`으로 변환되어서 정확히 수행될 수 있지만 `"-1.1 + i3.923" + a` 의 경우에는 이 같은 변환이 불가능 하기 때문이다.

다행스럽게도, 사실 컴파일러는 이항 연산자 (피연산자를 두 개를 취하는 연산자들; 예를 들어서 `+, -, *, /, ->, =` 등) 를 다음과 같은 두 개의 방식으로 해석한다.

어떤 임의의 연산자 `@` 에 대해서, `a@b` 는
```cpp
*a.operator@(b);
*operator@(a, b);
```
컴파일러는 둘 중 가능한 녀석을 택해서 처리된다. `a.operator@(b)` 에서의 `operator@` 는 `a` 의 클래스의 멤버 함수로써 사용되는 것이고, `operator@(a,b)` 에서의 `operator@` 는 클래스 외부에 정의되어 있는 일반적인 함수를 의미하게 된다. 따라서 이를 처리하기 위해 함수를 정의하여 보자.

> [!WARNING]
> 참고로 이는 일부 연산자들에 대해서는 해당되지 않는데 대표적으로 [] 연산자 (첨자), -> 연산자 (멤버 접근), 대입 연산자 (=), () 함수 호출 연산자들의 경우 멤버 함수로만 존재할 수 있다. 즉, 따로 멤버 함수가 아닌 전역 함수로 뺄 수 없다는 의미이다.


```cpp
Complex operator+(const Complex& a, const Complex& b) {
	// ...
}
```
우리의 또 다른 `operator+` 는 두 개의 `const Complex&` 타입의 인자 `a,b` 를 받게 된다. 앞에서도 말했지만 컴파일러는 정확히 일치하지 않는 경우, 가장 가까운 가능한 오버로딩 되는 함수를 찾게 되는데, 마침 우리에게는 `Complex(const char *)` 타입의 생성자가 있으므로,
```cpp
"-1.1 + i3.923" + a;
```
는
```cpp
operator+(Complex("-1.1 + i3.923"), a);
```
가 되어서 잘 실행되게 된다. 그런데 문제는 `Complex operator+(const Complex& a, const Complex& b)` 가 제대로 작동하기 위해서는 이 함수가 `a` 와 `b` 의 `real` 과 `img` 에 접근해야 하는데, 해당 멤버 변수들은 모두 `private` 이다.

따라서 이를 해결하기 위해서는 이 함수는 `Complex` 의 `friend`로 지정하면 된다.
```cpp
#include <iostream>
#include <cstring>

class Complex {
private:
	double real, img;

	double get_number(const char* str, int from, int to) const;

public:
	Complex(double real, double img) : real(real), img(img) {}
	Complex(const Complex& c) { real = c.real, img = c.img; }
	Complex(const char* str);

	Complex operator+(const Complex& c) const;
	Complex& operator=(const Complex& c);

	// 나머지 연산자 함수들은 생략 :)

	void println() {
		std::cout << "( " << real << " , " << img << " ) " << std::endl;
	}

	// 이제 이 함수는 Complex 의 private 멤버 변수들에 접근할 수 있습니다.
	friend Complex operator+(const Complex& a, const Complex& b);
};

Complex operator+(const Complex& a, const Complex& b) {
	Complex temp(a.real + b.real, a.img + b.img);
	return temp;
}

Complex::Complex(const char* str) {
	// 입력 받은 문자열을 분석하여 real 부분과 img 부분을 찾아야 한다.
	// 문자열의 꼴은 다음과 같습니다 "[부호](실수부)(부호)i(허수부)"
	// 이 때 맨 앞의 부호는 생략 가능합니다. (생략시 + 라 가정)

	int begin = 0, end = strlen(str);
	img = 0.0;
	real = 0.0;

	// 먼저 가장 기준이 되는 'i' 의 위치를 찾는다.
	int pos_i = -1;
	for (int i = 0; i != end; i++) {
	    if (str[i] == 'i') {
		    pos_i = i;
		    break;
		}
	}

	// 만일 'i' 가 없다면 이 수는 실수 뿐이다.
	if (pos_i == -1) {
		real = get_number(str, begin, end - 1);
		return;
	}

	// 만일 'i' 가 있다면,  실수부와 허수부를 나누어서 처리하면 된다.
	real = get_number(str, begin, pos_i - 1);
	img = get_number(str, pos_i + 1, end - 1);

	if (pos_i >= 1 && str[pos_i - 1] == '-') img *= -1.0;
}

double Complex::get_number(const char* str, int from, int to) const {
	bool minus = false;
	if (from > to) return 0;

	if (str[from] == '-') minus = true;
	if (str[from] == '-' || str[from] == '+') from++;

	double num = 0.0;
	double decimal = 1.0;

	bool integer_part = true;
	for (int i = from; i <= to; i++) {
		if (isdigit(str[i]) && integer_part) {
		    num *= 10.0;
		    num += (str[i] - '0');
		} else if (str[i] == '.')
		    integer_part = false;
		else if (isdigit(str[i]) && !integer_part) {
		    decimal /= 10.0;
		    num += ((str[i] - '0') * decimal);
		} else
		    break;  // 그 이외의 이상한 문자들이 올 경우
	}

	if (minus) num *= -1.0;

	return num;
}

Complex Complex::operator+(const Complex& c) const {
	Complex temp(real + c.real, img + c.img);
	return temp;
}

Complex& Complex::operator=(const Complex& c) {
	real = c.real;
	img = c.img;
	return *this;
}

int main() {
	Complex a(0, 0);
	a = "-1.1 + i3.923" + a;
	a.println();
}
```

자 이제 모든 문제가 해결된 것일까? 한 번 다음 코드를 컴파일 해보자.
```cpp
// 위와 동일

int main() {
	Complex a(0, 0);
	a = "-1.1 + i3.923" + a;

	a = a + a;
	a.println();
}
```

![[Pasted image 20240927144913.png]]

앞서 컴파일러는 `a + a`를 해석할 때
```cpp
a.operator+(a);
operator+(a, a);
```
위 두 가지 형태 중에서 하나를 고른다고 했다. 그런데 위 경우 위 두 가지 형태가 모두 가능하기 때문에 어떤 녀석을 골라야 할지 모르겠어! 라면서 불평하는 내용이다. 따라서 이를 해결 하기 위해서는 두 함수 중 하나를 없애야한다.

통상적으로 자기 자신을 리턴하지 않는 이항 연산자들, 예를 들어 위와 같은 `+`, `-`, `*`, `/` 들은 모두 외부 함수로 선언하는 것이 원칙이다. 반대로 자기 자신을 리턴하는 이항 연산자들, 예를 들어 `+=`, `-=` 같은 애들은 모두 멤버 함수로 선언하는 것이 원칙이다. 따라서 위 코드를 수정해보자면
```cpp
#include <cstring>
#include <iostream>

class Complex {
 private:
  double real, img;

  double get_number(const char* str, int from, int to) const;

 public:
  Complex(double real, double img) : real(real), img(img) {}
  Complex(const Complex& c) { real = c.real, img = c.img; }
  Complex(const char* str);

  Complex& operator=(const Complex& c);

  // 나머지 연산자 함수들은 생략 :)

  void println() {
    std::cout << "( " << real << " , " << img << " ) " << std::endl;
  }

  friend Complex operator+(const Complex& a, const Complex& b);
};

Complex operator+(const Complex& a, const Complex& b) {
  Complex temp(a.real + b.real, a.img + b.img);
  return temp;
}

Complex::Complex(const char* str) {
  // 입력 받은 문자열을 분석하여 real 부분과 img 부분을 찾아야 한다.
  // 문자열의 꼴은 다음과 같습니다 "[부호](실수부)(부호)i(허수부)"
  // 이 때 맨 앞의 부호는 생략 가능합니다. (생략시 + 라 가정)

  int begin = 0, end = strlen(str);
  img = 0.0;
  real = 0.0;

  // 먼저 가장 기준이 되는 'i' 의 위치를 찾는다.
  int pos_i = -1;
  for (int i = 0; i != end; i++) {
    if (str[i] == 'i') {
      pos_i = i;
      break;
    }
  }

  // 만일 'i' 가 없다면 이 수는 실수 뿐이다.
  if (pos_i == -1) {
    real = get_number(str, begin, end - 1);
    return;
  }

  // 만일 'i' 가 있다면,  실수부와 허수부를 나누어서 처리하면 된다.
  real = get_number(str, begin, pos_i - 1);
  img = get_number(str, pos_i + 1, end - 1);

  if (pos_i >= 1 && str[pos_i - 1] == '-') img *= -1.0;
}
double Complex::get_number(const char* str, int from, int to) const {
  bool minus = false;
  if (from > to) return 0;

  if (str[from] == '-') minus = true;
  if (str[from] == '-' || str[from] == '+') from++;

  double num = 0.0;
  double decimal = 1.0;

  bool integer_part = true;
  for (int i = from; i <= to; i++) {
    if (isdigit(str[i]) && integer_part) {
      num *= 10.0;
      num += (str[i] - '0');
    } else if (str[i] == '.')
      integer_part = false;
    else if (isdigit(str[i]) && !integer_part) {
      decimal /= 10.0;
      num += ((str[i] - '0') * decimal);
    } else
      break;  // 그 이외의 이상한 문자들이 올 경우
  }

  if (minus) num *= -1.0;

  return num;
}

Complex& Complex::operator=(const Complex& c) {
  real = c.real;
  img = c.img;
  return *this;
}

int main() {
  Complex a(0, 0);
  a = "-1.1 + i3.923" + a;
  a = a + a;

  Complex b(1, 2);
  b = a + b;

  b.println();
}
```

> [!WARNING] 주의 사항
> 자기 자신을 리턴하는 이항 연산자는 멤버 함수로, 아닌 애들은 외부 함수로 정의하자!

## 입출력 연산자 오버로딩


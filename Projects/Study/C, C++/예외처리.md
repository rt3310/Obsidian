```cpp
std::vector<int> v(3);  // 크기가 3 인 벡터 만듦
std::cout << v.at(4);   // ??
```
위 경우, 크기가 3 인 `vector` 를 만들었지만 4 번째 원소를 요청하고 있다. 위와 같은 코드는 문법 상 아무 문제가 없는 코드이지만, 막상 실행하게 되면 오류가 발생하게 된다.

다른 예로 아래와 같이 큰 메모리를 할당하는 경우를 생각해봅시다.
```cpp
std::vector<int> v(1000000000);
// ?
```
우리가 사용하는 대부분의 시스템의 경우 위와 같이 큰 메모리를 할당할 수 없다. 따라서, 위 코드 역시 문법 상 틀린 것이 없는 코드이지만, 실제로 실행해보면 오류가 발생하게 된다.

이렇게 정상적인 상황에서 벗어난 모든 예외적인 상황들을 **예외(exception)** 라고 부른다.

## 기존의 예외 처리 방식

C 언어에서는 언어 차원에서 제공하는 예외 처리 방식이라는 것이 딱히 따로 존재하지 않았다. 따라서 아래와 같이, 어떤 작업을 실행한 뒤에 그 결과값을 확인하는 방식으로 처리했다. 예를 들어, 아래 [malloc](https://modoocode.com/243) 으로 메모리를 동적으로 할당하는 경우를 생각해보자.
```c
char *c = (char *)malloc(1000000000);
if (c == NULL) {
	printf("메모리 할당 오류!");
	return;
}
```
[malloc](https://modoocode.com/243) 의 경우 메모리 할당 실패시에 `NULL` 을 리턴하므로, 위와 같이 `c` 가 `NULL` 인지 확인함으로써 예외적인 상황을 처리할 수 있었다.

하지만 이러한 방식으로 예외를 처리한다면, 함수가 깊어지면 깊어질수록 꽤나 귀찮게 된다.
```c
bool func1(int *addr) {
	if (func2(addr)) {
		// Do something
	}
	return false;
}
bool func2(int *addr) {
	if (func3(addr)) {
		// Do something
	}
	return false;
}
bool func3(int *addr) {
	addr = (int *)malloc(100000000);
	if (addr == NULL) return false;
	return true;
}
int main() {
	int *addr;
	if (func1(addr)) {
		// 잘 처리됨
	} else {
		// 오류 발생
	}
}
```
위 코드의 경우 `func3` 에서 '예외가 발생할 수 있는 작업' 을 수행하는데, 만약에 예외가 발생하게 된다면 `false` 를 리턴하게 되고, 잘 처리 되었다면 `true` 를 리턴한다.

여기까지는 좋은데, 문제는 이 `func3` 가 `func2` 에서 호출되고, 다시 `func2` 는 `func1` 에서 호출되고, `func1` 은 `main` 에서 호출된다는 점이다. 만약에 `main` 의 입장에서 `func3` 에서 문제가 발생했을 때 이를 캐치하기 위해서는, 각각의 함수들에서 처리 결과를 모두 리턴해야 할 것이다.

위 코드는 예외가 `func3`에서만 발생해서 간단했지만, 만약에 `func2` 도 어떤 다른 작업을 해서 예외를 발생시킬 수 있다면 어떻게 해야 할까? 상당히 골치 아픈 일이다.

하지만 다행히 C++ 에서는 위와 같은 불편한 예외 처리 방식을 획기적으로 해결했다.

## 예외 발생시키기 - throw

C 언어에서는 예외가 발생했을 때, 다른 값을 리턴하는 것으로 예외를 처리했지만, C++ 에서는 예외가 발생했다는 사실을 명시적으로 나타낼 수 있다. 바로 `throw` 문을 사용하면 된다.

예를 들어, 아래와 같이 매우 간단한 `vector` 클래스를 생각해보자.
```cpp
template <typename T>
class Vector {
public:
	Vector(size_t size) : size_(size) {
		data_ = new T[size_];
		for (int i = 0; i < size_; i++) {
			data_[i] = 3;
		}
	}
	const T& at(size_t index) const {
		if (index >= size_) {
			throw out_of_range("vector 의 index가 범위를 초과했습니다.");
		}
		return data_[index];
	}
	~Vector() { delete[] data_; }

private:
	T* data_;
	size_t size_;
};
```
만들어진 `vector` 의 요청한 위치에 있는 원소를 리턴하는 함수인 `at` 함수를 생각해보자.

> [!NOTE]
> at 함수는 operator[] 와 같이 index 로 전달된 위치에 있는 원소를 리턴한다. 하지만 차이점으로, at 의 경우 const 객체를 리턴해서, 이를 변경할 수 없다.

인자로 전달된 `index` 가 범위 이내라면, 간단하게 `data[index]` 를 리턴하면 되겠지만, 범위 밖이라면 어떻게 해야 할까?

문제는 `at` 함수가 `const T&` 를 리턴하기 때문에, 따로 '오류 메세지' 를 리턴할 수 없다는 점이다. 하지만 C++ 에서는 다음과 같이 예외가 발생하였음을 명시적으로 알릴 수 있다.
```cpp
const T& at(size_t index) const {
	if (index >= size) {
		// 예외를 발생시킨다!
		throw std::out_of_range("vector 의 index 가 범위를 초과하였습니다.");
	}
	return data[index];
}
```
먼저, 예외를 발생시키는 부분을 자세히 살펴보자.
```cpp
throw std::out_of_range("vector 의 index 가 범위를 초과하였습니다.");
```
C++ 에는 예외를 던지고 싶다면, `throw` 로 예외로 전달하고 싶은 객체를 써주면 된다. 예외로 아무 객체나 던져도 상관 없지만, C++ 표준 라이브러리에는 이미 여러가지 종류의 예외들이 정의되어 있어서 이를 활용하는 것도 좋다. 예를 들어서, 위 경우 `out_of_range` 객체를 `throw` 한다. C++ 표준에는 `out_of_range` 외에도 `overflow_error, length_error, runtime_error` 등등 여러가지가 정의되어 있고 표준 라이브러리에서 활용되고 있다.

이렇게 예외를 `throw` 하게 되면, `throw` 한 위치에서 즉시 함수가 종료되고, 예외 처리하는 부분까지 점프하게 된다. 따라서 `throw` 밑에 있는 모든 문장은 실행되지 않는다. 한 가지 중요한 점은 이렇게 함수에서 예외 처리하는 부분에 도달하기까지 함수를 빠져나가면서, `stack` 에 생성되었던 객체들을 빠짐없이 소멸시켜 준다는 점이다. 따라서 예외가 발생해도 사용하고 있는 자원들을 제대로 소멸시킬 수 있다(소멸자만 제대로 작성했다면)!

## 예외 처리하기 - try/catch

그렇다면 이렇게 발생한 에외를 어떻게 처리할까?
```cpp
#include <iostream>
#include <stdexcept>

template <typename T>
class Vector {
public:
	Vector(size_t size) : size_(size) {
		data_ = new T[size_];
		for (int i = 0; i < size_; i++) {
			data_[i] = 3;
		}
	}
	const T& at(size_t index) const {
		if (index >= size_) {
			throw std::out_of_range("vector 의 index 가 범위를 초과하였습니다.");
		}
		return data_[index];
	}
	~Vector() { delete[] data_; }

private:
	T* data_;
	size_t size_;
};
int main() {
	Vector<int> vec(3);
	
	int index, data = 0;
	std::cin >> index;
	
	try {
		data = vec.at(index);
	} catch (std::out_of_range& e) {
		std::cout << "예외 발생 ! " << e.what() << std::endl;
	}
	// 예외가 발생하지 않았다면 3을 이 출력되고, 예외가 발생하였다면 원래 data 에
	// 들어가 있던 0 이 출력된다.
	std::cout << "읽은 데이터 : " << data << std::endl;
}
```
```cpp
std::vector<int> v(3);  // 크기가 3 인 벡터 만듦
std::cout << v.at(4);   // ??
```
위 경우, 크기가 3 인 `vector` 를 만들었지만 4 번째 원소를 요청하고 있다. 위와 같은 코드는 문법 상 아무 문제가 없는 코드이지만, 막상 실행하게 되면 오류가 발생하게 된다.

다른 예로 아래와 같이 큰 메모리를 할당하는 경우를 생각해봅시다.
```cpp
std::vector<int> v(1000000000);
// ?
```
우리가 사용하는 대부분의 시스템의 경우 위와 같이 큰 메모리를 할당할 수 없다. 따라서, 위 코드 역시 문법 상 틀린 것이 없는 코드이지만, 실제로 실행해보면 오류가 발생하게 된다.

이렇게 정상적인 상황에서 벗어난 모든 예외적인 상황들을 **예외(exception)** 라고 부른다.

## 기존의 예외 처리 방식

C 언어에서는 언어 차원에서 제공하는 예외 처리 방식이라는 것이 딱히 따로 존재하지 않았다. 따라서 아래와 같이, 어떤 작업을 실행한 뒤에 그 결과값을 확인하는 방식으로 처리했다. 예를 들어, 아래 [malloc](https://modoocode.com/243) 으로 메모리를 동적으로 할당하는 경우를 생각해보자.
```c
char *c = (char *)malloc(1000000000);
if (c == NULL) {
	printf("메모리 할당 오류!");
	return;
}
```
[malloc](https://modoocode.com/243) 의 경우 메모리 할당 실패시에 `NULL` 을 리턴하므로, 위와 같이 `c` 가 `NULL` 인지 확인함으로써 예외적인 상황을 처리할 수 있었다.

하지만 이러한 방식으로 예외를 처리한다면, 함수가 깊어지면 깊어질수록 꽤나 귀찮게 된다.
```c
bool func1(int *addr) {
	if (func2(addr)) {
		// Do something
	}
	return false;
}
bool func2(int *addr) {
	if (func3(addr)) {
		// Do something
	}
	return false;
}
bool func3(int *addr) {
	addr = (int *)malloc(100000000);
	if (addr == NULL) return false;
	return true;
}
int main() {
	int *addr;
	if (func1(addr)) {
		// 잘 처리됨
	} else {
		// 오류 발생
	}
}
```
위 코드의 경우 `func3` 에서 '예외가 발생할 수 있는 작업' 을 수행하는데, 만약에 예외가 발생하게 된다면 `false` 를 리턴하게 되고, 잘 처리 되었다면 `true` 를 리턴한다.

여기까지는 좋은데, 문제는 이 `func3` 가 `func2` 에서 호출되고, 다시 `func2` 는 `func1` 에서 호출되고, `func1` 은 `main` 에서 호출된다는 점이다. 만약에 `main` 의 입장에서 `func3` 에서 문제가 발생했을 때 이를 캐치하기 위해서는, 각각의 함수들에서 처리 결과를 모두 리턴해야 할 것이다.

위 코드는 예외가 `func3`에서만 발생해서 간단했지만, 만약에 `func2` 도 어떤 다른 작업을 해서 예외를 발생시킬 수 있다면 어떻게 해야 할까? 상당히 골치 아픈 일이다.

하지만 다행히 C++ 에서는 위와 같은 불편한 예외 처리 방식을 획기적으로 해결했다.

{
	"nodes":[
		{"id":"9a598b39cb856d3b","type":"file","file":"Projects/Study/OS/VirtualMemory/md/가상 메모리(Virtual Memory).md","x":-400,"y":-20,"width":625,"height":1043},
		{"id":"98029daaf949d618","type":"file","file":"Projects/Study/OS/VirtualMemory/md/페이징(Paging).md","x":-920,"y":-620,"width":691,"height":352},
		{"id":"1d10639d1e380c0e","type":"file","file":"Projects/Study/OS/VirtualMemory/md/페이지 테이블 크기.md","x":-1357,"y":-1180,"width":783,"height":381},
		{"id":"b61d9a502d186a1a","type":"file","file":"Projects/Study/OS/VirtualMemory/md/TLB(Translation Lookahead Buffer).md","x":-420,"y":-1147,"width":545,"height":348},
		{"id":"5d3d0d99d36d19a9","type":"text","text":"- 32비트 주소체계, 4KB 페이지 크기, 페이지 테이블 항목이 4B\n\t- 전체 페이지 테이블 크기 = 2^20개 PTE * 4B -> 4MB 크기의 전체 페이지 테이블\n\t- 4MB 페이지 테이블/페이지 크기(4KB) 수만큼의 2단계 페이지를 구성해 이 페이지들 안에 4KB 만큼의 페이지 테이블들을 기록하여 가상기억공간에 할당\n\t- 주기억장치에 존재하는 루트 페이지테이블을 이용 필요한 2단계 페이지 테이블을 접근\n![[Pasted image 20240124211327.png]]","x":-1880,"y":-1800,"width":745,"height":417},
		{"id":"9758a39423ec4485","type":"text","text":"- 기존의 프로세스 별 페이지 테이블을 검색할 때 주기억장치에 커다란 페이지 테이블을 올리고 검색하는 문제점 발생 -> 개**수가 적은 프레임 메모리를 중심으로 검색(역발상)**\n- 운영체제는 모든 프로세스가 공통으로 사용하는 역 페이지 테이블을 별도로 생성\n\t- **프레임 당 하나의 페이지테이블 항목(PTE)으로 역 페이지 테이블을 구성**하고 이 짧아진 테이블을 **주기억장치**에 위치 -> PTE 개수가 **물리메모리의 프레임 개수로 결정**\n\t- 기존의 프로세스 별 페이지 테이블 관리는 동일\n- 처리기가 페이지 번호 발생 시 MMU는 **역 페이지 테이블 내에서 페이지 번호를 검색**하여 존재 시 여기에 연결되어 있는 **프레임 번호**를 바로 참고하는 역발상 기법\n- 하나의 프레임을 여러 개의 프로세스가 이용할 수 있으므로 검색 시에 **프로세스 ID**도 확인 필요\n- 일반적으로 속도 향상을 위해 **해시(Hash)기법**을 이용\n\t- 해시함수를 이용하고 중복을 위한 연결(체인) 기법 사용","x":-1055,"y":-1718,"width":766,"height":335},
		{"id":"916c9cbe7c0f7464","type":"text","text":"- TLB 내에 원하는 페이지 번호가 있는지는 연관사상 방식으로 검색 -> 연관 검색\n\t- TLB 내에 모든 페이지 번호들이 있지 않기 때문에 빠른 연관메모리와 하드웨어의 도움을 받아 전체 TLB 내에서 원하는 페이지 번호가 있는지를 빠르게 검색","x":-217,"y":-1477,"width":685,"height":94},
		{"id":"d8adec7a1bf2ebcf","type":"text","text":"- 연관 기억 장치 또는 내용 지정 메모리(CAM: Content Addressable Memory)\n- 병렬 판독 회로를 내장하고 있어서 한번에 전체 내용의 비교 가능\n\t- 캐시 메모리 보다도 훨씬 빠르나 가격이 매우 비싸다\n- 작은 용량의 IC 메모리를 사용하며 캐시 메모리나 가상 메모리(TLB)의 주소 검색에 많이 사용\n### 구성\n- 검색 데이터 레지스터\n\t- 찾고자 하는 내용의 일부분을 입력\n- 마스크 레지스터\n\t- 검색에 필요 없는 부분을 마스크\n- CAM 영역\n\t- 태그+데이터를 한 라인으로 하여 m개의 라인\n- 일치 레지스터\n\t- 태그 영역에서 일치하는 단어를 찾았을 경우 해당 태그의 데이터 영역 값을 출력","x":-152,"y":-2100,"width":556,"height":522},
		{"id":"c003c5a3e71edfff","type":"file","file":"Projects/Study/OS/VirtualMemory/md/페이지 크기.md","x":-1920,"y":-592,"width":780,"height":296},
		{"id":"64801c3a3fcad815","type":"file","file":"Projects/Study/OS/VirtualMemory/resources/Pasted image 20240124212835.png","x":-2000,"y":-989,"width":581,"height":291},
		{"id":"7bfd7100c36b32f7","type":"file","file":"Projects/Study/OS/VirtualMemory/md/세그먼테이션(segmentation).md","x":-75,"y":-457,"width":643,"height":184},
		{"id":"16cad29a67508126","type":"text","text":"- **세그먼트 크기의 동적 설정**\n\t- 확장성 자료구조에 대한 처리 단순화 가능\n\t- 필요 시 운영체제가 해당 세그먼트 크기를 축소, 확대(필요 시 위치 이동까지) 가능\n\t- 공간이 없을 경우 세그먼트 단위로 스왑-아웃, 스왑-인 가능\n- **세그먼트 별로 독립적인 수정, 재컴파일 가능**\n\t- 프로그램 전체에 대한 재연결(relink), 재적재(reloading) 없이도 가능\n- **세그먼트 공유**\n\t- 프로그래머가 지정하면 프로세스들이 세그먼트를 공유할 수 있다.\n- **세그먼트 보호**\n\t- 논리적 개체(유틸리티 코드, 데이터 테이블 등)를 세그먼트로 설정하여 공유/보호 가능\n\t- 프로그래머나 시스템 관리자가 기능을 부여할 수 있다.","x":810,"y":-584,"width":739,"height":342},
		{"id":"ac680f1238279963","type":"file","file":"Projects/Study/OS/VirtualMemory/md/페이징과 세그먼테이션의 결합.md","x":179,"y":-1076,"width":579,"height":492},
		{"id":"d91d00f1c7b302be","type":"file","file":"Projects/Study/OS/VirtualMemory/md/지역성(Locality)의 원리.md","x":-773,"y":1305,"width":544,"height":362},
		{"id":"933b46546eb6c875","type":"file","file":"Projects/Study/OS/VirtualMemory/md/가상메모리의 실용성.md","x":-53,"y":1305,"width":642,"height":916},
		{"id":"f5afcd0014b208ef","type":"file","file":"Projects/Study/OS/VirtualMemory/md/페이지 테이블 구조.md","x":641,"y":1601,"width":760,"height":503},
		{"id":"298d6247f8b29341","type":"text","text":"- **보다 많은 개수의 프로세스를 주기억장치에 유지할 수 있다.**\n\t- 준비 상태 프로세스가 존재할 가능성이 높아져 처리기 활용도가 높아진다.\n- **주기억장치보다 큰 프로세스를 수행할 수 있다.**\n\t- 오버레이 기법을 적용하기 위한 프로그래머의 부담을 운영체제가 담당한다.","x":661,"y":-103,"width":519,"height":190},
		{"id":"9712ae46e94a717d","type":"text","text":"- 가상주소를 물리주소로 변환하는 과정은 **MMU(메모리 관리장치)**에 의해 수행\n- 주소 간의 변환관계를 정의한 정보는 **페이지 테이블(Page Table)**에 보관 <- OS가 관리\n![[Pasted image 20240124031836.png]]\n![[Pasted image 20240124031951.png]]\n\n- 가상 주소공간은 4GB 공간이고 페이지 크기가 4KB일 때\n- 논리주소가 0000 0000 0000 0001 1001 / 0000 0000 0011b일 경우 -> 페이지 번호 25, 변위는 3\n\t- 페에지 테이블의 25위치에 저장된 프레임 번호는 00002, 페이지 변위가 003이므로\n\t- 생성되는 물리적 주소는 (00002#003)16 = (00002003)16 = (8195)10\n![[Pasted image 20240124035314.png]]","x":661,"y":181,"width":720,"height":1180},
		{"id":"6bc29ca54ae4aa07","type":"file","file":"Projects/Study/OS/VirtualMemory/md/가상메모리 동작원리.md","x":1661,"y":520,"width":760,"height":503},
		{"id":"5980e181740b871e","x":-1480,"y":422,"width":80,"height":267,"type":"text","text":"즉, 가상 메모리란 프로그램이 혼자 메모리를 사용하는 것처럼 메모리를 가상화 한 것을 말한다.\n\n멀티태스킹이 없던 옛날에는 항상 하나의 프로그램이 모든 메모리를 직접 사용한다는 전제하에 만들었다. 이후 멀티태스킹이 도입될 때 문제가 되던 것 중에 하나가 각자의 프로그램이 동시에 작동한다고 했을 때 메모리를 어떻게 분배할지에 대한 것이 있었다.\n\n일반적으로 프로그램이 메모리에 데이터를 읽거나 쓸 때 실행 파일에 저장된 특정 위치에 특정 데이터를 저장한다. 이때 만약 같은 프로그램을 2개 실행한다고 하면 두 프로그램이 메모리의 같은 위치에 데이터를 읽고 쓰게 되고, 두 프로그램이 서로 충돌해 오동작하게 된다.\n\n이를 해결하기 위한 여러 방법들 중 하나가 각 프로그램이 별도의 메모리를 혼자 사용하는 것처럼 가상화하는 것이다."}
	],
	"edges":[
		{"id":"457e469b8fea6eb8","fromNode":"9a598b39cb856d3b","fromSide":"right","toNode":"298d6247f8b29341","toSide":"left","label":"부분적재 수행 이점"},
		{"id":"f69a987866a3315e","fromNode":"9a598b39cb856d3b","fromSide":"right","toNode":"9712ae46e94a717d","toSide":"left","label":"가상메모리/물리메모리 매핑"},
		{"id":"f72c2d7c166bd8ad","fromNode":"9712ae46e94a717d","fromSide":"bottom","toNode":"f5afcd0014b208ef","toSide":"top","label":"페이지 테이블 구조"},
		{"id":"78fd43ed903137df","fromNode":"9712ae46e94a717d","fromSide":"right","toNode":"6bc29ca54ae4aa07","toSide":"left","label":"동작원리"},
		{"id":"ce39dc92e00998f7","fromNode":"9a598b39cb856d3b","fromSide":"bottom","toNode":"933b46546eb6c875","toSide":"top","label":"실용성"},
		{"id":"a421942ed10051c7","fromNode":"9a598b39cb856d3b","fromSide":"bottom","toNode":"d91d00f1c7b302be","toSide":"top","label":"지역성의 원리"},
		{"id":"e9bafac9c77b1fd6","fromNode":"9a598b39cb856d3b","fromSide":"top","toNode":"98029daaf949d618","toSide":"bottom","label":"페이징"},
		{"id":"12e6b1c65bc144c5","fromNode":"98029daaf949d618","fromSide":"top","toNode":"1d10639d1e380c0e","toSide":"bottom","label":"페이지 테이블 크기"},
		{"id":"44122db28596dddf","fromNode":"1d10639d1e380c0e","fromSide":"top","toNode":"5d3d0d99d36d19a9","toSide":"bottom","label":"n-단계 페이지 테이블(2단계 예시)"},
		{"id":"de1138d9d447d363","fromNode":"1d10639d1e380c0e","fromSide":"top","toNode":"9758a39423ec4485","toSide":"bottom","label":"역 페이지 테이블"},
		{"id":"12f0ac058b561005","fromNode":"98029daaf949d618","fromSide":"top","toNode":"b61d9a502d186a1a","toSide":"bottom","label":"TLB"},
		{"id":"435160c7a66ede04","fromNode":"b61d9a502d186a1a","fromSide":"top","toNode":"916c9cbe7c0f7464","toSide":"bottom","label":"TLB에 대한 연관사상"},
		{"id":"a15e13840b2ac0cb","fromNode":"916c9cbe7c0f7464","fromSide":"top","toNode":"d8adec7a1bf2ebcf","toSide":"bottom","label":"연관 메모리(Associative Memory) - 연관 검색"},
		{"id":"53eefea3b2ad8f22","fromNode":"98029daaf949d618","fromSide":"left","toNode":"c003c5a3e71edfff","toSide":"right","label":"페이지 크기"},
		{"id":"1e0cccbead233c1f","fromNode":"c003c5a3e71edfff","fromSide":"top","toNode":"64801c3a3fcad815","toSide":"bottom"},
		{"id":"b058c595841eb004","fromNode":"9a598b39cb856d3b","fromSide":"top","toNode":"7bfd7100c36b32f7","toSide":"bottom","label":"세그먼테이션"},
		{"id":"7dd86e8503d54725","fromNode":"7bfd7100c36b32f7","fromSide":"right","toNode":"16cad29a67508126","toSide":"left","label":"장점"},
		{"id":"47305efcd2b3efe1","fromNode":"7bfd7100c36b32f7","fromSide":"top","toNode":"ac680f1238279963","toSide":"bottom","label":"페이징과의 결합"},
		{"id":"b6cc2896424226ea","fromNode":"9a598b39cb856d3b","fromSide":"left","toNode":"5980e181740b871e","toSide":"right"}
	]
}
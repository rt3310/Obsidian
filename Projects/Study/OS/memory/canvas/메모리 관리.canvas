{
	"nodes":[
		{"id":"3c23aea662b6ad82","type":"text","text":"- 연속 메모리 관리\n- 불연속 메모리 관리","x":596,"y":-143,"width":237,"height":64},
		{"id":"438184394c8f8582","type":"text","text":"> [!INFO]\n> 메모리 집약과는 다르게 이동은 하지 않고 단지 연속된 빈 공간들을 모아서 더 큰 공간을 만드는 것을 **통합(garbage collection)**이라고 한다.","x":2133,"y":-143,"width":592,"height":154,"color":"#0000ff"},
		{"id":"8f8ced8f0d5f3b65","type":"file","file":"Projects/Study/OS/memory/md/메모리 집약 vs 메모리 통합.md","x":2913,"y":-176,"width":715,"height":220},
		{"id":"5981179a0fc035f7","type":"file","file":"Projects/Study/OS/memory/md/동적 분할.md","x":2135,"y":-564,"width":588,"height":280},
		{"id":"8c2fec2be65feb97","type":"file","file":"Projects/Study/OS/memory/md/배치 알고리즘.md","x":2935,"y":-578,"width":660,"height":309},
		{"id":"d194936f7b285366","type":"file","file":"Projects/Study/OS/memory/md/균등 분할.md","x":2935,"y":-1202,"width":440,"height":188},
		{"id":"93a919bfb6b2da49","type":"file","file":"Projects/Study/OS/memory/md/비균등 분할.md","x":2935,"y":-860,"width":424,"height":218},
		{"id":"57fb5db33a6670c1","type":"text","text":"- 프로그램이 파티션보다 클 경우 -> overlay 기법 필요\n- 주기억장치 이용률 저조\n- 내부단편화 발생","x":3555,"y":-1156,"width":471,"height":96},
		{"id":"41cc81e78b95570c","type":"text","text":"- 파티션 수에 의해 활성화 된 프로세스 수 제한\n- 크기가 작은 작업일수록 파티션 공간을 비효율적으로 사용\n- 내부 단편화 발생","x":3535,"y":-799,"width":511,"height":96},
		{"id":"5c44bdeee23d5cdd","type":"file","file":"Projects/Study/OS/memory/md/연속 메모리 관리.md","x":1280,"y":-794,"width":701,"height":220},
		{"id":"32ae751b00adf2f0","type":"file","file":"Projects/Study/OS/memory/md/버디(Buddy) 시스템.md","x":1329,"y":-1118,"width":603,"height":181},
		{"id":"354f49708636790a","type":"file","file":"Projects/Study/OS/memory/md/고정 분할.md","x":2135,"y":-1014,"width":677,"height":154},
		{"id":"3863cd4d62ed4c8c","type":"file","file":"Projects/Study/OS/memory/md/단편화(Fragmentation).md","x":413,"y":-794,"width":604,"height":253},
		{"id":"918a071ee1e6c80c","type":"text","text":"- 재배치(Relocation)\n- 보호(Protection)\n- 공유(Sharing)\n- 논리적 구성(Logical organization)\n- 물리적 구성(Physical organization)","x":-1028,"y":-192,"width":343,"height":163},
		{"id":"26f7aeefe02b2574","type":"file","file":"Projects/Study/OS/memory/md/재배치(Relocation).md","x":-1274,"y":-722,"width":589,"height":119},
		{"id":"f1185f216a15c7e5","type":"text","text":"- 논리 주소\n\t- 데이터가 적재된 메모리와는 독립적인 위치에 대한 참조로 접근전에 물리주소로 변환 필요\n\t- 처리기, 운영체제가 관리 (ex: 가상 메모리)\n- 상대 주소\n\t- 처리기의 레지스터 값으로부터 떨어진 주소\n- 물리 주소(절대 주소)\n\t- 주기억장치 내의 실제 주소","x":-880,"y":-1139,"width":458,"height":259},
		{"id":"9cc049e80f0f7ea7","type":"text","text":"- 적재 시 베이스(시작 주소)/경계 레지스터 사용\n- 실행 시 처리기는 '베이스 + 상대 주소'를 사용\n\t- 경계 범위 밖이면 인터럽트 발생(보호)","x":-1540,"y":-1057,"width":426,"height":96},
		{"id":"f5cf05458f2eb94e","type":"file","file":"Projects/Study/OS/memory/md/보호(Protection).md","x":-1967,"y":-756,"width":640,"height":187},
		{"id":"024e43ba5b21e256","type":"file","file":"Projects/Study/OS/memory/md/공유(Sharing).md","x":-2160,"y":-204,"width":688,"height":188},
		{"id":"4f0553220394ab9a","type":"file","file":"Projects/Study/OS/memory/md/물리적인 구성.md","x":-1271,"y":360,"width":620,"height":220},
		{"id":"a084a1b10be6ef6b","type":"text","text":"- 모듈의 작성과 컴파일이 독립적으로 이루어진다.\n- 비교적 적은 추가비용으로 모듈마다 서로 다른 보호 등급을 적용할 수 있다.\n- 프로세스 간 모듈 공유 기법을 제공한다.","x":-2045,"y":622,"width":641,"height":96},
		{"id":"b81205c4aa37ebe5","type":"file","file":"Projects/Study/OS/memory/md/논리적인 구성.md","x":-1978,"y":300,"width":506,"height":121},
		{"id":"c67247f8582359cc","type":"file","file":"Projects/Study/OS/memory/md/불연속 메모리 관리.md","x":1280,"y":232,"width":604,"height":238},
		{"id":"f71eaa91927a4198","type":"file","file":"Projects/Study/OS/memory/md/페이징.md","x":2083,"y":259,"width":640,"height":184},
		{"id":"ab819c9cb4fec40d","type":"text","text":"- 외부 단편화 발생 안함 -> 프로세스가 하나가 아니라 쪼개져 있다\n- 내부 단편화\n\t- 각 프로세스의 마지막 페이지에서만 발생 (프레임 = 페이지)\n- 단순 페이징\n\t- 고정 분할 방법과 유사","x":2992,"y":270,"width":557,"height":163},
		{"id":"e4368f9ce9ae6ba8","type":"text","text":"- **페이지(page)**: 작은 고정 사이즈의 프로세스 조각\n- **프레임(frame)**: 페이지와 크기가 같은 주기억장치 메모리 조각\n- **페이지 테이블**: 프로세스의 각 페이지에 해당하는 프레임 위치 관리","x":2118,"y":80,"width":571,"height":96,"color":"5"},
		{"id":"b3f736fcaed50e94","type":"text","text":"- 페이지 크기(=프레임 크기)는 2의 거듭제곱으로 구성\n\t- MMU 하드웨어의 구현이 간단\n\t- 논리 주소(페이지 번호, 오프셋) = 상대주소\n\t- ex) 64K 주소공간을 1K 단위의 페이지로 나눈 경우\n\t\t- 페이지 개수 = 64K / 1K (페이지 크기) = 64개\n\t\t- 주소 16bit = 페이지 번호 6bit + 오프셋 10bit\n\t\t- 논리주소 1502d = 000001 0111011110(2)","x":2159,"y":560,"width":489,"height":229},
		{"id":"39ee70b453ea2299","type":"file","file":"Projects/Study/OS/memory/md/세그먼테이션.md","x":1236,"y":740,"width":692,"height":220},
		{"id":"fb6220af2bbfe216","type":"text","text":"- 세그먼트 크기를 프로그래머가 알아야 한다.\n- 논리주소와 물리주소 관계가 복잡하다.","x":2118,"y":850,"width":409,"height":66},
		{"id":"28bd8edc5be1a8f5","type":"file","file":"Projects/Study/OS/memory/md/메모리 관리.md","x":-400,"y":-220,"width":694,"height":218},
		{"id":"dd1f4e279a11de73","type":"text","text":"주기억장치 = 운영체제 + 수행 중인 프로그램을 위한 공간","x":-289,"y":-360,"width":473,"height":29},
		{"id":"2471c00b40aeec50","type":"text","text":"- 페이지: 고정크기\n- 세그먼트: 가변크기 + 보호","x":1438,"y":1161,"width":288,"height":64,"color":"5"},
		{"id":"6686d6f3fef91545","x":-480,"y":382,"width":546,"height":176,"type":"file","file":"Projects/Study/OS/memory/md/MMU.md"},
		{"id":"89516f1cd7d26e72","x":244,"y":80,"width":523,"height":223,"type":"text","text":"- 모든 프로세스마다 같은 주소를 사용할 수 있게 한다.\n\t- 실제 물리 주소가 13번지, 15번지, 29번지 일 때 MMU는 가상주소로 이를 모두 1번지로 표현할 수 있다.\n- CPU는 프로세스 관리 및 구현이 간단하다.\n- 서로 떨어져 있는 데이터를 연속된 데이터를 표현할 수 있다.\n\t- 실제 물리 주소가 13번지, 15번지, 29번지 일 때 연속된 데이터처럼 1번지, 2번지, 3번지로 표현이 가능하다."},
		{"id":"54d703622a03d6f6","x":320,"y":514,"width":471,"height":88,"type":"text","text":"프로세스는 독립적인 메모리 공간을 가져야 한다.\n따라서 MMU는 한 프로세스에게 합법적인 주소 영역을 설정하고, 잘못된 접근이 오면 trap을 발생시키며 보호한다."},
		{"id":"99c47ad550d6f23a","type":"file","file":"Projects/Study/OS/memory/md/프로세스 활성화.md","x":-614,"y":1520,"width":733,"height":188},
		{"id":"923a42761ea55c92","type":"file","file":"Projects/Study/OS/memory/md/로딩.md","x":-1016,"y":1870,"width":694,"height":386},
		{"id":"40e58106e84afe41","type":"file","file":"Projects/Study/OS/memory/md/링킹.md","x":-85,"y":1873,"width":681,"height":283},
		{"id":"92cec3cc7d73fc97","x":239,"y":776,"width":633,"height":184,"color":"#0000ff","type":"text","text":"> [!INFO]\n> **base와 limit 레지스터를 활용한 메모리 보호 기법**\n> base 레지스터: 메모리 상의 프로세스 시작 주소를 물리 주소로 저장\n> limit 레지스터: 프로세스의 사이즈를 저장"},
		{"id":"df9c73af487e2d9f","x":-496,"y":684,"width":579,"height":386,"type":"file","file":"Projects/Study/OS/memory/md/메모리 과할당(Over Allocating).md"},
		{"id":"5eb66f82088f88ff","x":-480,"y":1180,"width":551,"height":175,"type":"file","file":"Projects/Study/OS/memory/md/Swapping 기법.md"},
		{"id":"82091ca1c9e20713","x":-1304,"y":684,"width":687,"height":493,"type":"text","text":"오버레이 기법은 주기억장치보다 큰 사용자 프로그램을 실행하기 위한 기법이다.\n\n보조기억장치에 저장된 하나의 프로그램을 여러 개의 조각으로 분할한 후 필요한 조각을 차례로 주기억장치에 적재하여 프로그램을 실행한다.\n\n프로그램이 실행되면서 주기억장치의 공간이 부족하면 주기억장치에 적재된 프로그램의 조각 중 불필요한 조각이 위치한 장소에 프로그램이 조각을 중첩(Overlay)하여 적재한다.\n![[Pasted image 20240107225608.png]]"}
	],
	"edges":[
		{"id":"5b612337588bbd15","fromNode":"28bd8edc5be1a8f5","fromSide":"left","toNode":"918a071ee1e6c80c","toSide":"right","label":"요구조건"},
		{"id":"08221c19f3dc00cf","fromNode":"28bd8edc5be1a8f5","fromSide":"top","toNode":"dd1f4e279a11de73","toSide":"bottom","label":"주기억장치"},
		{"id":"e6e95f0774b00a86","fromNode":"918a071ee1e6c80c","fromSide":"top","toNode":"26f7aeefe02b2574","toSide":"bottom","label":"재배치"},
		{"id":"af4944b77e88c036","fromNode":"918a071ee1e6c80c","fromSide":"top","toNode":"f5cf05458f2eb94e","toSide":"bottom","label":"보호"},
		{"id":"f0d02403fa6b2941","fromNode":"918a071ee1e6c80c","fromSide":"left","toNode":"024e43ba5b21e256","toSide":"right","label":"공유"},
		{"id":"6fbbce06524a65a2","fromNode":"918a071ee1e6c80c","fromSide":"bottom","toNode":"b81205c4aa37ebe5","toSide":"top","label":"논리적인 구성"},
		{"id":"174c9d74f56ab696","fromNode":"b81205c4aa37ebe5","fromSide":"bottom","toNode":"a084a1b10be6ef6b","toSide":"top","label":"운영체제 및 하드웨어의 모듈 단위 처리 시 이점"},
		{"id":"9c859b0cd23abd1e","fromNode":"918a071ee1e6c80c","fromSide":"bottom","toNode":"4f0553220394ab9a","toSide":"top","label":"물리적인 구성"},
		{"id":"a6c99e5e40ff7044","fromNode":"28bd8edc5be1a8f5","fromSide":"right","toNode":"3c23aea662b6ad82","toSide":"left","label":"메모리 분할"},
		{"id":"a3d5db0f5f424bc8","fromNode":"3c23aea662b6ad82","fromSide":"right","toNode":"5c44bdeee23d5cdd","toSide":"left","label":"연속 메모리 관리"},
		{"id":"50fd57a29bf14bac","fromNode":"3c23aea662b6ad82","fromSide":"right","toNode":"c67247f8582359cc","toSide":"left","label":"불연속 메모리 관리"},
		{"id":"91eb92e61ee6ee3a","fromNode":"3c23aea662b6ad82","fromSide":"top","toNode":"3863cd4d62ed4c8c","toSide":"bottom","label":"메모리 분할 문제"},
		{"id":"92a01e0804d6fbaf","fromNode":"5c44bdeee23d5cdd","fromSide":"right","toNode":"354f49708636790a","toSide":"left","label":"고정 분할"},
		{"id":"53369e16e234f705","fromNode":"354f49708636790a","fromSide":"right","toNode":"d194936f7b285366","toSide":"left","label":"균등 분할"},
		{"id":"6f0440bed1f4e6ac","fromNode":"354f49708636790a","fromSide":"right","toNode":"93a919bfb6b2da49","toSide":"left","label":"비균등 분할"},
		{"id":"4f57927e3d86e84f","fromNode":"d194936f7b285366","fromSide":"right","toNode":"57fb5db33a6670c1","toSide":"left","label":"문제점"},
		{"id":"5ac4b2606555cf32","fromNode":"93a919bfb6b2da49","fromSide":"right","toNode":"41cc81e78b95570c","toSide":"left","label":"문제점"},
		{"id":"55b1e50c4b9cf159","fromNode":"5c44bdeee23d5cdd","fromSide":"right","toNode":"5981179a0fc035f7","toSide":"left","label":"동적 분할"},
		{"id":"a3eaebc20f67dcba","fromNode":"5981179a0fc035f7","fromSide":"bottom","toNode":"438184394c8f8582","toSide":"top"},
		{"id":"3655825484c400b6","fromNode":"438184394c8f8582","fromSide":"right","toNode":"8f8ced8f0d5f3b65","toSide":"left","label":"집약 vs 통합"},
		{"id":"b076ba55c7283ba0","fromNode":"5981179a0fc035f7","fromSide":"right","toNode":"8c2fec2be65feb97","toSide":"left","label":"배치 알고리즘"},
		{"id":"04962aac36be70ea","fromNode":"5c44bdeee23d5cdd","fromSide":"top","toNode":"32ae751b00adf2f0","toSide":"bottom","label":"버디 시스템"},
		{"id":"4db093fc15f1fd3f","fromNode":"26f7aeefe02b2574","fromSide":"top","toNode":"f1185f216a15c7e5","toSide":"bottom","label":"재배치 지원 시 사용되는 주소 유형"},
		{"id":"6cd77ded24cd036e","fromNode":"26f7aeefe02b2574","fromSide":"top","toNode":"9cc049e80f0f7ea7","toSide":"bottom","label":"처리기에 의한 재배치"},
		{"id":"67fc894c04784fe1","fromNode":"c67247f8582359cc","fromSide":"right","toNode":"f71eaa91927a4198","toSide":"left"},
		{"id":"8d6c3312ed436bf1","fromNode":"f71eaa91927a4198","fromSide":"right","toNode":"ab819c9cb4fec40d","toSide":"left","label":"장점"},
		{"id":"ac97079c2f1b3d2e","fromNode":"f71eaa91927a4198","fromSide":"top","toNode":"e4368f9ce9ae6ba8","toSide":"bottom","label":"용어"},
		{"id":"6bb6bee847cd81fc","fromNode":"f71eaa91927a4198","fromSide":"bottom","toNode":"b3f736fcaed50e94","toSide":"top","label":"페이징 기법의 주소 관리"},
		{"id":"a94b9360461c4355","fromNode":"c67247f8582359cc","fromSide":"bottom","toNode":"39ee70b453ea2299","toSide":"top"},
		{"id":"916f10381bb66b22","fromNode":"39ee70b453ea2299","fromSide":"right","toNode":"fb6220af2bbfe216","toSide":"left","label":"문제점"},
		{"id":"2f7804c32cd4f52c","fromNode":"39ee70b453ea2299","fromSide":"bottom","toNode":"2471c00b40aeec50","toSide":"top","label":"페이지 vs 세그먼트"},
		{"id":"3d43a44aa43ac27b","fromNode":"99c47ad550d6f23a","fromSide":"bottom","toNode":"923a42761ea55c92","toSide":"top","label":"로딩"},
		{"id":"b84e5e7e2387cb11","fromNode":"99c47ad550d6f23a","fromSide":"bottom","toNode":"40e58106e84afe41","toSide":"top","label":"링킹"},
		{"id":"54f5efd9d59fbdba","fromNode":"4f0553220394ab9a","fromSide":"right","toNode":"6686d6f3fef91545","toSide":"left","label":"MMU?"},
		{"id":"97e6e620264d662f","fromNode":"6686d6f3fef91545","fromSide":"right","toNode":"89516f1cd7d26e72","toSide":"left","label":"장점"},
		{"id":"adf359ce93e4137e","fromNode":"6686d6f3fef91545","fromSide":"right","toNode":"54d703622a03d6f6","toSide":"left","label":"MMU의 메모리 보호"},
		{"id":"e41c6d56a8541c2f","fromNode":"54d703622a03d6f6","fromSide":"bottom","toNode":"92cec3cc7d73fc97","toSide":"top"},
		{"id":"9848ac8167588b34","fromNode":"6686d6f3fef91545","fromSide":"bottom","toNode":"df9c73af487e2d9f","toSide":"top","label":"메모리 과할당(Over Allocating)"},
		{"id":"066c1bc21917ba92","fromNode":"df9c73af487e2d9f","fromSide":"bottom","toNode":"5eb66f82088f88ff","toSide":"top","label":"Swapping 기법"},
		{"id":"45e90c3b53cf6858","fromNode":"4f0553220394ab9a","fromSide":"bottom","toNode":"82091ca1c9e20713","toSide":"top","label":"Overlay 기법"}
	]
}
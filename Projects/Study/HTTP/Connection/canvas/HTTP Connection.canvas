{
	"nodes":[
		{"id":"70c938aa690912f0","type":"group","x":-1320,"y":-640,"width":2720,"height":1880,"label":"무제 그룹"},
		{"id":"fbfcd8ae35fe5b67","type":"file","file":"Projects/Study/HTTP/Connection/md/HTTP 커넥션 성능 향상 기술.md","x":-2151,"y":-471,"width":402,"height":187},
		{"id":"8cc9b9580a8ff4d3","type":"file","file":"Projects/Study/HTTP/Connection/md/병렬 커넥션.md","x":-2760,"y":-866,"width":560,"height":266},
		{"id":"2689ce1341d03bb4","type":"text","text":"- 각 트랜잭션마다, 새로운 커넥션을 맺고 끊기 때문에 시간과 대역폭이 소요된다.\n- 각각의 새로운 커넥션은 TCP 느린 시작 때문에 성능이 떨어진다.\n- 실제로 연결할 수 있는 병렬 커넥션 수에는 제한이 있다.","x":-2426,"y":-1182,"width":550,"height":126},
		{"id":"bcb5b9c767a64470","type":"file","file":"Projects/Study/HTTP/Connection/md/지속 커넥션.md","x":-1837,"y":-994,"width":503,"height":394},
		{"id":"b8c24aa50b91b220","type":"text","text":"커넥션 관리가 제대로 이루어지지 않으면 TCP 성능이 매우 안좋아질 수 있다.\n순차적인 처리로 인한 지연에는 물리적인 지연뿐 아니라, 하나의 이미지를 내려받고 있는 중에는 웹페이지의 나머지공간에 아무런 변화가 없어서 느껴지는 심리적인 지연도 있다.\n\n순차적으로 로드하는 방식의 또 하나의 단점은, 특정 브라우저의 경우 객체를 화면에 배치하려면 객체의 크기를 알아야 하기 때문에, 모든 객체를 내려받기 전까지는 텅 빈 화면을 보여준다는 것이다. 이 경우 브라우저는 객체들을 연속해서 하나씩 내려받는 것이 효율적이겠으나, 사용자는 어떻게 진행되고 있는지 모르는 상태로 흰색의 텅 빈 화면만 보게 된다.","x":-2200,"y":-153,"width":500,"height":332},
		{"id":"5e803365927ed469","type":"file","file":"Projects/Study/HTTP/Connection/md/IP 패킷 구성.md","x":236,"y":483,"width":474,"height":154},
		{"id":"a7a6170af572e459","type":"text","text":"컴퓨터는 항상 TCP 커넥션을 여러 개 가지고 있다.\nTCP는 포트 번호를 통해서 이런 여러 개의 커넥션을 유지한다.\n\nTCP 커넥션은 네 가지 값으로 식별한다.\n**<발신지 IP 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트>**\n\n어떤 커넥션들은 같은 목적지 포트 번호를 가리킬 수 있다.\n하지만 네 가지 커넥션 구성요소를 모두 똑같이 가리키고 있는 커넥션은 있을 수 없다.","x":-594,"y":896,"width":561,"height":247},
		{"id":"fe7764d244e1d106","type":"file","file":"Projects/Study/HTTP/Connection/md/TCP 세그먼트 헤더 구성.md","x":216,"y":819,"width":515,"height":154},
		{"id":"a5942026ca893e5a","type":"file","file":"Projects/Study/HTTP/Connection/resources/IP 패킷.png","x":815,"y":819,"width":400,"height":375},
		{"id":"27a504d3b7b34e1a","type":"file","file":"Projects/Study/HTTP/Connection/md/병렬 커넥션 vs 지속 커넥션.md","x":-1848,"y":-1513,"width":526,"height":394},
		{"id":"bf93f49145ed3498","type":"text","text":"많은 HTTP/1.0 브라우저와 서버들은 일찍부터 다소 실험적이었던 keep-alive 커넥션이라는 지속 커넥션을 지원하기 위해 확장되었다.\n이 초기의 지속 커넥션은 상호 운용과 관련된 설계에 문제가 있었지만, 아직 많은 클라이언트와 서버는 이 초기 keep-alive 커넥션을 사용하고 있다. 그리고 설계상의 문제는 HTTP/1.1에서 수정되었다.","x":-1832,"y":-1874,"width":494,"height":208},
		{"id":"e8398d59c95e38f4","type":"text","text":"Keep-Alive 헤더는 커넥션을 유지하기를 바라는 요청일 뿐이다.\n클라이언트나 서버가 keep-alive 요청을 받았다고 해서 무조건 그것을 따를 필요는 없다. 언제든지 현재의 keep-alive 커넥션을 끊을 수 있으며 keep-alive 커넥션에서 처리되는 트랜잭션의 수를 제한할 수도 있다.\n- timeout\n\t- Keep-Alive 응답 헤더를 통해 보낸다.\n\t- 커넥션이 얼마간 유지될 것인지를 의미한다.\n\t- 이대로 동작한다는 보장은 없다.\n- max\n\t- Keep-Alive 응답 헤더를 통해 보낸다.\n\t- 커넥션이 몇 개의 HTTP 트랜잭션을 처리할 때까지 유지될 것인지를 의미한다.\n\t- 이대로 동작한다는 보장은 없다.\n- Keep-Alive 헤더는 진단이나 디버깅을 주목적으로 하는, 처리되지는 않는 임의의 속성들을 지원하기도 한다.\n\t- 이름[=값] 같은 식이다.","x":-1120,"y":-1738,"width":512,"height":500},
		{"id":"804733d8f52f1c1e","type":"text","text":"keep-alive는 사용하지 않기로 결정되어 HTTP/1.1 명세에서 빠졌다. 하지만 아직도 브라우저와 서버 간에 keep-alive 핸드셰이크가 널리 사용되고 있기 때문에, HTTP 애플리케이션은 그것을 처리할 수 있게 개발해야 한다.\n\nHTTP/1.0 keep-alive 커넥션을 구현한 클라이언트는 커넥션을 유지하기 위해서 요청에 Connection:Keep-Alive 헤더를 포함시킨다. 이 요청을 받는 서버는 그다음 요청도 이 커넥션을 통해 받고자 한다면, 응답 메시지에 같은 헤더를 포함시켜 응답한다.\n응답에 Connection: Keep-Alive 헤더가 없으면, 클라이언트는 서버가 keep-alive를 지원하지 않으며, 응답 메시지가 전소오디고 나면 서버 커넥션을 끊을 것이라 추청한다.","x":-1120,"y":-2174,"width":502,"height":332},
		{"id":"b72e63cbdb8a6aba","type":"text","text":"- keep-alive는 HTTP/1.0에서 기본으로 사용되지는 않는다. 클라이언트는 keep-alive 커넥션을 사용하기 위해 Connection: Keep-Alive 요청 헤더를 보내야 한다.\n- 커넥션을 계속 유지하려면 모든 메시지에 Connection: Keep-Alive 헤더를 포함해 보내야 한다. 만약 클라이언트가 Conneciton: Keep-Alive 헤더를 보내지 않으면 서버는 요청을 처리한 후 커넥션을 끊을 것이다.\n- 클라이언트는 Connection: Keep-Alive 응답 헤더가 없는 것을 보고 서버가 응답 후에 커넥션을 끊을 것임을 알 수 있다.\n- 커넥션이 끊어지기 전에 엔티티 본문의 길이를 알 수 있어야 커넥션을 유지할 수 있다.\n\t- 엔티티 본문에 정확한 Content-Length 값과 함께 멀티파트 미디어 형식(multipart media type)을 가지거나 청크 전송 인코딩(chunked transfer encoding)으로 인코드 되어야 함을 뜻한다.\n\t- keep-alive 커넥션에서 잘못된 Content-Length 값을 보내는 것은 좋지 않은데, 트랜잭션이 끝나는 시점에 기존 메시지의 끝과 새로운 메시지의 시작점을 정확히 알 수 없기 때문이다.\n- 프록시와 게이트웨이는 Connection 헤더의 규칙을 철저히 지켜야 한다. 프록시와 게이트웨이는 메시지를 전달하거나 캐시에 넣기 전에 Connection 헤더에 명시된 모든 헤더 필드와 Connection 헤더를 제거해야 한다.\n- 정석대로라면, keep-alive 커넥션은 Connection 헤더를 인식하지 못하는 프록시 서버와는 맺어지면 안된다. 이는 뒤에서 설명할 멍청한(dumb) 프록시로 인해 발생할 문제를 예방하기 위한 것이지만, 현실적으로 그것이 쉽진 않다.\n- 기술적으로 HTTP/1.0을 따르는 기기로부터 받는 모든 Connection 헤더 필드는 무시해야 한다. 오래된 프록시 서버로부터 실수로 전달될 수 있기 때문이다. 실제로, 어떤 클라이언트나 서버는 오래된 프록시에 행(hang)이 걸릴 수 있는 위험이 있음에도 이 규칙을 지키지 않기도 한다.\n- 클라이언트는 응답 전체를 모두 받기 전에 커넥션이 끊어졌을 경우, 별다른 문제가 없으면 요청을 다시 보낼 수 있게 준비되어 있어야 한다. 그렇지 않으면 요청이 반복될 경우 문제가 발생할 수 있다.","x":-1904,"y":-2780,"width":638,"height":772},
		{"id":"9201bd97269512d0","type":"file","file":"Projects/Study/HTTP/Connection/md/IP 헤더 구성.md","x":940,"y":483,"width":275,"height":154},
		{"id":"f05eded8e2400426","type":"file","file":"Projects/Study/HTTP/Connection/md/TCP 데이터 전송.md","x":-650,"y":399,"width":673,"height":322},
		{"id":"c61938553c630481","type":"file","file":"Projects/Study/HTTP/Connection/md/TCP 커넥션.md","x":-539,"y":-60,"width":452,"height":145},
		{"id":"ef5290e3a1b00b6f","type":"file","file":"Projects/Study/HTTP/Connection/md/TCP 소켓 프로그래밍.md","x":-533,"y":-488,"width":439,"height":256},
		{"id":"d0edd324b279af6d","type":"file","file":"Projects/Study/HTTP/Connection/md/HTTP 커넥션.md","x":-1240,"y":-60,"width":552,"height":145},
		{"id":"8d7c79ebf5348066","type":"text","text":"HTTP는 클라이언트와 서버 사이에 proxy 서버, cache 서버 등과 같은 중개 서버가 놓이는 것을 허락한다.\nHTTP 메시지는 클라이언트에서 서버까지 중개 서버들을 하나하나 거치면서 전달된다.\n\n어떤 경우에는, 두 개의 인접한 HTTP 애플리케이션이 현재 맺고 있는 커넥션에만 적용된 옵션을 지정해야 할 때가 있다.\nHTTP Connection 헤더 필드는 **커넥션 토큰을 쉼표로 구분**하여 가지고 있으며, 그 값들은 다른 커넥션에 전달되지 않는다.\n예를 들어, 다음 메시지를 보낸 다음 끊어져야 할 커넥션은 **Connection: close**라고 명시할 수 있다.\n\n커넥션 토큰이 HTTP 헤더 필드 명을 가지고 있으면, 해당 필드들은 현재 커넥션만을 위한 정보이므로 다음 커넥션에 전달하면 안된다.\nConneciton 헤더에 있는 모든 헤더 필드는 메시지를 다른 곳으로 전달하는 시점에 삭제되어야 한다.\nConnection 헤더는 홉별 헤더 명을 기술하는데, 이것을 **헤더 보호하기**라 한다.","x":-1268,"y":-600,"width":608,"height":444},
		{"id":"f7a10d30f5a22b1f","type":"text","text":"병렬 커넥션이 일반적으로 더 빠르기는 하지만, 항상 그렇지는 않다.\n클라이언트의 네트워크 대역폭이 좁을 때는 대부분 시간을 데이터를 전송하는 데만 쓸 것이다.\n여러 개의 객체를 병렬로 내려받는 경우, 이 제한된 대역폭 내에서 각 객체를 전송받는 것은 느리기 때문에 성능상의 장점은 거의 없어진다.\n\n또한 다수의 커넥션은 메모리를 많이 소모하고 자체적인 성능 문제를 발생시킨다.\n복잡한 웹페이지는 수십 개에서 수 백 개의 객체를 포함한다. 클라이언트가 수백개의 커넥션을 열 수도 있겠지만, 서버는 다른 여러 사용자의 요청도 함께 처리해야 하기 때문에 수백 개의 커넥션을 허용하는 경우는 드물다.\n\n브라우저는 실제로 병렬 커넥션을 사용하긴 하지만 적은 수(대부분 4개)의 병렬 커넥션만을 허용한다.\n서버는 특정 클라이언트로부터 과도한 수의 커넥션이 맺어졌을 경우, 그것을 임의로 끊어버릴 수 있다.","x":-3320,"y":-1380,"width":780,"height":324},
		{"id":"9612403ecccb1d44","type":"text","text":"HTTP 트랜잭션 지연","x":940,"y":-216,"width":250,"height":60},
		{"id":"d101e3bce685181e","type":"text","text":"HTTP는 TCP 바로 위에 있는 계층이기 때문에 HTTP 트랜잭션의 성능은 그 아래 계층인 TCP 성능에 영향을 받는다.","x":306,"y":-220,"width":466,"height":58},
		{"id":"220e30899fdfd2b1","type":"text","text":"1. 브라우저가 url의 호스트명을 추출한다.\n2. 브라우저가 호스트명에 대한 IP 주소를 찾는다\n3. 브라우저가 포트 번호(80)를 얻는다.\n4. 브라우저가 IP의 포트(80)로 TCP 커넥션을 생성한다.\n5. 브라우저가 서버로 HTTP GET 요청 메시지를 보낸다.\n6. 브라우저가 서버에서 온 HTTP 응답 메시지를 읽는다.\n7. 브라우저가 커넥션을 끊는다.","x":300,"y":80,"width":472,"height":229,"color":"5"}
	],
	"edges":[
		{"id":"d8cae87fbd8c692b","fromNode":"d0edd324b279af6d","fromSide":"right","toNode":"c61938553c630481","toSide":"left"},
		{"id":"803938f632f27c65","fromNode":"c61938553c630481","fromSide":"bottom","toNode":"f05eded8e2400426","toSide":"top","label":"데이터 전송 방식"},
		{"id":"5b3ae9640a1d9cd0","fromNode":"f05eded8e2400426","fromSide":"right","toNode":"5e803365927ed469","toSide":"left","label":"IP 패킷 구성"},
		{"id":"599be0061c2ed2a7","fromNode":"5e803365927ed469","fromSide":"right","toNode":"9201bd97269512d0","toSide":"left","label":"IP 헤더 구성"},
		{"id":"f8ddb6dbfa2fb191","fromNode":"5e803365927ed469","fromSide":"bottom","toNode":"a5942026ca893e5a","toSide":"top"},
		{"id":"e2221c8964e43758","fromNode":"5e803365927ed469","fromSide":"bottom","toNode":"fe7764d244e1d106","toSide":"top","label":"TCP 세그먼트 헤더 구성"},
		{"id":"87978136b524f987","fromNode":"f05eded8e2400426","fromSide":"bottom","toNode":"a7a6170af572e459","toSide":"top","label":"TCP 커넥션 유지"},
		{"id":"ebbe7c89288215cb","fromNode":"c61938553c630481","fromSide":"top","toNode":"ef5290e3a1b00b6f","toSide":"bottom","label":"TCP 소켓 프로그래밍"},
		{"id":"dec4ddf94090fde1","fromNode":"c61938553c630481","fromSide":"right","toNode":"220e30899fdfd2b1","toSide":"left","label":"브라우저에 주소를 입력하면?"},
		{"id":"b05c3aec5b98c7d3","fromNode":"c61938553c630481","fromSide":"right","toNode":"d101e3bce685181e","toSide":"left","label":"TCP 성능"},
		{"id":"660f2187138dc09e","fromNode":"d101e3bce685181e","fromSide":"right","toNode":"9612403ecccb1d44","toSide":"left"},
		{"id":"352c3e9356d5a4e0","fromNode":"d0edd324b279af6d","fromSide":"top","toNode":"8d7c79ebf5348066","toSide":"bottom","label":"Connection 헤더"},
		{"id":"4fa2835ef33a8889","fromNode":"d0edd324b279af6d","fromSide":"left","toNode":"b8c24aa50b91b220","toSide":"right","label":"순차적인 트랜잭션 처리에 의한 지연"},
		{"id":"ded8dd91e172627d","fromNode":"b8c24aa50b91b220","fromSide":"top","toNode":"fbfcd8ae35fe5b67","toSide":"bottom","label":"HTTP 커넥션 성능 향상 기술"},
		{"id":"1efe4b712e5cb164","fromNode":"fbfcd8ae35fe5b67","fromSide":"top","toNode":"8cc9b9580a8ff4d3","toSide":"bottom","label":"병렬 커넥션"},
		{"id":"6216d28d827cc475","fromNode":"8cc9b9580a8ff4d3","fromSide":"top","toNode":"f7a10d30f5a22b1f","toSide":"bottom","label":"병렬 커넥션이 항상 더 빠르지는 않다"},
		{"id":"e8e6cc04cc2251e6","fromNode":"fbfcd8ae35fe5b67","fromSide":"top","toNode":"bcb5b9c767a64470","toSide":"bottom","label":"지속 커넥션"},
		{"id":"a1f70f1aca143398","fromNode":"8cc9b9580a8ff4d3","fromSide":"top","toNode":"2689ce1341d03bb4","toSide":"bottom","label":"단점"},
		{"id":"ef2561c71acfb286","fromNode":"bcb5b9c767a64470","fromSide":"top","toNode":"27a504d3b7b34e1a","toSide":"bottom","label":"병렬 커넥션 vs 지속 커넥션"},
		{"id":"860c66a8c04e9923","fromNode":"27a504d3b7b34e1a","fromSide":"top","toNode":"bf93f49145ed3498","toSide":"bottom","label":"Keep-Alive 커넥션"},
		{"id":"612ca9a6cf6bc46e","fromNode":"bf93f49145ed3498","fromSide":"right","toNode":"804733d8f52f1c1e","toSide":"left","label":"동작"},
		{"id":"14af3332bab29903","fromNode":"bf93f49145ed3498","fromSide":"right","toNode":"e8398d59c95e38f4","toSide":"left","label":"옵션"},
		{"id":"575f4c6fdc9a221b","fromNode":"bf93f49145ed3498","fromSide":"top","toNode":"b72e63cbdb8a6aba","toSide":"bottom"}
	]
}
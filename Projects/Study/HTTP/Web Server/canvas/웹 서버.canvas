{
	"nodes":[
		{"id":"e1fb798ede82c62c","type":"file","file":"Projects/Study/HTTP/Web Server/md/웹 서버.md","x":-340,"y":-240,"width":478,"height":298},
		{"id":"a5889d53a8a61974","type":"text","text":"웹 서버는 HTTP 및 그와 관련된 TCP 처리를 구현한 것이다.\n\n- 웹 서버는 자신이 제공하는 리소스를 관리하고 웹 서버를 설정, 통제, 확장하기 위한 관리 기능을 제공한다.\n- 웹 서버는 HTTP 프로토콜을 구현하고, 웹 리소스를 관리하고, 웹 서버 관리 기능을 제공한다.\n- 웹 서버는 TCP 커넥션 관리에 대한 책임을 운영체제와 나눠 갖는다.\n\t- 운영체제는 컴퓨터 시스템의 하드웨어를 관리하고 TCP/IP 네트워크 지원, 웹 리소스를 유지하기 위한 파일 시스템, 현재 연산 활동을 제어하기 위한 프로세스 관리를 제공한다.","x":260,"y":-238,"width":570,"height":294},
		{"id":"3fc514c0546b5507","type":"text","text":"1. 커넥션을 맺는다.\n\t1. 클라이언트의 접속을 받아들이거나, 원치 않는 클라이언트라면 닫는다.\n2. 요청을 받는다.\n\t1. HTTP 요청 메시지를 네트워크로부터 읽어 들인다.\n3. 요청을 처리한다.\n\t1. 요청 메시지를 해석하고 행동을 취한다.\n4. 리소스에 접근한다.\n\t1. 메시지에서 지정한 리소스에 접근한다.\n5. 응답을 만든다.\n\t1. 올바른 헤더를 포함한 HTTP 응답 메시지를 생성한다.\n6. 응답을 보낸다.\n\t1. 응답을 클라이언트에게 돌려준다.\n7. 트랜잭션 로그로 남긴다.\n\t1. 로그파일에 트랜잭션 완료에 대한 기록을 남긴다.\n\n![[Pasted image 20240121104335.png]]","x":-418,"y":378,"width":634,"height":860},
		{"id":"cce11f1b63592510","type":"file","file":"Projects/Study/HTTP/Web Server/md/4. 리소스의 매핑과 접근.md","x":-901,"y":1674,"width":700,"height":226},
		{"id":"ae369de0a19ed29f","type":"file","file":"Projects/Study/HTTP/Web Server/md/2. 요청 메시지 수신.md","x":751,"y":1058,"width":817,"height":805},
		{"id":"c46fdff3387897a4","type":"file","file":"Projects/Study/HTTP/Web Server/md/메시지의 내부 표현.md","x":1809,"y":1058,"width":652,"height":488},
		{"id":"5ce58165fae2b643","type":"file","file":"Projects/Study/HTTP/Web Server/md/커넥션 입출력 처리 아키텍처.md","x":1809,"y":1640,"width":740,"height":897},
		{"id":"59f4e9159196dd0b","type":"file","file":"Projects/Study/HTTP/Web Server/md/단일 스레드 웹 서버.md","x":2889,"y":1415,"width":523,"height":225},
		{"id":"4bccbc9649291f2b","type":"file","file":"Projects/Study/HTTP/Web Server/md/멀티프로세스와 멀티스레드 웹 서버.md","x":2889,"y":1815,"width":610,"height":322},
		{"id":"45577bb9c1239d80","type":"file","file":"Projects/Study/HTTP/Web Server/md/다중 IO 서버.md","x":2889,"y":2255,"width":701,"height":298},
		{"id":"96666000948afe26","type":"file","file":"Projects/Study/HTTP/Web Server/md/다중 멀티스레드 웹 서버.md","x":2889,"y":2675,"width":645,"height":195},
		{"id":"ec051ade21cb2270","type":"file","file":"Projects/Study/HTTP/Web Server/md/3. 요청 처리.md","x":0,"y":1646,"width":630,"height":282},
		{"id":"3becf5a39fa7a526","type":"text","text":"웹 서버는, 경로가 파일이 아닌 디렉터리를 가리키는, 디렉터리 URL에 대한 요청을 받을 수 있다.\n대부분의 웹 서버는 클라이언트가 디렉터리 URL을 요청했을 때 다음과 같이 몇 가지 다른 행동을 취하도록 설정할 수 있다.\n- 에러를 반환한다.\n- 디렉터리 대신 특별한 '색인 파일'을 반환한다.\n- 디렉터리를 탐색해서 그 내용을 담은 HTML 페이지를 반환한다.\n\n대부분의 웹 서버는 **요청한 URL에 대응되는 디렉터리 안에서 index.html 혹은 index.htm으로 이름 붙은 파일을 찾는다**.\n만약 사용자가 어떤 디렉터리에 대한 URL을 요청했는데, 그 디렉터리가 index.html이란 이름을 가진 파일을 갖고 있다면, 서버는 그 파일의 콘텐츠를 반환할 것이다.","x":-720,"y":2343,"width":641,"height":355},
		{"id":"82880f83fae590b7","type":"text","text":"아파치 웹 서버에서, **DirectoryIndex 설정 지시자**를 사용해서 기본 디렉터리 파일로 사용될 파일 이름의 집합을 설정할 수 있다.\nDirectoryIndex 지시자는 디렉터리 색인 파일로 사용될 모든 파일의 이름을 우선순위로 나열한다.\n\n다음의 설정은 아파치가 디렉터리 URL 요청에 대한 응답으로 나열된 파일 중 하나를 찾게 만든다.\n```shell\nDirectoryIndex index.html index.htm home.html home.html index.cgi\n```\n\n사용자가 디렉터리 URI를 요청했을 때 기본 색인 파일이 없고 디렉터리 색인 기능이 꺼져 있지 않다면, 많은 웹 서버는 자동으로 그 디렉터리의 파일들을 크기, 변경일 및 그 파일에 대한 링크와 함께 열거한 HTML 파일을 반환한다.\n이 파일 열거는 편리하기는 하지만, 일반적으로는 발견할 수 없는 파일도 드러나게 된다는 단점이 있다.\n\n다음과 같이 아파치 지시자로 디렉터리 색인 파일 자동 생성을 끌 수 있다.\n`Options -Indexes`","x":-698,"y":2804,"width":597,"height":467},
		{"id":"e1c480d3830d1847","type":"text","text":"웹 서버는 URI를 동적 리소스에 매핑할 수도 있다. 즉, 요청에 맞게 콘텐츠를 생성하는 프로그램에 URI를 매핑하는 것이다.\n\n웹 서버들 중에서 애플리케이션 서버라고 불리는 것들은 웹 서버를 복잡한 백엔드 애플리케이션과 연결하는 일을 한다.\n어떤 리소스가 동적 리소스라면, 애플리케이션 서버는 그에 대한 동적 콘텐츠 생성 프로그램이 어디에 있는지, 그리고 어떻게 그 프로그램을 실행하는지 알려줄 수 있어야 한다.\n대부분의 웹 서버는 동적 리소스를 식별하고 매핑할 수 있는 기본적인 메커니즘을 갖고 있다\n","x":-1551,"y":2371,"width":650,"height":284},
		{"id":"5a9fe4f579f220b1","type":"text","text":"\n아파치는 URI의 경로명이 실행 가능한 프로그램이 위치한 디렉터리로 매핑되도록 설정하는 기능을 제공한다.\n서버가 실행 가능한 경로명을 포함한 URI로 요청을 받으면, 그 경로에 대응하는 디렉터리에서 프로그램을 찾아 실행하려 시도한다.\n예를 들어, 다음의 아파치 설정 지시자는 URI의 경로가 /cgi-bin/으로 시작한다면 /usr/local/etc/httpd/cgi-programs/에서 프로그램을 찾아 실행하라는 의미다.\n\n```\nScriptAlias /cgi-bin/ /usr/local/etc/httpd/cgi-programs/\n```\n또한 아파치에서는 특정 확장자의 파일만 실행하도록 설정할 수도 있다. 이 방법은, 실행 가능한 스크립트를 아무 디렉터리에나 위치시킬 수 있다.\n다음의 아파치 설정 지시자는 .cgi로 끝나는 모든 웹 리소스는 실행되어야 함을 명시한다.\n```\nAddHandler cgi-script .cgi\n```\n웹 초창기에 널리 쓰였던 CGI는 서버사이드 애플리케이션을 실행하기 위한 간단한 인터페이스다.\n오늘날의 애플리케이션 서버는, 마이크로소프트의 액티브 서버 페이지와 자바 서블릿과 같은 한층 더 강력하고 효과적인 서버사이드 동적 컨텐츠 지원 기능을 갖고 있다.","x":-1538,"y":2773,"width":624,"height":573},
		{"id":"5ee85bb955ba8ec2","type":"file","file":"Projects/Study/HTTP/Web Server/md/5. 응답 만들기.md","x":-1370,"y":1093,"width":672,"height":145},
		{"id":"4441499545da9fe0","type":"text","text":"많은 웹 서버가 서버사이드 인클루드도 지원한다.\n만약 어떤 리소스가 서버사이드 인클루드를 포함하고 있는 것으로 설정되어 있다면, 서버는 **그 리소스의 콘텐츠를 클라이언트에게 보내기 전에 처리**한다.\n\n서버는 콘텐츠에 변수 이름이나 내장된 스크립트가 될 수 있는 어떤 특별한 패턴이 있는지(주로 특별한 HTML 주석 안에 포함된다) 검사를 받는다.\n특별한 패턴은 변수 값이나 실행 가능한 스크립트의 출력 값으로 치환된다. 이것은 동적 콘텐츠를 만드는 쉬운 방법이다.","x":-2120,"y":2040,"width":603,"height":228},
		{"id":"83a19c6eb72dc6bb","type":"text","text":"웹 서버는 각각의 리소스에 접근 제어를 할당할 수 있다.\n접근 제어되는 리소스에 대한 요청이 도착했을 때 웹 서버는 **클라이언트의 IP 주소에 근거하여 접근을 제어**할 수 있고 혹은 **리소스에 접근하기 위한 비밀번호**를 물어볼 수도 있다.","x":-2021,"y":1841,"width":483,"height":118},
		{"id":"eb87c09102ba2fed","type":"text","text":"웹 서버는 종종 성공 메시지 대신 리다이렉션 응답을 반환한다.\n웹 서버는 요청을 수행하기 위해 브라우저가 다른 곳으로 가도록 리다이렉트 할 수 있다.\n\n리다이렉션 응답은 3XX 상태 코드로 지칭된다.\nLocation 응답 헤더는 콘텐츠의 새로운 혹은 선호하는 위치에 대한 URI를 포함한다.\n\n리다이렉트는 다음의 경우에 유용하다.\n- **영구히 리소스가 옮겨진 경우**\n\t- 리소스는 새 URL이 부여되어 새로운 위치로 옮겨졌거나 이름이 바뀌었을 수 있다.\n\t- 웹 서버는 클라이언트에게 리소스의 이름이 바뀌었으므로, 클라이언트는 북마크를 갱신하거나 할 수 있다고 말해줄 수 있다.\n\t- 301 Moved Permanently 상태 코드는 이런 종류의 리다이렉트를 위해 사용된다.\n- **임시로 리소스가 옮겨진 경우**\n\t- 만약 리소스가 임시로 옮겨지거나 일므이 변경된 경우, 서버는 클라이언트를 새 위치로 리다이렉트하길 원할 것이다.\n\t- 그러나 이름 변경이 임시적이기 때문에, 서버는 클라이언트가 나중에는 원래 URL로 찾아오고 북마크도 갱신하지 않기를 원한다.\n\t- 303 See Other와 307 Temporary Redirect 상태 코드는 이런 종류의 리다이렉트를 위해 사용된다.\n- **URL 증강**\n\t- 서버는 종종 문맥 정보를 포함시키기 위해 재 작성된 URL로 리다이렉트한다.\n\t- 요청이 도착했을 때, 서버는 상태 저옵를 내포한 새 URL을 생성하고 사용자를 이 새 URL로 리다이렉트 한다.\n\t- 클라이언트는 리다이렉트를 따라가서, 이번엔 상태정보가 추가된 완전한 URL을 포함한 요청을 다시 보낸다.\n\t- 이것은 트랜잭션 간 상태를 유지하는 유용한 방법이다. 이러한 종류의 리다이렉트를 위해 303 See Other와 307 Temporary Redirect 상태 코드를 사용한다.\n- **부하 균형**\n\t- 만약 과부하된 서버가 요청을 받으면, 서버는 클라이언트를 좀 덜 부하가 걸린 서버로 리다이렉트할 수 있다.\n\t- 이런 종류의 리다이렉트를 위해 303 See Other와 307 Temporary Redirect 상태 코드를 사용한다.\n- **친밀한 다른 서버가 있을 때**\n\t- 웹 서버는 어떤 사용자에 대한 정보를 가질 수 있다.\n\t- 서버는 클라이언트를 그 클라이언트에 대한 저옵를 갖고 있는 다른 서버로 리다이렉트할 수 있다.\n\t- - 이런 종류의 리다이렉트를 위해 303 See Other와 307 Temporary Redirect 상태 코드를 사용한다.\n- **디렉터리 이름 정규화**\n\t- 클라이언트가 디렉터리 이름에 대한 URI를 요청하는데 끝에 빗금(/)을 빠뜨렸다면, 대부분의 웹 서버는 상대경로가 정상적으로 동작할 수 있도록 클라이언트를 슬래시를 추가한 URI로 리다이렉트한다.","x":-2120,"y":-291,"width":645,"height":1235},
		{"id":"a38f9dc7caee4a35","type":"text","text":"웹 서버에게는 응답 본문의 MIME 타입을 결정해야 하는 책임이 있다.\n다음은 MIME 타입과 리소스를 연결하는 여러 가지 방법이다.\n- mime.types\n\t- 웹 서버는 MIME 타입을 나타내기 위해 파일 이름의 확장자를 사용할 수 있다.\n\t- 웹 서버는 각 리소스의 MIME 타입을 계산하기 위해 확장자별 MIME 타입이 담겨 있는 파일을 탐색하낟.\n\t- 이러한 확장자 기반 타입 연계가 가장 흔한 방법이다.\n- 매직 타이핑(Magic typing)\n\t- 아파치 웹 서버는 각 파일의 MIME 타입을 알아내기 위해 파일의 내용을 검사해서 알려진 패턴에 대한 테이블(매직 파일이라 불린다)에 해당하는 패턴이 있는지 찾아볼 수 있다.\n\t- 이 방법이 느리긴 하지만 파일이 표준 확장자 없이 이름 지어진 경우에는 특히 편리하다.\n- 유형 명시(Explicit typing)\n\t- 특정 파일이나 디렉터리 안의 파일들이 파일 확장자나 내용에 상관없이 어떤 MIME 타입을 갖도록 웹 서버를 설정할 수 있다\n\t- ![[Pasted image 20240121204044.png]]\n- 유형 협상(Type negotiation)\n\t- 어떤 웹 서버는 한 리소스가 여러 종류의 문서 형식에 속하도록 설정할 수 있다.\n\t- 이 때 웹 서버가 사용자와의 협상 과정을 통해 사용하기 가장 좋은 형식(그리고 대응하는 MIME 타입)을 판별할 것인지의 여부도 설정할 수 있다.\n\t- 웹 서버는 특정 파일이 특정 MIME 타입을 갖게끔 설정할 수도 있다.","x":-2740,"y":736,"width":548,"height":1005},
		{"id":"7043d95749672674","type":"text","text":"만약 트랜잭션이 응답 본문을 생성한다면, 그 내용을 응답 메시지와 함께 돌려보낸다.\n만약 본문이 있다면, 응답 메시지는 주로 다음을 포함한다.\n- 응답 본문의 MIME 타입을 서술하는 Content-Type 헤더\n- 응답 본문의 길이를 서술하는 Content-Length 헤더\n- 실제 응답 본문의 내용","x":-2120,"y":1440,"width":488,"height":206},
		{"id":"79b21a6682d90b7b","type":"text","text":"docroot의 또 다른 대표적인 활용은, 사용자들이 한 대의 웹 서버에서 각자의 개인 웹 사이트를 만들 수 있도록 해주는 것이다.\n보통 빗금(/)과 물결표(~) 다음에 사용자 이름이 오는 것으로 시작하는 URI는 그 사용자의 개인 문서 루트를 가리킨다.\n개인 docroot는 주로 사용자 홈 디렉터리 안에 있는 **public_html**로 불리는 디렉터리지만, 설정에 따라 다르다.\n\n![[Pasted image 20240121195551.png]]","x":-460,"y":3438,"width":960,"height":428},
		{"id":"32554fd6fd882a09","type":"text","text":"가상 호스팅 웹 서버는, 각 사이트에 **그들만의 분리된 문서 루트를 주는 방법**으로 한 웹 서버에서 여러 개의 웹 사이트를 호스팅 한다.\n가상 호스팅 웹 서버는 URI나 Host 헤더에서 얻는 IP 주소나 호스트 명을 이용해 올바른 문서 루트를 식별한다.\n이 방법으로, 하나의 웹 서버 위에서 **두 개의 사이트가 완전히 분리된 콘텐츠를 갖고 호스팅 되도록** 할 수 있다.\n\n![[Pasted image 20240121185044.png]]\n위 그림에서, 서버는 두 사이트 www.joes-hardware.com와 www.marys-antiques.com을 호스팅 한다.\n서버는 두 웹 사이트를 HTTP Host 헤더나 서로 다른 IP 주소를 이용해 구분할 수 있다.\n- 요청 A가 도착했을 때, 서버는 /docs/joe/index.html 파일을 가져온다.\n- 요청 B가 도착했을 때, 서버는 /docs/mary/index.html 파일을 가져온다.","x":600,"y":3380,"width":840,"height":544},
		{"id":"33e4a79827dd17f8","type":"text","text":"가상으로 호스팅 되는 docroot 설정은 대부분의 웹 서버에서 간단하다.\n널리 쓰이는 아파치 웹 서버에서는, 각 가상 웹 사이트의 VirtualHost 블록이 가상 서버에 대한 DocumentRoot 지시자를 포함하도록 설정해야 한다.\n\n```xml\n<VirtualHost www.joes-hardware.com>\n  ServerName www.joes-hardware.com\n  DocumentRoot /docs/joe\n  TransferLog /logs/joe.access_log\n  ErrorLog /logs/joe.error_log\n</VirtualHost>\n\n<VirtualHost www.marys-hardware.com>\n  ServerName www.marys-hardware.com\n  DocumentRoot /docs/mary\n  TransferLog /logs/mary.access_log\n  ErrorLog /logs/mary.error_log\n</VirtualHost>\n```","x":701,"y":4140,"width":639,"height":425},
		{"id":"b801e27325b8e234","type":"text","text":"웹 서버는 여러 종류의 리소스 매핑을 지원한다.\n하지만 리소스 매핑의 가장 단순한 형태는 **요청 URI를 웹 서버의 파일 시스템 안에 있는 파일 이름을 사용하는 것**이다.\n일반적으로 웹 서버 파일 시스템의 특별한 폴더를 웹 콘텐츠를 위해 예약해 둔다. 이 폴더는 **문서 루트** 혹은 **docroot**로 불린다.\n웹 서버는 요청 메시지에서 URI를 가져와서 문서 루트 뒤에 붙인다.\n\n![[Pasted image 20240121184556.png]]\n위 그림에서, /specials/saw-blade.gif에 대한 요청이 도착했다. 이 예에서 웹 서버는 문서 루트 /usr/local/httpd/files를 갖고 있다. 또 /usr/local/httpd/files/specials/saw-blade.gif 파일을 반환한다.\n\n다음과 같이 httpd.conf 설정 파일에 DocumentRoot 줄을 추가하여 아파치 웹 서버의 문서 루트를 설정할 수 있다.\n`DocumentRoot /usr/local/httpd/files`\n\n서버는 상대적인 url이 docroot를 벗어나서 파일 시스템의 docroot 이외 부분이 노출되는 일이 생기지 않도록 주의해야 한다.\n예를 들어 대부분의 성숙한 웹 서버는 Joe's Hardware의 문서 루트 위의 파일을 보려고 하는 이와 같은 URI를 허용하지 않는다.\n`http://www.joes-hardware.com/../`","x":160,"y":2343,"width":760,"height":720},
		{"id":"0ef951bd372f87f4","type":"file","file":"Projects/Study/HTTP/Web Server/md/새 커넥션 다루기.md","x":1618,"y":-678,"width":654,"height":354},
		{"id":"26b5c8769f3b2423","type":"file","file":"Projects/Study/HTTP/Web Server/md/클라이언트 호스트 명 식별.md","x":1618,"y":-218,"width":665,"height":274},
		{"id":"50ecedb2c7188877","type":"text","text":"ident는 조직 내부에서는 잘 사용할 수 있지만, 공공 인터넷에서는 다음을 포함한 여러 이유로 잘 동작하지 않는다.\n- 많은 클라이언트 PC는 identd 신원확인 프로토콜 데몬 소프트웨어를 실행하지 않는다.\n- ident 프로토콜은 HTTP 트랜잭션을 유의미하게 지연시킨다.\n- 방화벽이 ident 트래픽이 들어오는 것을 막는 경우가 많다.\n- ident 프로토콜은 안전하지 않고 조작하기 쉽다.\n- ident 프로토콜은 가상 IP 주소를 잘 지원하지 않는다.\n- 클라이언트 사용자 이름의 노출로 인한 프라이버시 침해의 우려가 있다.\n\n아파치 웹 서버의 경우 IdentityCheck 지시어를 사용해 ident 룩업을 사용하게 할 수 있다.\n만약 가용한 ident 정보가 없다면, 아파치는 ident 로그 필드를 하이픈(-)으로 채울 것이다. 보통 ident 정보가 없기 때문에 일반 로그 포맷 로그 파일의 두 번째 필드는 하이픈으로 채워진다.","x":2638,"y":349,"width":861,"height":338},
		{"id":"6f42e85f5c1dc8bd","type":"file","file":"Projects/Study/HTTP/Web Server/md/ident를 통해 클라이언트 사용자 알아내기.md","x":1618,"y":184,"width":772,"height":667},
		{"id":"14d994081a8ea617","type":"file","file":"Projects/Study/HTTP/Web Server/md/7. 로깅.md","x":-1295,"y":254,"width":523,"height":146},
		{"id":"9dc4ff20426b6115","type":"file","file":"Projects/Study/HTTP/Web Server/md/6. 응답 보내기.md","x":-1426,"y":571,"width":728,"height":330},
		{"id":"b25df975eca326bc","type":"file","file":"Projects/Study/HTTP/Web Server/md/1. 클라이언트 커넥션 수락.md","x":751,"y":386,"width":559,"height":264}
	],
	"edges":[
		{"id":"b64a1dc7d9490e3c","fromNode":"e1fb798ede82c62c","fromSide":"right","toNode":"a5889d53a8a61974","toSide":"left"},
		{"id":"c9c12a225d80bd97","fromNode":"e1fb798ede82c62c","fromSide":"bottom","toNode":"3fc514c0546b5507","toSide":"top","label":"실행 과정"},
		{"id":"39792040aa84d0b8","fromNode":"3fc514c0546b5507","fromSide":"right","toNode":"b25df975eca326bc","toSide":"left","label":"1. 클라이언트 커넥션 수락"},
		{"id":"094d1b639101982b","fromNode":"6f42e85f5c1dc8bd","fromSide":"right","toNode":"50ecedb2c7188877","toSide":"left"},
		{"id":"cfb9546fc0c412ab","fromNode":"3fc514c0546b5507","fromSide":"right","toNode":"ae369de0a19ed29f","toSide":"left","label":"2. 요청 메시지 수신"},
		{"id":"b2edb396370ab707","fromNode":"b25df975eca326bc","fromSide":"right","toNode":"0ef951bd372f87f4","toSide":"left"},
		{"id":"390dc341fba92cca","fromNode":"b25df975eca326bc","fromSide":"right","toNode":"26b5c8769f3b2423","toSide":"left"},
		{"id":"9d321257c665c3b3","fromNode":"b25df975eca326bc","fromSide":"right","toNode":"6f42e85f5c1dc8bd","toSide":"left"},
		{"id":"b41d67fd58b32486","fromNode":"ae369de0a19ed29f","fromSide":"right","toNode":"c46fdff3387897a4","toSide":"left"},
		{"id":"7dfb5c6a0083dd91","fromNode":"ae369de0a19ed29f","fromSide":"right","toNode":"5ce58165fae2b643","toSide":"left"},
		{"id":"cd1193a97229bdfd","fromNode":"5ce58165fae2b643","fromSide":"right","toNode":"59f4e9159196dd0b","toSide":"left","label":"단일 스레드 웹 서버"},
		{"id":"e7c0338425ac3791","fromNode":"5ce58165fae2b643","fromSide":"right","toNode":"4bccbc9649291f2b","toSide":"left","label":"멀티프로세스와\n멀티스레드 웹 서버"},
		{"id":"8bd9c83147d47dd9","fromNode":"5ce58165fae2b643","fromSide":"right","toNode":"45577bb9c1239d80","toSide":"left","label":"다중 I/O 서버"},
		{"id":"7d06c728d8b38708","fromNode":"5ce58165fae2b643","fromSide":"right","toNode":"96666000948afe26","toSide":"left","label":"다중 멀티스레드\n웹 서버"},
		{"id":"1ffdf0b7e5651d72","fromNode":"3fc514c0546b5507","fromSide":"bottom","toNode":"ec051ade21cb2270","toSide":"top","label":"3. 요청 처리"},
		{"id":"64f1b40d268b4c1d","fromNode":"3fc514c0546b5507","fromSide":"bottom","toNode":"cce11f1b63592510","toSide":"top","label":"4. 리소스의 매핑과 접근"},
		{"id":"25e4c88595ca1d35","fromNode":"cce11f1b63592510","fromSide":"bottom","toNode":"b801e27325b8e234","toSide":"top","label":"Docroot"},
		{"id":"8b19fe6f7e8d6748","fromNode":"b801e27325b8e234","fromSide":"bottom","toNode":"32554fd6fd882a09","toSide":"top","label":"가상 호스팅 된 docroot"},
		{"id":"13dfe78bdc9651d6","fromNode":"32554fd6fd882a09","fromSide":"bottom","toNode":"33e4a79827dd17f8","toSide":"top"},
		{"id":"294a7aa0d98fa896","fromNode":"b801e27325b8e234","fromSide":"bottom","toNode":"79b21a6682d90b7b","toSide":"top","label":"사용자 홈 디렉터리 docroots"},
		{"id":"6c5d6142a38f1676","fromNode":"cce11f1b63592510","fromSide":"bottom","toNode":"3becf5a39fa7a526","toSide":"top","label":"디렉터리 목록"},
		{"id":"3089225356346a7a","fromNode":"cce11f1b63592510","fromSide":"bottom","toNode":"e1c480d3830d1847","toSide":"top","label":"동적 콘텐츠 리소스 매핑"},
		{"id":"783013113aebd0c8","fromNode":"e1c480d3830d1847","fromSide":"bottom","toNode":"5a9fe4f579f220b1","toSide":"top","label":"아파치에서는?"},
		{"id":"73198840e790ab7c","fromNode":"3becf5a39fa7a526","fromSide":"bottom","toNode":"82880f83fae590b7","toSide":"top","label":"아파치에서는?"},
		{"id":"90ae18c66eb82cf1","fromNode":"cce11f1b63592510","fromSide":"left","toNode":"4441499545da9fe0","toSide":"right","label":"서버사이드 인클루드(SSI)"},
		{"id":"77dde50df5af1f3c","fromNode":"cce11f1b63592510","fromSide":"left","toNode":"83a19c6eb72dc6bb","toSide":"right","label":"접근 제어"},
		{"id":"fabbf04223ad4353","fromNode":"3fc514c0546b5507","fromSide":"left","toNode":"5ee85bb955ba8ec2","toSide":"right","label":"5. 응답 만들기"},
		{"id":"89f9f0fd1fa6e540","fromNode":"5ee85bb955ba8ec2","fromSide":"left","toNode":"a38f9dc7caee4a35","toSide":"right","label":"MIME 타입 결정하기"},
		{"id":"98e1181ee50f8b8b","fromNode":"3fc514c0546b5507","fromSide":"left","toNode":"9dc4ff20426b6115","toSide":"right","label":"6. 응답 보내기"},
		{"id":"460b8961ee163aa5","fromNode":"3fc514c0546b5507","fromSide":"left","toNode":"14d994081a8ea617","toSide":"right","label":"7. 로깅"},
		{"id":"c5b2bab4fd61a1a6","fromNode":"5ee85bb955ba8ec2","fromSide":"left","toNode":"eb87c09102ba2fed","toSide":"bottom","label":"리다이렉션"},
		{"id":"58a28432be86eece","fromNode":"5ee85bb955ba8ec2","fromSide":"left","toNode":"7043d95749672674","toSide":"right","label":"응답 엔티티"}
	]
}
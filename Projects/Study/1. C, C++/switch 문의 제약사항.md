## switch 문에는 실수 타입을 넣을 수 없다.

`switch`문의 기본 구조는 아래와 같다.
```cpp
switch (/* 변수 */) {
	case /* 값1 */:
		// 명령들;
		break;
	case /* 값2 */:
		// 명령들;
		break;
		// .. (생략) ..
}
```
이 때 변수 부분에는 값1, 값2, ... 들과 비교할 변수가 들어가게 된다. 이 때 `switch` 문에 사용될 변수로는 반드시 정수 데이터를 보관하는 변수여야 한다.
다시 말해 '변수' 부분에 들어가는 변수들의 타입은 `char`, `short`, `int`, `long` 중에 하나 여야 한다. 만약 `input`이 `float`이나 `double`이라면 컴파일 시 오류가 발생하게 된다.

## switch 문의 값은 상수여야 한다.

또 주의할 점으로는 '값'에 위치하는 것들이 무조건 상수여야 한다는 것이다. 만약 '값' 부분에 변수들이 오게 된다면 오류가 발생하게 되는데 그 이유는 `switch` 문의 내부적인 처리 방법 때문이다.

`switch` 문을 배우고 나면 드는 의문이 하나가 생긴다.
"정말로 `switch` 문이 우리에게 필요한가? `if-else`로 다 해결되는데 왜 귀찮게 `switch` 문을 만들었을까? 차이는 단지 겉으로 얼마나 깔끔한지가 다를 뿐인데... 내부적으로 `switch` 문과 `if-else` 와는 차이가 없나요?"

위 질문에 대한 답변을 정확하게 이해하려면 어셈블리어에 대한 이해가 필요하다.

```cpp
switch(input) {
case 1:
	printf("아이 맛있어 \n");
	break;
case 2:
	printf("아이 시원해 \n");
	break;
case 3:
	printf("zzz \n");
	break;
default:
	printf("무슨 명령이야?");
	break;
}
```

```cpp
if (input == 1) {
	printf("아이 맛있어 \n");
} else if (input == 2) {
	printf("아이 시원해 \n");
} else if (input == 3) {
	printf("zzz \n");
} else {
	printf("무슨 명령이야?");
}
```

위 두 코드는 같은 코드를 `switch`문과 `if`문을 이용하여 나타낸 것이다. 사실, 외형적으로 동작하는 것은 차이가 없다. 단지 내부적으로 어떻게 처리되냐가 다를 뿐이다.

일단 `if` 문의 경우 각 경우마다 값들을 비교한다. 위 경우 값을 3번 비교할 것이다. 왜냐하면 `if` 가 1번, `else if`가 2번이고 `else` 의 경우 비교 없이 자동으로 처리되는 것이므로 총 3번 비교하게 된다.
즉, `if`문을 이용하면 각 `case`의 경우 비교하게 되므로 최악의 경우 모든 `case` 에 대해 값을 비교하는 연산을 시행하게 된다(어셈블리어에서는 `CMP` 연산을 한다).

그런데 `switch`는 사뭇 다르다. `switch`의 경우 내부적으로 `jumb table`이라는 것을 생성한다. 이 때, `jump table`의 크기는 `case`의 값들에 따라 달라지는데, 예를 들어 어떤 `switch`문의 경우 case 1 ~ case 10까지 있었다고 해보자. 그렇다면 `jump table`에는 값들이 0부터 9까지 들어가게 된다.
여기서 우리는 왜 `case 값:` 할 때 '값' 부분에 변수가 위치하면 안되는지 알게 된다.
`jump table`은 초기에 작성되기 때문에 이미 `switch`문이 실행되기 전에 `jump table`이 작성되게 된다. 따라서 **'값' 부분에 변수가 들어가게 되면 `jump table`에 무엇이 올지 알 수 없으므로 변수를 사용하면 안되는 것**이다.

이 값들은 무엇을 의미하냐면 각 `case`별로 명령들이 위치한 곳의 주소를 가리키는데, 예를 들어서 1인 지점으로 점프하게 되면 "아이 시원해"가 나오고 0인 지점으로 점프하게 되면 "아이 맛있어"라고 출력하라는 내용의 명령문들이 나온다. 변수의 값에 따라 변수가 3이라면 `jump table`의 3번째 원소를 찾아서 그 값에 해당하는 곳으로 점프하게 된다.
(실제로 `switch` 문이 처리되는 과정은 이보다 약간 더 복잡하다.)
https://blog.naver.com/kki2406/80041410085

따라서, `switch` 문을 이용하면 `case`에 따라 `CMP` 연산이 늘어나는 것이 아니라 `jump table`의 크기만 커질 뿐 성능에 있어서는 전혀 영향을 받지 않게 된다.

결론적으로, `switch` 문이 효과적으로 처리되기 위해서는 `case`의 '값' 들의 크기가 그다지 크지 않아야 하고, '값'들이 순차적으로 정렬되어 있고, 그 '값'끼리의 차이가 크지 않다면 최고로 효율적인 `switch`문을 이용할 수 있게 된다.
## 정적 라이브러리 단점

- 라이브러리 루틴이 실행 코드의 일부가 된다.
	- 버그가 제거되었거나 새로운 하드웨어 장치를 지원하는 신판 라이브러리가 나오더라도 정적으로 링크된 프로그램은 옛날 라이브러리를 사용해야 한다.
- 실행 파일에서 한 번이라도 호출되는 라이브러리는 모든 루틴을 다 적재해야 한다.
	- 심지어는 이 호출이 실제 실행되지 않더라도 모두 적재한다. 이 라이브러리가 프로그램에 비해 클 수 있다.
	- 예를 들어, 표준 C 라이브러리는 2.5MB이다.

## 동적 링크 라이브러리(dynamically linked library, DLL)

이 방식에서 프로그램 실행 전에는 라이브러리가 링크되지도 않고 적재되지도 않는다.
대신 프로그램과 라이브러리 루틴은 전역 프로시저의 위치와 이름에 대한 정보를 추가로 가지고 있다.

초기의 DLL에서는 로더가 동적 링커를 실행시켰다. 동적 링커는 파일에 저장된 추가 정보를 이용해서 적절한 라이브러리를 찾고 모든 외부 참조를 갱신한다.

이 초기 DLL의 단점은 호출될 가능성이 있는 모든 라이브러리 루틴을 링크시킨다는 것이다. 실제로 호출되는 것만 링크시킨다면 더 좋을 것이다. 이런 관점에서 지연(lazy) 프로시저 링키지형의 DLL이 개발되었다. 여기서는 모든 루틴을 실제로 호출된 후에 링크시킨다.

다른 많은 기술 혁신처럼 여기에도 트릭이 존재하는데, 여기서 사용되는 트릭은 간접접근(indirection) 기법이다. 이 과정은 프로그램 끝에 있는 더미 루틴(dummy routine)들을 호출하는 전역 루틴에서부터 시작된다.
전역 루틴 하나 당 더미 엔트리가 하나씩 있는데 이 더미 엔트리에는 간접 점프가 하나씩 있다.

라이브러리 루틴을 처음 호출할 때는 프로그램이 더미 엔트리를 호출하고 간접 점프를 따라간다. 더미 엔트리는 원하는 라이브러리 루틴을 표시하기 위해 레지스터에 숫자를 넣고 동적 링커/로더로 점프하는 코드를 가리킨다.
링커/로더는 원하는 루틴을 찾아서 재사상하고, 이 루틴을 가리키도록 간접 점프 위치에 있는 주소를 바꾼다. 그러고 나서는 그 주소로 점프하고, 루틴의 실행이 끝나면 원래 호출한 위치로 돌아온다.
그 이후에 다시 라이브러리 루틴을 호출하면 추가로 돌아다니는 일 없이 해당 루틴으로 바로 간접 점프한다.
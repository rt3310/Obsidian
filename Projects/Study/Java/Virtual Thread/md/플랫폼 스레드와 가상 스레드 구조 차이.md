앞서 플랫폼 스레드는 OS 스레드를 감싼 것이라고 설명했다. 애플리케이션 코드가 플랫폼 스레드를 사용하면 실제로는 OS 스레드를 사용하는 것이다.
이때 사용하는 스레드는 비용이 비싸기 때문에 스레드 풀을 사용하여 접근하는 방식으로 사용해왔다.

![[전통적인 Thread 사용방식.png]]

이에 반해 가상 스레드는 OS 스레드를 감싼 구조가 아니기 때문에 애플리케이션 코드는 가상 스레드 풀 없이 사용하고 JVM 자체적으로 가상 스레드를 OS 스레드와 연결하는 스케줄링한다.
이 작업을 mount / unmount 라고 하고 기존에 플랫폼 스레드라고 하던 부분을 Carrier 스레드라고 한다. (가상 스레드를 실제 OS 스레드로 연결해준다는 의미

![[Virtual Thread 사용방식.png]]

구조적으로 보자면 OS 스레드를 사용하기 전에 하나의 레이어가 더 있는 것처럼 보인다. (가상 스레드 스케줄링) 하지만 이 자체적인 스케줄링을 통해서 큰 차이가 발생한다.

기존의 스레드는 **Blocking이 발생하면 그냥 기다려야** 했는데, 가상 스레드는 Blocking이 발생하면 **내부의 스케줄링을 통해서 실제 작업을 처리하는 Carrier 스레드는 다른 가상 스레드의 작업을 처리**하면 된다.

따라서 Non-blocking이 누리는 장점을 동일하게 누릴 수 있다.
![[Mount-Unmount Flow.png]]

다만 위와 같은 구조는 가상 스레드가 수십~수백만 까지 늘어날 수 있기 때문에 전통적인 플랫폼 스레드와 동일한 메모리 비용, 컨텍스트 비용이 발생하면 감당하기 어렵다.
따라서 플랫폼 스레드와 가상 스레드는 자원 사용량의 차이가 있다.
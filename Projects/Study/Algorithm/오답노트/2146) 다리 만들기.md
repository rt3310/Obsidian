##### 따로 BFS를 돌리는 것 보다는 동시에 BFS를 돌리는 것이 더 효율적이다.
##### 방문 배열을 매번 초기화 하는 것 보다. 매번 다른 값을 방문 기준으로 정하는 것이 더 효율적이다.


![[Pasted image 20240713224940.png]]
첫 번째 개선 사항은 바로 같은 섬에 속한 육지에 대해 BFS를 동시에 돌리는 것입니다. 우리는 여러 개의 시작점에서 BFS를 돌리고 싶을 경우 그냥 일단 큐에 전부 넣고, 이후로는 그냥 늘 하던대로 하면 된다는 것을 알고 있습니다([BOJ 5427번 : Fire](https://icpc.me/5427), [BOJ 7576번 : 토마토](https://icpc.me/7576) 참고). 이 문제에서도 마찬가지로 같은 섬에 속한 육지에 대해, **각 육지를 따로 BFS를 돌리는 것 보다는 동시에 BFS를 돌리는 것이 더 효율적**입니다.

두 번째로, 이전에는 dist 배열을 매번 초기화해주는 과정이 필요했는데 이를 해결할 수 있는 아이디어가 있습니다. 우선 거리는 dist 배열 대신 큐에 좌표와 거리를 같이 넣는 방식으로 관리하고, 방문했는지 여부를 vis 배열로 체크합니다. 이 vis 배열에서 방문 표시는 **min_bridge 함수가 호출될 때 마다 다른 값으로 하도록 하면 vis 배열을 초기화할 필요가 없어집니다**.

![[Pasted image 20240713224955.png]]
두 번째 풀이는 O(N2)𝑂(𝑁2)에 깔끔하게 풀이가 가능한 풀이입니다. 이 풀이는 우선 섬을 파악한 후, 모든 섬에서 동시에 BFS를 돌려 섬의 영역을 확장하다가 껍데기끼리 겹쳐지는 순간을 찾는 방식입니다. 편의상 세 섬의 색을 달리 표현하겠습니다. [정답 코드](http://boj.kr/53a38e13910642babb85c51de4317064)를 확인해보세요. 여기서 주황색으로 표시된 곳이 만나는 부분들인데, 진한 주황과 옅은 주황은 전 단계의 모양을 참고해 무슨 차이가 있을지 고민해보세요.
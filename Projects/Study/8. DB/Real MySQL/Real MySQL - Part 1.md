## 모델링

- 논리 모델링 (업무 전문가)
	- 업무 분석
	- 엔터티 & 속성 & 관계 도출
	- 정규화
- 물리 모델링 (DBMS 전문가)
	- DBMS 벤더별 최적 컬럼 타입 선정
	- 접근 패턴 분석
	- 반 정규화
	- 인덱스 전략

## CHAR vs VARCHAR

#### 공통점
- 문자열 저장용 컬럼
- 최대 저장 가능 문자 길이 명시 (바이트 수 아님)

#### 차이점
- 값의 실제 크기에 관계 없이 고정된 공간 할당 여부
- 최대 저장 길이: CHAR(255) vs VARCHAR(16383) → 65535 byte
- 저장된 값의 길이 관리 여부 (VARCHAR와 가변 길이 문자셋 사용하는 CHAR는 저장된 값 길이 관리)
	- 0 ~ 255 bytes                 length-bytes: 1
	- 256 ~ 65535 bytes       length-bytes: 2

### CHAR vs VARCHAR (Latin1)
- Latin1: 고정 길이 문자셋
![[Pasted image 20240626185307.png]]
VARCHAR 타입의 길이 저장 바이트가 컬럼 바로 앞에 저장되어 있는 것 처럼 보이지만 실제로는 더 복잡하게 저장되어 있다.

### CHAR vs VARCHAR (UTF8MB4)
- UTF8MB4: 가변 길이 문자셋
![[Pasted image 20240626190425.png]]

## CHAR 타입의 공간 낭비

- 일반적으로 알고 있는 구분 기준
	- 고정된 길이의 값 저장은 CHAR 타입, 그 외의 경우 VARCHAR 타입

- CHAR 대신 VARCHAR를 사용하면?
	- 어떤 경우에는 CHAR 타입의 공간 낭비 심함
		- 저장되는 문자열의 최소 최대 길이 가변 폭이 큰 경우 (e.g. 1~100)
	- 하지만 그렇지 않은 경우도 있음
		- 저장되는 문자열의 최소 최대 길이 가변 폭이 작은 경우 (eg. 90~100)
	- 저장되는 값의 길이 변동이 크지 않다면 낭비는 크지 않음

## 컬럼 값의 길이 변경 시 작동 방법

![[Pasted image 20240626191015.png]]
- 레코드를 저장하기 위한 공간을 찾는 것이 점점 어려워진다.
- 그럼 어느 순간에는 빈 공간을 찾지 못하게 되고, 결국 페이지의 레코드들을 다시 컴펙션하는 작업을 한 후에야 비로소 새로운 레코드를 저장할 만한 공간을 찾게 되는 경우가 생긴다.

- CHAR의 경우 레코드의 위치를 옮겨 적어야하는 가능성을 낮춰줄 수 있다.
	- 컬럼의 길이 변경 시에 페이지 관리 작업을 최소화하고 자연스럽게 페이지의 프레그멘테이션을 최소화해주는 효과를 만든다.
	- 결과적으로 데이터 페이지의 조각 모음 작업이 덜 필요해지게 된다.
	- 또 레코드의 이동이 줄어들고 프레그멘테이션이 줄어들면서 공간 절약 효과까지 얻을 수 있다.

## 문자열 타입 선정

- VARCHAR 보다는 CHAR을 선택해야 하는 경우
	- 값의 가변 길이 범위 폭이 좁고
	- 자주 변경되는 경우 (특히 인덱스된 컬럼인 경우)
- 이런 경우 VARCHAR 사용 시
	- 데이터 페이지 내부의 조각화 현상 ↑↑
	- CHAR 타입보다 공간 효율 떨어짐
	- 내부적으로 빈번한 Page Reorganize 작업 필요

## VARCHAR vs TEXT

#### 공통점
- 문자열 속성 값을 저장
- 최대 65,535 Bytes 까지 저장 가능

#### 차이점
- VARCHAR 타입 컬럼에는 지정된 글자 수 만큼만 데이터 저장 가능
	- VARCHAR(10) → 10글자 이하만 저장 가능
- TEXT 타입 컬럼은 인덱스 생성 시 반드시 Prefix 길이 지정 필요
	- CREATE INDEX ix_text_column ON table (text_column(100));
- TEXT 타입 컬럼은 표현식으로만 디폴트 값 지정 가능
	- CREATE TABLE tb1 (col TEXT DEFAULT 'abc') → 에러 발생
	- CREATE TABLE tb1 (col1 TEXT DEFAULT ('abc')) → 생성 가능

#### 일반적인 사용 형태
- 길이가 짧으면 VARCHAR 타입, 길이가 길면 TEXT 타입

#### 그렇다면 VARCHAR(5000) vs TEXT ?
- VARCHAR 타입은 메모리 버퍼 공간을 미리 할당해두며 재활용 가능, TEXT 타입은 그때 그때 필요할 때마다 할당 & 해제
- 컬럼 사용이 빈번하고 메모리 용량이 충분하다면 VARCHAR 타입 추천
- VARCHAR(5000)과 같이 길이가 긴 컬럼들을 자주 추가하는 경우, Row 사이즈 제한(65,535 Bytes)에 도달할 수 있으므로 적절하게 TEXT 타입과 같이 사용하는 것을 권장

#### VARCHAR(30) vs VARCHAR(255) ?
- 실제 최대 사용하는 길이만큼 명시해야 메모리 사용 효율 증가
- 디스크 공간 효율 차이도 미미하게 존재 (1Byte vs 2Bytes)
	- 내부적으로 컬럼에 저장되는 데이터의 길이 정보를 저장하고 있다.]

## VARCHAR & TEXT 주의사항

저장되는 값의 사이즈가 크면 Off-Page 형태로 데이터가 저장될 수 있다.

![[Pasted image 20240626213554.png]]
- MySQL의 InnoDB 스토리지 엔진은 하나의 레코드 크기가 데이터 페이지의 절반크기보다 큰 경우에는 레코드에서 외부로 저장할 가변 길이 컬럼을 선택하게 되고 그렇게 선택된 컬럼은 별도 외부 페이지의 데이터가 저장된다.
- 실제 다른 컬럼들이 모두 저장되어 있는 본래의 데이터 페이지에는 이 외부 페이지를 가리키는 20 bytes 포인터 값만 저장된다.
- 이렇게 외부에 저장된 페이지를 External Off Page 또는 Overflow Page 라고 한다.
- 테이블에 설정된 InnoDB 로우 포맷에 따라 외부 페이지로 컬럼 값을 저장할 때 본래의 데이터 페이지에 저장해 두는 값의 사이즈가 다르다.

- 쿼리에서 Off-Page 컬럼의 참조 여부에 따라 쿼리 처리 성능이 매우 달라진다.
![[Pasted image 20240626214124.png]]
- 관성적으로 테이블의 모든 컬럼을 조회하는 경우가 많은데, 그런 경우 Off-Page로 저장된 큰 사이즈의 컬럼 데이터를 조회하면 쿼리 성능이 저하되고 DB 서버 자원도 비효율적으로 사용될 수 있으므로 필요 없는 경우에 한해서는 select 절에서 해당 컬럼을 제외해주는 것이 좋다.
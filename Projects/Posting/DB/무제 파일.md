# 에러 발생
```bash
Caused by: org.springframework.transaction.UnexpectedRollbackException: Transaction silently rolled back because it has been marked as rollback-only
```

  → 롤백 전용으로 표시되어 있기 때문에 트랜잭션이 자동으로 롤백됨
# 발생 원인
```java

@Service
@RequiredArgsConstructor
class AuthenticationService {
	private final MemberQueryService memberQueryService;
	private final SignupService signupService;

	@Transactional
	public Member authenticateToken(String idToken, String accessToken) {
		try {
			return memberQueryService.findByAccount(getAccount(idToken));
		} catch (EntityNotFoundException e) {
			return signupService.signup(accessToken);
		}
	}
}
```

DB에 Member가 저장되어있지 않을 경우 EntityNotFoundException을 던지는데, 
인증 성공 후 Member가 없을 시 이를 잡아 `signup()` 메서드를 실행하여 Member를 등록하려 했다.

하지만 위 예외(`UnexpectedRollbackException`)가 발생하였고 자동으로 롤백되어 Member가 저장되지 않았다.

# 롤백 상황
### 상황 1 - Rollbacked
```java
	@Transactional
	public void test1(Long id) {
		Domain domain = findById(id);

		test2(domain);
	}

	private void test2(Domain domain) {
		domain.plus();
		throw new RuntimeException("throw error");
	}
```
Spring의 @Transactional은 메서드를 호출하는 동안 데이터베이스 트랜잭션을 시작하고, 메서드 실행이 완료되면 트랜잭션을 커밋한다.
만약 메서드 실행 도중에 unchecked exception (예를 들어, RuntimeException과 그 하위 클래스들)이 발생하면, 트랜잭션은 자동으로 롤백된다.

위 `test2()`는 `test1()`의 트랜잭션 컨텍스트에서 실행되므로, `test1()`과 `test2()` 는 동일한 트랜잭션을 공유한다. `test2()`에서 RuntimeException을 던지면, `test1()`의 트랜잭션을 롤백시킨다.

따라서 `test2()`에서 `domain.plus();` 로 인한 변경사항은 롤백되게 되며, 이는 `test2()`에서 발생한 RuntimeException이 동일한 트랜잭션을 공유하는 `test1()`의 트랜잭션을 롤백시키기 때문이다.

### 상황 2 - Rollbacked
```java
public class A {
	@Transactional
	public void test1(Long id) {
		Domain domain = findById(id);

		B.test2(domain);
	}
}

public class B {
	@Transcational
	public void test2(Domain domain) {
		domain.plus();
		throw new RuntimeException("throw error");
	}
}
```
현재 `A.test1()`과 `B.test2()`가 전부 @Transactional이 붙어있다. 기본적으로 Spring의 @Transactional은 호출된 메서드가 이미 트랜잭션의 일부인지 확인하는데, 만약 일부라면 그 메서드는 기존 트랜잭션의 일부로 실행되며, 이를 트랜잭션 전파라고 부른다.
A.test1()에서 호출되는 B.test2()는 동일한 트랜잭션에서 실행되며 B.test2()에서 RuntimeException이 발생하면, 이 **예외는 메서드 호출 스택을 통해 상위 메서드로 전파**된다. 

결과적으로, **B.test2()에서 발생한 예외로 인해 domain.plus()의 변경사항이 롤백된다.**

### 상황 3 - Rollbacked
```java
	@Transactional
	public void test1(Long id) {
		Domain domain = findById(id);

		test2(domain);
	}

	@Transactional(propagation = Propagation.REQUIRES_NEW)
	public void test2(Domain domain) {
		domain.plus();
		throw new RuntimeException("throw error");
	}
```
위 코드는 같은 클래스 내에 있는 메서드들이다. 따라서 `test2()`는 Spring 프록시를 거치지 않고 호출된다.
이는 `test2()`에 설정된 **@Transactional(propagation = Propagation.REQUIRES_NEW) 전파 정책이 무시되고, test1()의 트랜잭션을 사용**하게 되며, `test2()` 메서드는 **새로운 트랜잭션을 시작하지 않고 test1()의 트랜잭션 범위 내에서 실행된다**는 것을 의미한다.

따라서 `test2()`에서 발생한 RuntimeException은 `test1()`의 트랜잭션을 롤백시키게 되며, **최종적으로 `test2()`에서 예외가 발생하여 전체 트랜잭션이 롤백**이 된다.

이러한 현상을 피하기 위해서는 `test2()`를 다른 클래스로 이동하거나, 같은 클래스 내에서도 프록시를 통해 메서드를 호출하도록 수정하는 방법으로 해결할 수 있습니다.

### 상황 4 - Rollbacked
```java
public class A {
	@Transactional
	public void test1(Long id) {
		Domain domain = findById(id);

		B.test2(domain);
	}
}

public class B {
	@Transcational(propagation = Propagation.REQUIRES_NEW)
	public void test2(Domain domain) {
		domain.plus();
		throw new RuntimeException("throw error");
	}
}
```
예시 3과 동일하지만, 다른 클래스에 존재하는 메서드들이다.

**`B.test2()`에서는 @Transactional(propagation = Propagation.REQUIRES_NEW)이 적용되어 A.test1()의 트랜잭션과는 별개의 새로운 트랜잭션을 시작한다.**
이렇게 설정하면 `B.test2()` 트랜잭션은 `A.test1()` 트랜잭션과 독립적이게 되며, **서로 다른 생명 주기를 가져 하나의 트랜잭션에서 발생한 문제가 다른 트랜잭션에 영향을 주지 않는다.**

실행 흐름은 다음과 같다.
1. `A.test1()`이 트랜잭션을 시작한다.
2. `B.test2()`가 새로운 트랜잭션을 시작하고, `domain.plus()`를 수행한 후, RuntimeException을 발생시킨다.
3. RuntimeException이 발생했기 때문에, Spring은 현재 트랜잭션(`B.test2()`의 트랜잭션)을 롤백한다.
4. 그러나 `A.test1()`에서 시작된 첫 번째 트랜잭션은 `B.test2()`의 실패와 관계없이 계속 진행된다.

즉, 이 경우 `B.test2()`에서 발생한 예외로 인해 `B.test2()`의 트랜잭션이 롤백된다.
하지만 별개의 트랜잭션 이기 때문에 `A.test1()`의 트랜잭션은 `B.test2()`의 실패로 인해 직접적으로 영향을 받지 않는다. 다만 `B.test2()`에서 발생한 예외로 인해 `B.test2()`의 트랜잭션에서 롤백이 일어나고, **`B.test2()`에서 발생한 예외는 호출자에게 전파되어 `A.test1()`에게 전파된다. 따라서 `B.test2()` 뿐만 아니라 `A.test1()`에  추가 작업이 있다면 이 작업도 롤백된다.**

즉, **최종적으로 domain.plus()의 작업은 반영되지 않는다.**
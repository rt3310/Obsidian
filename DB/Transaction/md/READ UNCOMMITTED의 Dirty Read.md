예를 들어 사용자 A의 트랜잭션에서 INSERT를 통해 데이터를 추가했다고 하자. 아직 커밋 또는 롤백이 되지 않는 상태임에도 불구하고 READ UNCOMMITTED는 변경된 데이터에 접근할 수 있다.
![[read uncommitted 1.png]]

이렇듯 **어떤 트랜잭션의 작업이 완료되지 않았는데도, 다른 트랜잭션에서 볼 수 있는 부정합 문제**를 **Dirty Read(오손 읽기)** 라고 한다.
Dirty Read는 데이터가 조회되었다가 사라지는 현상을 초래하므로 시스템에 상당한 혼란을 주게 된다.
만약 위의 경우에 사용자 A가 커밋이 아닌 롤백을 수행한다 해보자.

![[read uncommitted 2.png]]
사용자 B의 트랜잭션은 id=51인 데이터를 계속 처리하고 있을 텐데, 다시 데이터를 조회하니 결과가 존재하지 않는 상황이 생긴다. 이러한 Dirty Read 상황은 시스템에 상당한 버그를 초래할 것이다.
그래서 READ UNCOMMITTED는 RDBMS 표준에서 인정하지 않을 정도로 정합성에 문제가 많은 격리 수준이다. 

따라서 MySQL을 사용한다면 최소한 READ COMMITTED 이상의 격리 수준을 사용해야 한다.
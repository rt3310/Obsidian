{
	"nodes":[
		{"id":"434c95c3c3bafa5a","type":"file","file":"DB/Transaction/SERIALIZABLE 작동 방식.md","x":1220,"y":-533,"width":664,"height":276},
		{"id":"dcbb3435d83bc9d2","type":"text","text":"# Transaction 격리 수준","x":-693,"y":-508,"width":310,"height":39},
		{"id":"c50d0668cf011443","type":"text","text":"여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 여부를 결정하는 것","x":-80,"y":-620,"width":507,"height":87},
		{"id":"f06c929a4b103795","type":"text","text":"- Serializable\n- Repeatable Read\n- Read Commited\n- Read Uncommited","x":-151,"y":-387,"width":224,"height":130},
		{"id":"1a3a712d3cd012fb","type":"file","file":"DB/Transaction/SERIALIZABLE.md","x":380,"y":-475,"width":631,"height":176},
		{"id":"f7ee296a63e98a81","type":"file","file":"DB/Transaction/REPEATABLE READ.md","x":380,"y":-180,"width":513,"height":116},
		{"id":"3e0701bc6a8cbd11","type":"file","file":"DB/Transaction/MVCC.md","x":1160,"y":-151,"width":603,"height":346},
		{"id":"82136eeeccd2995b","type":"file","file":"DB/Transaction/REPEATABLE READ 작동 방식.md","x":1160,"y":360,"width":824,"height":2087},
		{"id":"6011cf39079fc0c1","x":2400,"y":-299,"width":808,"height":2852,"type":"text","text":"앞서 설명하였듯 REPEATABLE READ는 새로운 레코드의 추가까지는 막지 않는다고 하였다. 따라서 SELECT로 조회한 경우 트랜잭션이 끝나기 전에 다른 트랜잭션에 의해 추가된 레코드가 발견될 수 있는데, 이를 유령 읽기(Phantom Read)라고 한다.\n하지만 MVCC 덕분에 일반적인 조회에서 유령 읽기(Phantom Read)는 발생하지 않는다. 왜냐하면 자신보다 나중에 실행된 트랜잭션이 추가한 레코드는 무시하면 되기 때문이다.\n\n![[repeatable read 4.png]]\n\n그렇다면 언제 Phantom Read가 발생하는 것일까? 바로 **잠금이 사용되는 경우**이다. MySQL은 다른 RDBMS와 다르게 특수한 갭 락이 존재하기 때문에, 동작이 다른 부분이 있으므로 일반적인 RDBMS 부터 살펴보자.\n\n마찬가지로 사용자 B가 먼저 데이터를 조회하는데, 이번에는 SELECT FOR UPDATE를 이용해 쓰기 잠금을 걸었다.\n> [!INFO]\n> SELECT ... FOR UPDATE 구문은 베타적 잠금(비관적 잠금, 쓰기 잠금)을 거는 것이다.\n> 읽기 잠금을 걸려면 SELECT FOR SHARE 구문을 사용해야 한다.\n\n> [!TIP]\n> 락은 트랜잭션이 커밋 또는 롤백될 때 해제된다.\n\n그리고 사용자 A가 새로운 데이터를 INSERT하는 상황이라고 하자. 일반적인 DBMS에서는 갭락이 존재하지 않으므로 id=50인 레코드만 잠금이 걸린 상태이고, 사용자 A의 요청은 잠금 없이 즉시 실행된다.\n\n![[repeatable read 5.png]]\n\n이때 사용자 B가 동일한 쓰기 잠금 쿼리로 다시 한번 데이터를 조회하면, 이번에는 2건의 데이터가 조회된다.\n동일한 트랜잭션 내에서도 새로운 레코드가 추가되는 경우에 조회 결과가 달라지는데, 이렇듯 다른 트랜잭션에서 수행한 작업에 의해 레코드가 안보였다 보였다하는 현상을 Phantom Read라고 한다. 이는 다른 트랜잭션에서 새로운 레코드를 추가하거나 삭제하는 경우 발생할 수 있다.\n\n![[repeatable read 6.png]]\n\n이 경우에도 MVCC를 통해 해결될 것 같지만, 두 번째 실행되는 SELECT FOR UPDATE 때문에 그럴 수 없다. 왜냐하면 잠금있는 읽기는 데이터 조회가 언두 로그가 아닌 테이블에서 수행되기 때문이다.\n\n잠금있는 읽기는 테이블에 변경이 일어나지 않도록 테이블에 잠금을 걸고 테이블에서 데이터를 조회한다.\n잠금이 없는 경우처럼 언두 로그를 바라보고 언두 로그를 잠그는 것은 불가능한데, 그 이유는 언두 로그가 append only 형태이므로 잠금 장치가 없기 때문이다.\n따라서 SELECT FOR UPDATE나 SELECT FOR SHARE로 레코드를 조회하는 경우에는 언두 영역의 데이터가 아니라 테이블의 레코드를 가져오게 되고, 이로 인해 Phantom Read가 발생하는 것이다.\n\n"}
	],
	"edges":[
		{"id":"024717a02585fb07","fromNode":"dcbb3435d83bc9d2","fromSide":"right","toNode":"c50d0668cf011443","toSide":"left","label":"트랜잭션 격리 수준?"},
		{"id":"f61fe5f84a7c6c94","fromNode":"dcbb3435d83bc9d2","fromSide":"right","toNode":"f06c929a4b103795","toSide":"left","label":"격리 수준 종류"},
		{"id":"9c4375081c546657","fromNode":"f06c929a4b103795","fromSide":"right","toNode":"1a3a712d3cd012fb","toSide":"left","label":"Serializable?"},
		{"id":"77d8699f2458b74e","fromNode":"1a3a712d3cd012fb","fromSide":"right","toNode":"434c95c3c3bafa5a","toSide":"left","label":"작동 방식"},
		{"id":"e8f4014e6521e8b7","fromNode":"f7ee296a63e98a81","fromSide":"right","toNode":"3e0701bc6a8cbd11","toSide":"left","label":"MVCC?"},
		{"id":"755d82fe72b6967c","fromNode":"f06c929a4b103795","fromSide":"right","toNode":"f7ee296a63e98a81","toSide":"left","label":"Repeatable Read?"},
		{"id":"e6362c426605c1bf","fromNode":"f7ee296a63e98a81","fromSide":"right","toNode":"82136eeeccd2995b","toSide":"left","label":"작동 방식"},
		{"id":"9ef4ac900a20b482","fromNode":"82136eeeccd2995b","fromSide":"right","toNode":"6011cf39079fc0c1","toSide":"left","label":"Phantom Read는 언제 발생?"}
	]
}
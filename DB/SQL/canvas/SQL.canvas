{
	"nodes":[
		{"id":"d0073da8fb9ec9c6","type":"file","file":"DB/SQL/md/반복계의 단점.md","x":120,"y":-304,"width":556,"height":151},
		{"id":"a3e8dfd90e9305e5","type":"text","text":"# 반복계","x":-280,"y":-364,"width":250,"height":60},
		{"id":"111eaf1956dadc82","type":"text","text":"- 실행 계획의 안정성\n- 예상 처리 시간의 정밀도\n- 트랜잭션 제어가 편리","x":122,"y":-560,"width":554,"height":171},
		{"id":"dee0d4374ec7cbb0","type":"file","file":"DB/SQL/md/결합 알고리즘 종류.md","x":-144,"y":385,"width":429,"height":329},
		{"id":"4388858d55e561aa","type":"text","text":"# 결합","x":-580,"y":520,"width":250,"height":60},
		{"id":"3a31f4fdb2fc520a","type":"file","file":"DB/SQL/md/Nested Loops.md","x":440,"y":379,"width":666,"height":342},
		{"id":"01304f18aa6c99ac","type":"file","file":"DB/SQL/md/반복계가 포장계에 성능적으로 질 수 밖에 없는 이유.md","x":940,"y":-1140,"width":657,"height":1084},
		{"id":"5af13ca78b01043d","type":"file","file":"DB/SQL/md/구동 테이블의 중요성.md","x":1340,"y":86,"width":700,"height":464},
		{"id":"f0eba82ecd5cfcfb","type":"text","text":"'구동 테이블이 작은 Nested Loops' + '내부 테이블의 결합 키에 인덱스'라는 조합만 있다면 성능은 충분하다고 생각할 수 있다. 하지만 기대만큼의 응답 시간이 나오지 않기도 한다.\n\n**보통 이런 경우는 결합 키로 내부 테이블에 접근할 대 히트되는 레코드가 너무 많기 때문**이다. 이는 앞에서 설명했던 **결합키가 내부 테이블에 대해 유일하지 않은 경우**에 발생할 수 있다. 여러가지 방법으로 인덱스를 사용해 반복을 생략할 수 있다고 해도, 결국 절대적인 양이 너무 많으면 반복이 많이 일어난다.\n\n예를 들어 점포 테이블과 점포에서 받은 주문 테이블을 생각해보자. 이런 경우 하나의 점포에 대해 여러 개의 주문이 대응하므로 점포 테이블이 당연히 작을 것이다. 따라서 점포 테이블을 구동 테이블로 만들고 점포 ID를 결합 키로 사용하면 될 것이다.\n여기까지는 굉장히 좋은 생각이지만, 한 개의 점포 ID에 수백만 건, 수천만 건의 레코드가 히트된다면 결국 내부 테이블에 대해 반복 횟수가 많아져서 Nested Loops 성능이 낮아진다.\n\n이 문제에 대처하는 방법은 두 가지이다.\n\n첫 번째는 **구동 테이블로 큰 테이블을 선택**하는 역설적인 방법이다.\n이렇게 하면 내부 테이블에 대한 점포 테이블의 접근이 기본 키(점포 ID)로 수행되므로, 항상 하나의 레코드로 접근하는 것이 보장된다.\n따라서 점포에 따른 성능 비균등 문제를 해결해서, 극단적으로 성능이 저하되는 것을 막을 수 있다. 이는 주문 테이블이라는 거대 테이블 접근 비용이 현실적인 범위라면 굉장히 효과적인 방법이다.\n\n두번째는 해시이다.","x":1340,"y":620,"width":825,"height":728},
		{"id":"ab6ffcea0a9f3a1c","type":"file","file":"DB/SQL/md/Hash.md","x":440,"y":1380,"width":638,"height":444},
		{"id":"1429de098de68a9a","type":"file","file":"DB/SQL/md/Hash가 유용한 경우.md","x":1240,"y":1440,"width":652,"height":244},
		{"id":"538cec540c8f50b2","type":"file","file":"DB/SQL/md/Hash 트레이드오프.md","x":1240,"y":1740,"width":652,"height":352},
		{"id":"161c8af1f9cd0114","type":"text","text":"Sort Merge는 결합 대상 테이블을 각각 결합 키로 정렬하고 일치하는 결합 키를 찾으면 결합한다.\n\n- 특징\n\t- 대상 테이블을 모두 정렬해야 하므로 Nested Loops보다 많은 메모리를 소비한다. Hash와 비교하면 규모에 따라 다르지만 Hash는 한쪽 테이블에 대해서만 해시 테이블을 만드므로 Hash보다 많은 메모리를 사용하기도 한다.\n\t- Hash와 다르게 동치 결합뿐만 아니라 부등오를 사용한 결합에도 사용할 수 있다. 하지만 부정 조건(<>) 결합에는 사용할 수 없다.\n\t- 원리적으로는 테이블이 결합 키로 정렬되어 있다면 정렬을 생략할 수 있다. 다만 이는 SQL에서 테이블에 있는 레코드의 물리적인 위치를 알고 있을 때이다. 따라서 이러한 생략은 구현 의존적이다.","x":476,"y":2180,"width":602,"height":342},
		{"id":"9deb3cdd53682807","type":"file","file":"DB/SQL/md/Soft Merge가 유용한 경우.md","x":1356,"y":2320,"width":571,"height":176},
		{"id":"8fcbdb14e3e678e6","type":"text","text":"인덱스는 테이블의 특정 필드 집합에 대해 만든다. 이때 어떤 필드에 대해 인덱스를 작성할 것인지 기준이 되는 요소가 필드의 카디널리티와 선택률이다.\n\n- 카디널리티란 값의 균형을 나타내는 개념이다. 카디널리티가 가장 높은 필드는 모든 레코드에 다른 값이 들어가 있는 유일 키 필드이다. 반대로 모든 레코드에 같은 값이 들어가 있다면 카디널리티가 낮은 필드이다.\n- 선택률은 특정 필드 값을 지정했을 때 테이블 전체에서 몇 개의 레코드가 선택되는지를 나타내는 개념이다.\n\t- 예를 들어서 100개의 레코드를 가진 테이블에서 유일키로 'pkey=1'처럼 등호를 지정한다면 한 개의 레코드가 선택될 것이다. 따라서 1/100 = 0.01로 선택률은 1%이다.","x":-260,"y":2661,"width":649,"height":291},
		{"id":"5c371f64ceefd6fb","type":"text","text":"# 인덱스","x":-740,"y":2860,"width":250,"height":60},
		{"id":"bd81d9d1266de109","type":"file","file":"DB/SQL/md/인덱스를 사용하는 것이 좋은지 판단.md","x":-282,"y":3000,"width":671,"height":342},
		{"id":"51a0038c802438bd","type":"file","file":"DB/SQL/md/인덱스를 사용할 수 없는 경우.md","x":-289,"y":3491,"width":709,"height":463},
		{"id":"c4636296ff1b9d7a","type":"file","file":"DB/SQL/md/인덱스를 사용할 수 없는 경우 대처.md","x":600,"y":3338,"width":675,"height":770}
	],
	"edges":[
		{"id":"c7c4aa7e9ce897d8","fromNode":"a3e8dfd90e9305e5","fromSide":"right","toNode":"d0073da8fb9ec9c6","toSide":"left"},
		{"id":"0f5bfee24964da42","fromNode":"d0073da8fb9ec9c6","fromSide":"right","toNode":"01304f18aa6c99ac","toSide":"left"},
		{"id":"5c6d23abcc6d3680","fromNode":"a3e8dfd90e9305e5","fromSide":"right","toNode":"111eaf1956dadc82","toSide":"left"},
		{"id":"2d2bdd60e915694c","fromNode":"4388858d55e561aa","fromSide":"right","toNode":"dee0d4374ec7cbb0","toSide":"left"},
		{"id":"e5c4e5c8173ac307","fromNode":"dee0d4374ec7cbb0","fromSide":"right","toNode":"3a31f4fdb2fc520a","toSide":"left"},
		{"id":"58f2587be0279e0b","fromNode":"3a31f4fdb2fc520a","fromSide":"right","toNode":"5af13ca78b01043d","toSide":"left"},
		{"id":"5f5fbfb5ad283caa","fromNode":"3a31f4fdb2fc520a","fromSide":"right","toNode":"f0eba82ecd5cfcfb","toSide":"left"},
		{"id":"98e53b7f2135311f","fromNode":"dee0d4374ec7cbb0","fromSide":"right","toNode":"ab6ffcea0a9f3a1c","toSide":"left"},
		{"id":"620aeabb444e7d5d","fromNode":"ab6ffcea0a9f3a1c","fromSide":"right","toNode":"1429de098de68a9a","toSide":"left"},
		{"id":"9ff6ae8fa5037a87","fromNode":"ab6ffcea0a9f3a1c","fromSide":"right","toNode":"538cec540c8f50b2","toSide":"left"},
		{"id":"0c141e61c64eae4d","fromNode":"dee0d4374ec7cbb0","fromSide":"right","toNode":"161c8af1f9cd0114","toSide":"left"},
		{"id":"1b1f0e123d7aeea7","fromNode":"161c8af1f9cd0114","fromSide":"right","toNode":"9deb3cdd53682807","toSide":"left"},
		{"id":"64cec5bed1a88bb9","fromNode":"5c371f64ceefd6fb","fromSide":"right","toNode":"8fcbdb14e3e678e6","toSide":"left"},
		{"id":"8715d77d38ecd1c1","fromNode":"5c371f64ceefd6fb","fromSide":"right","toNode":"bd81d9d1266de109","toSide":"left"},
		{"id":"3cf6f4651da0f2eb","fromNode":"5c371f64ceefd6fb","fromSide":"right","toNode":"51a0038c802438bd","toSide":"left"},
		{"id":"d0b06879716d961f","fromNode":"51a0038c802438bd","fromSide":"right","toNode":"c4636296ff1b9d7a","toSide":"left"}
	]
}
{
	"nodes":[
		{"id":"42a5762343f26cb1","type":"text","text":"# Session in Multi Server","x":-560,"y":-259,"width":334,"height":39},
		{"id":"2e8bba703a9c0bfc","type":"text","text":"세션은 서버 1대에 하나의 저장소가 형성된다.\n나누어진 세션 저장소에 대한 별도의 처리가 없다면 각각의 세션들은 정합성 이슈를 발생시킨다.\n\n![[Session per WAS.png]]\n때문에 여러 대로 나뉜 서버가 하나의 서비스를 운영하기 위해서는 4개의 분리된 세션을 하나의 시스템처럼 동작하게 하거나, 고정된 세션을 사용해야 한다.","x":120,"y":-500,"width":560,"height":528},
		{"id":"d01ca641c99f9608","type":"text","text":"all-to-all 세션 복제란 하나의 세션 저장소에 변경되는 요소가 발생하면 변경된 사항이 다른 모든 세션에 복제가 된다는 것을 말한다.\n![[all-to-all session replication.png]]\n위 그림과 같이 세션을 복제한다면 유저가 이후에 어떤 서버에 접속하더라도 로그인 정보가 세션에 복제되어 있으므로 정합성 이슈를 해결할 수 있다.\n이로써 서버 하나에 장애가 발생하더라도 서비스는 중단되지 않고 운영이 가능하다.","x":2100,"y":-438,"width":580,"height":640},
		{"id":"d7d85387efaa06af","type":"text","text":"![[primary-secondary session replication.png]]\n위 그림과 같이 Primary 서버는 Secondary(Backup) 서버에 세션 객체의 Key-Value 전체를 복제한다. 하지만 이외의 서버에는 Key에 해당하는 JSESSIONID만을 복제하기 때문에 메모리 사용이 all-to-all 방식보다 줄어든다.\n\n그러므로 이러한 방식은 4개 이상의 대규모 클러스터에서 사용이 용이하다. Tomcat 8.0 버전까지는 공식문서에서 해당 방법이 all-to-all 복제 방식만큼 검증된 방식이 아니라고 명시되어 있었으나, Tomcat 9.0 Document에서 해당 내용이 빠진 것을 미루어 보아 안정화되어 사용할 수 있을 것으로 예상된다.\n\n그럼에도 불구하고 아직 문제점은 존재한다.\n세션을 복제하는 데 걸리는 시간은 줄일 수 있었으나, Primary 서버와 Secondary 서버를 제외한 Proxy 서버에 세션 정보를 요청할 경우에는 다시 Primary 서버에 요청하여 해당 Key에 해당하는 객체를 받아와야만 한다.\n\n이처럼 Tomcat의 세션 클러스터링은 정합성 이슈를 해결할 수 있지만, 성능적인 한계가 존재한다.","x":2880,"y":134,"width":680,"height":863},
		{"id":"312f092453d8b904","type":"text","text":"하지만 Tomcat의 all-to-all 세션 복제 방식은 고려해야 할 단점들이 존재한다.\n\n우선, 모든 서버가 동일한 세션 객체를 가져야 하기 때문에 **많은 메모리가 필요**하다.\n또한 세션 저장소에 데이터가 저장될 때마다 모든 서버에 값을 입력해야하므로 **서버 수에 비례하여 네트워크 트래픽이 증가하는 등 성능 저하가 발생**하게 된다.\n\n그러므로 해당 방식은 **소규모 클러스터에서 좋은 효율을 보여준다**. **4개 이상의 서버를 가진 대규모 클러스터들에는 추천하지 않는 방식**이다.\n\nTomcat은 이를 해결할 방법으로 `BackupManager`를 활용한 primary-secondary 세션 복제 방식을 제시한다.","x":2940,"y":-264,"width":578,"height":292},
		{"id":"4911a35e1853227e","type":"text","text":"여러 대의 컴퓨터들이 연결되어 하나의 시스템처럼 동작하도록 만드는 것을 클러스터링이라고 한다.\n서버 또한 컴퓨터로서 여러 대가 하나의 서비스를 하기 위해서는 클러스터링이 필요하다.\n\n- Tomcat 9.0 Document  \n    [http://tomcat.apache.org/tomcat-9.0-doc/cluster-howto.html](http://tomcat.apache.org/tomcat-9.0-doc/cluster-howto.html)\n\t- 첨부된 Tomcat 9.0 Document를 보면 톰캣이 세션 클러스터링을 구현하는 방법으로 `DeltaManager`를 사용하여 all-to-all 세션 복제 방식을 제안한다.","x":1040,"y":-220,"width":681,"height":204},
		{"id":"ed1f565c95f83647","type":"text","text":"하지만 이 방식에도 단점이 존재한다.\n\n먼저, 고정된 세션을 사용한다는 것은 특정 서버에 트래픽이 집중될 위험이 있다.\n사용자가 접속해야 하는 서버가 정해져 있기 때문에 하나의 서버에 트래픽이 집중되어 있더라도 사용자는 자신의 세션이 없는 다른 서버를 사용할 수 없다.\n\n![[Sticky Session Problem.png]]\n또 위 그림을 보면 서비스 중에 하나의 서버에 장애가 발생하게 되면 해당 서버를 사용하는 사용자들은 세션 정보를 잃어버리게 된다. -> 가용성이 떨어진다.\n\nSticky Session을 사용하면 정합성 이슈를 해결할 수 있지만 스케일 아웃의 장점인 가용성과 트래픽 분산을 완벽히 사용할 수는 없다.","x":1920,"y":-1180,"width":566,"height":648},
		{"id":"e5462ca6ce8d8e8e","type":"text","text":"Sticky Session이란 말 그대로 고정된 세션을 의미한다.\n![[Sticky Session.png]]\n\n예를 들어, User1이 1번부터 3번까지의 서버 중 1번 서버에 세션을 생성했다면, 이후에 User1이 보내는 모든 요청은 1번 서버로만 보내지게 된다. 즉, Load Balancer는 User가 첫 번째 세션을 생성한 서버로 모든 요청을 리다이렉트하여 고정된 세션만 사용하게 한다.\n\n이를 위해서 로드 밸런서는 요청을 받으면 가장 먼저 요청에 쿠키가 존재하는지 확인한다.\n쿠키가 있으면 해당 요청이 쿠키에 지정된 서버로 전송된다.\n쿠키가 없는 경우에는 로드 밸런서가 기존 로드 밸런싱 알고리즘을 기반으로 서버를 선정한다.\n\n동일한 사용자가 계속 해당 서버에 요청을 보낼 수 있도록 지속적으로 서버 정보가 쿠키를 통해 응답에 삽입되어 보내진다.\n\n이러한 방식을 사용하면 유저는 세션이 유지되는 동안 동일한 서버만을 사용하기 때문에 정합성 이슈에서 자유로워질 수 있다.","x":1040,"y":-1212,"width":660,"height":712},
		{"id":"a863b5e70815e4cc","type":"text","text":"세션 스토리지를 분리한다는 것은, 기존 서버가 갖고있는 로컬 세션 저장소를 사용하는 것이 아니라, 별도의 세션 저장소를 사용하는 것을 의미한다.\n\n![[Pasted image 20231207164644.png]]\n위와 같이 세션 스토리지가 분리되면, 서버가 아무리 늘어난다고 할 지라도 세션 스토리지에 대한 정보만 각각의 서버에 입력해주면 세션을 공유할 수 있게 된다.\n\n이러한 방식을 사용한다면 로드밸런싱 알고리즘만 잘 구현되어 있다는 가정 하에 Sticky Session처럼 트래픽이 비정상적으로 몰리는 현상을 고려하지 않아도 되게 된다.\n\n또한 서버가 하나 장애가 발생하더라도 별도의 세션 저장소가 존재하기 때문에 서비스를 계속해서 제공할 수 있다. -> 가용성을 확보할 수 있다\n\n뿐만 아니라 정합성 문제도 해결할 수 있다.\n여러 대의 서버가 하나의 세션을 사용하기 때문에 기존에 개별적으로 갖고 있던 로컬 세션 저장소의 데이터 불일치가 발생하지 않기 때문이다.\n\n무엇보다도 세션 저장소가 하나이기 때문에 데이터 정합성 해결을\b위한 별도의 세션 복제를 할 필요가 없어서 이에 대한 성능적인 문제도 해결이 가능하다.\n단, 세션 저장소도 세션 객체를 복제해야 할 필요가 있다. 이는 데이터 정합성 문제를 해결하기 위한 것이 아니라, 하나의 세션 저장소를 운영한다는 것은 그만큼 해당 서버에 장애가 발생하면, 모든 세션 이용이 불가하다는 뜻이기 때문에 가용성을 확보하기 위해 동일한 세션 저장소 하나를 더 구성하여 복제하는 것이다.","x":1040,"y":271,"width":605,"height":927},
		{"id":"647776bbbf95d9cb","type":"text","text":"**세션에 저장하는 데이터들은 영구적으로 저장하는 데이터가 아니다**.\n로그인 한 사용자 정보를 예로 들어보면, 로그아웃을 할 경우, 사용자의 세션 객체는 만료된다. 더 나아가 로그아웃을 하지 않더라도 개발자가 정한 일정 시간이 지나면 자동적으로 만료되게 된다. 만료된 이후에 다시 서비스를 사용하기 위해서는 재로그인을 하면된다. 또한 로그아웃을 하지 않고, 브라우저를 종료한 경우에도 쿠키에 저장된 세션 ID가 사라지기 때문에 서버에 저장되어 있던 기존 세션 객체 사용이 불가하므로 다시 로그인을 해야한다.\n\n이렇게 세션을 관리하는 이유는 다양하다. 현재 사용 중이지 않는 사용자의 데이터를 계속해서 세션 저장소에 보관하게 된다면, 일정 시간 후에는 **메모리 부족 현상이 발생**할 수 있다. 또한 **세션이 지속적으로 유지된다면 해커의 세션 기반 공격에 대한 노출이 증가**하기 때문에 **일정 시간 후 세션을 만료시키도록 해야한다**.\n\n세션에 저장되는 데이터가 이러한 특성을 지니기 때문에 상대적으로 서비스 장애로 인하여 데이터가 소멸됨에 있어서 피해가 적다. 계속해서 로그인한 사용자 데이터의 경우를 생각해보면 세션 객체에 저장되는 사용자 정보 역시 In-Memory DB의 장애로 인해 내부에서 소멸하더라도 사용자가 다시 로그인 요청을 하여 세션에 저장될 정보를 가져온다면 서비스를 재사용할 수 있다.\n\n물론 이러한 단점으로 발생하는 서비스 중단을 해결하기 위해서 일부 In-Memory DB에서는 Replication이라는 기능을 통해 failover를 지원한다. 아래 그림을 보는 바와 같이 **Master DB를 Slave DB에 복제함으로써 가용성을 높일 수 있다**.\n만일 Master DB에 장애가 발생하여 사용할 수 없을 시에는 Slave DB를 Master DB로 승격시켜 서비스를 중단 없이 지속적으로 제공할 수 있다.\n![[DB Replication.png]]","x":2120,"y":280,"width":560,"height":918},
		{"id":"bbf910ce7fa86bd7","type":"text","text":"세션 객체는 Key에 해당하는 SESSION ID와 이에 대응하는 Value로 구성된다.\nValue에는 세션 생성 시간, 마지막 접근 시간 및 User가 저장한 속성 등이 Map 형태로 저장된다.\n\n세션 객체가 저장되는 방식과 유사하게 Key-Value 형태로 데이터를 저장하는 데이터베이스가 있다. 이를 Key-Value 데이터베이스 혹은 Key-Value Model NoSQL이라고 한다.\n\n이러한 데이터베이스의 특징은 Key-Value 형태로 단순하다는 점이다. 이로 인해 관계형 데이터베이스와 같이 복잡한 조회 연산을 지원하지 않지만, 단일 키 처리만을 지원하기 때문에 고속 읽기와 쓰기에 최적화된 경우가 많다. 특히 세션에 저장되는 데이터의 경우에는 대부분 비교적 간단한 연산을 통해 처리를 할 수 있다.\n\n이러한 점에서 Key-Value 형태의 데이터베이스가 세션 저장소로서 적합하다고 볼 수 있다.\n그 중에서도 세션 저장소로 가장 많이 사용되는 것이 바로 Redis와 Memcached이다.\n\n엄밀히 말하면 Memcached는 캐시 솔루션으로써 전원이 꺼지게 되면 데이터가 사라지기 때문에 영속성을 보장할 수 없다는 점에서 데이터베이스나 저장소는 아니다.\nRedis는 AOF와 RDB 기능을 통해서 디스크에 데이터를 저장하여 영속성을 보장할 수 있다.","x":2088,"y":1340,"width":627,"height":452},
		{"id":"77ae443d3dce7a87","x":3060,"y":1340,"width":656,"height":88,"type":"text","text":"Memcached와 Redis는 In-Memory 기반으로 동작한다는 점과, Key-Value 형태로 데이터를 저장한다는 점에서 공통적인 특성을 지니고 있다. 이러한 특성은 두 저장소 모두 빠르게 데이터를 처리할 수 있다는 장점으로 이어진다."},
		{"id":"62c5ead0e6880baa","x":3060,"y":1566,"width":772,"height":774,"type":"text","text":"첫 번째는 failover(장애 극복 기능)이다.\n- Redis의 경우, **Replication을 지원**하기 때문에 **서버 하나에 장애가 발생하더라도 복제된 Slave 서버를 Master로 승격**시켜서 서비스를 중단 없이 운영할 수 있도록 한다.\n- 하지만, Memcached의 경우에는 **Replication을 지원하지 않는다**. 대신 서비스 중단을 최소화하기 위해서 **'Consistent Hashing'으로 인하여 서버 1대가 장애가 발생하더라도, 나머지 노드에 있는 데이터들은 재배치할 필요 없이 장애가 발생한 노드의 데이터들만 손실**되기 때문에 나머지 노드들은 지속적으로 운영이 가능하다.\n- ![[Pasted image 20231207173241.png]]\n- 이러한 방식의 경우, Memcached 서버의 숫자를 늘리게 되면 그 피해를 감소시킬 수 있다.\n\t- 예를 들어, 3대 중 1대에 장애가 발생하면, 약 33%의 데이터를 손실하지만, 4대 중 1대에서 장애가 발생한다면, 25%의 데이터만 손실된다. 그러므로 노드가 많을수록 서비스 장애에 대한 피해는 줄어든다.\n- Memcached가 Replication을 지원하지 않기 때문에 이렇게 손실을 감안하고 운영을 하는 경우도 있지만, 각 노드에 Backup 서버를 배치하여 직접 failover를 구현하고 가용성을 보장할 수 있다.\n\t- Backup 노드를 만드는 방법은 MySQL BinLog를 이용하거나 Primary-Secondary 서버 각 2대의 서버에 데이터를 쓰고 관리하는 방법 혹은 Repcached라는 패치를 통하여 Replication을 구현하는 등 다양한 방법이 존재한다.\n\n두 번째는 응답속도의 균일성이다.\n- Redis의 경우, 대규모 트래픽이 발생하면 Memcached에 비해 응답속도의 안정성이 떨어질 수 있다.\n\t- Redis는 메모리 할당을 하는데 있어서 jemalloc 알고리즘을 사용하여 매번 malloc과 free를 통하여 메모리를 할당하는데, 이는 메모리 단편화 문제를 발생시키고, 이러한 단편화 문제로 인하여 응답속도가 느려질 수 있기 때문이다.\n- Memcached의 경우 메모리 할당에 있어서 slab allocator를 사용하기 때문에 내부적으로 메모리 할당을 다시 하지 않고 관리할 수 있다.\n\t- [http://jake.dothome.co.kr/slub/](http://jake.dothome.co.kr/slub/)\n\n세 번째는 스레드 방식이다.\n- Redis는 싱글 스레드로 동작하고, Memcached는 멀티 스레드로 동작을 한다.\n- Redis가 싱글 스레드로 설계되었기 때문에 병목현상이 발생ㅎ"}
	],
	"edges":[
		{"id":"14262ed411618757","fromNode":"42a5762343f26cb1","fromSide":"right","toNode":"2e8bba703a9c0bfc","toSide":"left","label":"세션의 정합성 이슈"},
		{"id":"b6b2ddd2c204cf06","fromNode":"2e8bba703a9c0bfc","fromSide":"right","toNode":"e5462ca6ce8d8e8e","toSide":"left","label":"Sticky Session"},
		{"id":"86dddb7a3920d08c","fromNode":"e5462ca6ce8d8e8e","fromSide":"right","toNode":"ed1f565c95f83647","toSide":"left","label":"단점"},
		{"id":"67da05939e94a4f5","fromNode":"2e8bba703a9c0bfc","fromSide":"right","toNode":"4911a35e1853227e","toSide":"left","label":"세션 클러스터링"},
		{"id":"b9e794482c191879","fromNode":"4911a35e1853227e","fromSide":"right","toNode":"d01ca641c99f9608","toSide":"left","label":"All-to-all Session Replication?"},
		{"id":"de45e9f3ccf33b97","fromNode":"d01ca641c99f9608","fromSide":"right","toNode":"312f092453d8b904","toSide":"left","label":"단점"},
		{"id":"fa4c3a5e42fe924a","fromNode":"2e8bba703a9c0bfc","fromSide":"right","toNode":"a863b5e70815e4cc","toSide":"left","label":"세션 스토리지 분리"},
		{"id":"93a8d8b3b4cfc80e","fromNode":"312f092453d8b904","fromSide":"bottom","toNode":"d7d85387efaa06af","toSide":"top","label":"Primary-Secondary Session Replication"},
		{"id":"4d1d81026ab17d1c","fromNode":"a863b5e70815e4cc","fromSide":"right","toNode":"647776bbbf95d9cb","toSide":"left","label":"세션 스토리지로 In-Memory DB는 적합?"},
		{"id":"a23c8c9f34efd0e4","fromNode":"647776bbbf95d9cb","fromSide":"bottom","toNode":"bbf910ce7fa86bd7","toSide":"top","label":"어떤 형태의 DB가 적합할까"},
		{"id":"fb4e133065c5070e","fromNode":"bbf910ce7fa86bd7","fromSide":"right","toNode":"77ae443d3dce7a87","toSide":"left","label":"Redis & Memcached 공통점"},
		{"id":"00925d8bae8d49a4","fromNode":"bbf910ce7fa86bd7","fromSide":"right","toNode":"62c5ead0e6880baa","toSide":"left","label":"Redis vs Memcached"}
	]
}
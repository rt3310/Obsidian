### 잘못된 알고리즘 사용
알고리즘을 전산학적으로 다루는 경우 크게 두 가지에 대해 배운다.
- **알고리즘의 정당성(correctness) 증명**
- **시간/공간복잡도(efficiency) 분석**

1. **틀린 알고리즘**
	- 알고리즘이 왜 맞는지 논리적으로 설명할 자신이 있는지 잘 생각해보라. 그 자체로 좋은 공부가 된다.
	- 특히 특별한 경우, 최대값이나 최소값, 또는 경계 조건 같은 것들을 깊이 검토해보라
	- 알고리즘이 맞는지 틀린지 자신이 없다면, 데이터를 좀 더 넣어보면 도움이 된다.
		- 이 때, 다음 두 가지를 준비해서 비교해보는 것이 좋다. 작은 데이터에서 맞다면, 많은 경우 큰 데이터에서도 맞기 마련이다.
			- 랜덤한 데이터를 만드는 프로그램
			- 느려서 작은 데이터만 풀 수 있지만, 확실히 틀리지 않을 알고리즘
2. **절대 시간 안에 답이 나오지 않는 알고리즘**
	- 때로는 우주가 끝날 때까지 답이 나오지 않을 수도 있다. 채점자 입장에서는 알 수 없기 때문에, 일정 시간이 지나면 오답처리하고 종료하는 수밖에는 없다.
	- 얼마만큼의 시간이 걸릴지 어림잡아 보라.
		- 예를 들어, C/C++의 경우 조건문이나 덧셈 같은 연산이 1억번 정도 되면 1초 정도 걸린다고 어림할 수 있다 (다른 언어는 더 복잡하다).
	- 아슬하게 시간에 걸리는 경우는 보통 없다. 구현의 방법에 따라서 같은 알고리즘도 두세배 씩은 느릴 수 있다. 아예 방법이 잘못된 경우, 시간 제한이 1초인 문제에 대해 10초, 1시간, 1년 혹은 그 이상이 걸리게 된다.

### 테스트 케이스 여러 개가 한 번에 입력될 때, 적절히 초기화하지 않는 문제
테스트 케이스가 새로이 입력되는 것은 많은 경우 대부분의 변수에 대한 초기화가 다시 이루어져야 한다는 것을 뜻한다. 이 이유로 많은 사람들이 오답을 받는다.

할 수 있는 것들
- C++을 기준으로, 만약 문제를 해결하기 위해 사용하는 변수(객체)들의 생애 주기가 각 테스트케이스마다 끝나게끔 한다.
	- 이 경우 코드의 여러 부분에서 객체를 공유하려면 인자 등으로 전달해야 하기 때문에 복잡해지는 단점이 있다.
- 변수를 하나 새로 선언할 때마다 항상 초기화하는 습관을 들인다.
	- 종종, 원래 변수를 선언했을 당시의 생각으로는 굳이 초기화가 필요 없었으나 구현을 하는 도중에 필요해지는 경우도 있다. 자신이 없다면 모든 내용을 항상 초기화하는 것이 현명하다.
- 예제 입력을 넣을 경우에 같은 입력을 반복해서 한 차례 더 넣는다.
	- 예를 들어 예제가 3개의 테스트 케이스로 구성되어 있다면 대신 6개의 케이스를 넣고 ABCABC와 같이 반복되도록 하는 것이다. 이러한 예제 입력들은 아래로 갈수록 어려운/복잡한/답이 커지는 것인 경향이 있다. 다시 작은 케이스를 입력하는것만으로도 많은 경우 잘못을 알아차릴 수 있습니다.
### C 스타일 문자열에서 종결 문자를 고려하지 않고 배열 크기를 지정 (C/C++)
입력되는 문자열의 길이가 L이라고 하면 C string은 null-terminated인 것이 원칙이므로, 마지막에 `'\0'`(=0) 바이트가 붙는다.
따라서 문자열의 용도로 `char[]`를 선언하는 경우 그 길이가 최소 L+1만큼은 되어야 한다. 그렇지 않으면 표준 라이브러리에서 제공하는 입력과 출력을 포함하여(e.g. `scanf()`, `printf()`, `std::istream`/`cin`, `std::ostream`/`cout`) 문자열 지원을 대부분 사용할 수 없다.
```cpp
//문제 : 입력되는 문자열의 길이는 최대 50
char str[50]; // 잘못된 경우의 예
char str[51]; // 이렇게 하셔야합니다
char str[50+1]; // 자주 헷갈린다면 이렇게 표시하는 것도 한 방법
```

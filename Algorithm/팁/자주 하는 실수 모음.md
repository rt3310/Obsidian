### 잘못된 알고리즘 사용
알고리즘을 전산학적으로 다루는 경우 크게 두 가지에 대해 배운다.
- **알고리즘의 정당성(correctness) 증명**
- **시간/공간복잡도(efficiency) 분석**

1. **틀린 알고리즘**
	- 알고리즘이 왜 맞는지 논리적으로 설명할 자신이 있는지 잘 생각해보라. 그 자체로 좋은 공부가 된다.
	- 특히 특별한 경우, 최대값이나 최소값, 또는 경계 조건 같은 것들을 깊이 검토해보라
	- 알고리즘이 맞는지 틀린지 자신이 없다면, 데이터를 좀 더 넣어보면 도움이 된다.
		- 이 때, 다음 두 가지를 준비해서 비교해보는 것이 좋다. 작은 데이터에서 맞다면, 많은 경우 큰 데이터에서도 맞기 마련이다.
			- 랜덤한 데이터를 만드는 프로그램
			- 느려서 작은 데이터만 풀 수 있지만, 확실히 틀리지 않을 알고리즘
2. **절대 시간 안에 답이 나오지 않는 알고리즘**
	- 때로는 우주가 끝날 때까지 답이 나오지 않을 수도 있다. 채점자 입장에서는 알 수 없기 때문에, 일정 시간이 지나면 오답처리하고 종료하는 수밖에는 없다.
	- 얼마만큼의 시간이 걸릴지 어림잡아 보라.
		- 예를 들어, C/C++의 경우 조건문이나 덧셈 같은 연산이 1억번 정도 되면 1초 정도 걸린다고 어림할 수 있다 (다른 언어는 더 복잡하다).
	- 아슬하게 시간에 걸리는 경우는 보통 없다. 구현의 방법에 따라서 같은 알고리즘도 두세배 씩은 느릴 수 있다. 아예 방법이 잘못된 경우, 시간 제한이 1초인 문제에 대해 10초, 1시간, 1년 혹은 그 이상이 걸리게 된다.

### 테스트 케이스 여러 개가 한 번에 입력될 때, 적절히 초기화하지 않는 문제
테스트 케이스가 새로이 입력되는 것은 많은 경우 대부분의 변수에 대한 초기화가 다시 이루어져야 한다는 것을 뜻한다. 이 이유로 많은 사람들이 오답을 받는다.

할 수 있는 것들
- C++을 기준으로, 만약 문제를 해결하기 위해 사용하는 변수(객체)들의 생애 주기가 각 테스트케이스마다 끝나게끔 한다.
	- 이 경우 코드의 여러 부분에서 객체를 공유하려면 인자 등으로 전달해야 하기 때문에 복잡해지는 단점이 있다.
- 변수를 하나 새로 선언할 때마다 항상 초기화하는 습관을 들인다.
	- 종종, 원래 변수를 선언했을 당시의 생각으로는 굳이 초기화가 필요 없었으나 구현을 하는 도중에 필요해지는 경우도 있다. 자신이 없다면 모든 내용을 항상 초기화하는 것이 현명하다.
- 예제 입력을 넣을 경우에 같은 입력을 반복해서 한 차례 더 넣는다.
	- 예를 들어 예제가 3개의 테스트 케이스로 구성되어 있다면 대신 6개의 케이스를 넣고 ABCABC와 같이 반복되도록 하는 것이다. 이러한 예제 입력들은 아래로 갈수록 어려운/복잡한/답이 커지는 것인 경향이 있다. 다시 작은 케이스를 입력하는것만으로도 많은 경우 잘못을 알아차릴 수 있습니다.

### C 스타일 문자열에서 종결 문자를 고려하지 않고 배열 크기를 지정 (C/C++)
입력되는 문자열의 길이가 L이라고 하면 C string은 null-terminated인 것이 원칙이므로, 마지막에 `'\0'`(=0) 바이트가 붙는다.
따라서 문자열의 용도로 `char[]`를 선언하는 경우 그 길이가 최소 L+1만큼은 되어야 한다. 그렇지 않으면 표준 라이브러리에서 제공하는 입력과 출력을 포함하여(e.g. `scanf()`, `printf()`, `std::istream`/`cin`, `std::ostream`/`cout`) 문자열 지원을 대부분 사용할 수 없다.
```cpp
//문제 : 입력되는 문자열의 길이는 최대 50
char str[50]; // 잘못된 경우의 예
char str[51]; // 이렇게 하셔야합니다
char str[50+1]; // 자주 헷갈린다면 이렇게 표시하는 것도 한 방법
```

### 개행 문자 처리: 테스트 데이터 마지막줄에 '\n'가 없는 경우
테스트 데이터 마지막에 개행 문자가 존재한다는 보장은 없다. 구현과 환경에 따라 이 부분이 문제를 일으키기도 한다.  
구체적으로 예를 들어 Node.js 사용 시 on('line')에 이벤트를 걸다보면, 맨 마지막 줄이 잘려나가는 경우가 생길 수 있다.
```js
var input = [];
require('readline').createInterface(process.stdin, {})
.on('line', function(line) {
    input.push(line.trim());
}).on('close', function(a) {
    // '\n'가 없어 line이 호출되지 않았기 때문에,
    // input[input.length-1]에 마지막 줄이 들어있지 않음
}
```

그 경우, 아래와 같이 라인버퍼를 input 배열에 추가한다.
```js
var input = [];
require('readline').createInterface(process.stdin, {})
.on('line', function(line) {
    input.push(line.trim());
}).on('close', function(a) {
    if(this._line_buffer!='')
    {
        input.push(this._line_buffer);
        this._line_buffer = '';
    }
}
```

### 변수 범위 오버플로우
`int`의 표현 범위는 대부분의 환경에서 $-2^{31}$ ~ $2^{31-1}$ 사이이므로, 이 범위를 벗어나는 값을 계산하는 경우가 되면 예상과는 다른 이상한 값이 들어가게 된다.
이런 경우에는 64비트가 보장되는 정수 형태인 `long long`을 활용하거나 임의의 크기의 정수를 다룰 수 있는 정수 라이브러리(보통 BigInteger 라고 부릅니다)를 구현해서 해결해야된다.
BigInteger 클래스는 java만 쓰는 팀이 아닌 이상, 언제나 팀 노트에 들어가게 되는 약방의 감초와도 같은 라이브러리가 되겠습니다.
```cpp
// 틀린 예
int a = 1000000 * 1024; 
int b = 1<<50; 

// 옳은 예
long long a = 1000000LL * 1024;
long long b = 1LL << 50;
```

### cin/cout과 integer overflow
위와 관련된 사례로, 입력을 받을 때 integer overflow가 나는 경우도 흔히 하는 실수이다.
signed 32-bit integer의 범위를 넘어가는 정수를 `scanf("%d")` 로 받거나 `int x; cin >> x` 처럼 받지 않도록 주의한다.

- scanf와 64-bit integer (`long long`)을 사용하는 경우, "%I64d" 또는 "%lld" 의 포맷을 사용하면 된다 (이는 컴파일러/플랫폼마다 다를 수 있으니, 주의해야 한다).
	- 출력 시에도, 64-bit 정수를 printf("%d")로 출력하지 않도록 주의한다.
- C++의 경우, cin은 [이 코드](http://ideone.com/WQfpSn)에서처럼 한번 잘못된 입력(overflow 등)이 발생한 이후에는 완전히 오동작할 수 있어 주의해야 한다.

### 소수 처리
부동소수점 소수표현은 언제나 제한된 precision을 갖게 된다.
`float` < `double` < (`long double` - 제한된 상황에서만 사용 가능) 순서로 precision이 증가하게 되는데, 문제는 이러한 부동소수점 값들이 정확한 값은 아니라는 데 있다. 변수에다 1827361621525123.128371263을 넣으면 실제 들어가는 값은 제한된 precision으로 표현할 수 있는 범위 내의 값만 저장되게 된다는 것이다.
그렇기 때문에, 부동소수점 값들을 가지고는 **== 등의 연산을 사용하는 것을 자제**해야 한다. 부득이하게 == 연산을 사용해야 할 경우 `1e-12` 등 작은 epsilon 값을 더하거나 뺀 값을 가지고 비교하는 방법을 활용하도록 한다.
```cpp
// 틀린 예
if(a==b) ... 
// 옳은 예
if(fabs(a-b) < 1e-9) ...
```
`while(e-s < 1e-6) ...`: 이런 건 보통 결정 알고리즘에서 많이 활용하는 방식인데, 여러 모로 좋지 않으니(`e`나 `s`의 값이 각각 너무 큰 경우, 그리고 `1e-6`보다 더 작은 값을 epsilon으로 잡아야 하는 경우 등) 그냥 적당한 수를 매직 넘버로 넣어서 그 수만큼 iteration을 돌도록 하는게 좋다. `for(int i=0;i<200;i++) ...` 과 같은 식으로.

### I/O 처리 속도
cin, cout, istringstream 등의 C++ I/O는 getline(cin,str) 등의 함수를 활용하면 입력의 크기에 관계없이 입력을 받을 수 있어서 좋다. 하지만, 입력데이터가 큰 문제에서는 종종 TLE의 원인이 되기도 한다. 3M 정도 되는 입력 데이터를 cin으로 처리하면 데이터 읽어들이는 데에만 1초 이상 소모하게 되는 경우도 종종 있다.
반면 fgets 등의 함수를 활용하면 엄청난 속도차이를 경험할 수 있다. 다만 C 함수의 몇가지 제약조건은 주의해야 할 때도 있다.(fgets의 argument 등)
```cpp
// 느린 예
cin >> a; 
// 빠른 예
scanf("%d",&a);

// 느린 예 
string str; getline(cin,str); 
// 빠른 예
char str[1024]; 
if(fgets(str,1024,stdin) == 1024) 강제RE발생 // 입력 데이터의 크기를 유추할 때 사용
```
